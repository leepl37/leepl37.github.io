<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SMART POINTERS, ch 15 - tony</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="一切唯心造">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="../aboutNvim/nvim.html"><strong aria-hidden="true">2.</strong> aboutNvim&Linux</a></li><li class="chapter-item "><a href="../system/index.html"><strong aria-hidden="true">3.</strong> systemProgremming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../system/lecture1.html"><strong aria-hidden="true">3.1.</strong> lecture1</a></li><li class="chapter-item "><a href="../system/lecture2.html"><strong aria-hidden="true">3.2.</strong> lecture2</a></li></ol></li><li class="chapter-item expanded "><a href="../rust_book/intro.html"><strong aria-hidden="true">4.</strong> The Rust Programming Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rust_book/3_common_programming_concepts.html"><strong aria-hidden="true">4.1.</strong> Common Programming Concepts, Ch3</a></li><li class="chapter-item "><a href="../rust_book/4_understanding_ownership.html"><strong aria-hidden="true">4.2.</strong> UNDERSTANDING OWNERSHIP, Ch4</a></li><li class="chapter-item "><a href="../rust_book/5_using_structs_to_structure_related_data.html"><strong aria-hidden="true">4.3.</strong> USING STRUCTS TO STRUCTURE RELATED DATA, Ch5</a></li><li class="chapter-item "><a href="../rust_book/6_enums_and_pattern_matching.html"><strong aria-hidden="true">4.4.</strong> ENUMS AND PATTERN MATCHING, Ch6</a></li><li class="chapter-item "><a href="../rust_book/7_managing_growing_projects_with_packages_creates_and_modules.html"><strong aria-hidden="true">4.5.</strong> MANAGING GROWING PROJECTS WITH PACKAGES, CREATES, AND MODULES, Ch 7</a></li><li class="chapter-item "><a href="../rust_book/8_common_collections.html"><strong aria-hidden="true">4.6.</strong> COMMON COLLECTIONS, Ch 8</a></li><li class="chapter-item "><a href="../rust_book/9_error_handling.html"><strong aria-hidden="true">4.7.</strong> ERROR HANDLING, Ch 9</a></li><li class="chapter-item "><a href="../rust_book/10_generic_types_traits_and_lifetimes.html"><strong aria-hidden="true">4.8.</strong> GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10</a></li><li class="chapter-item "><a href="../rust_book/13_iterators_and_closures.html"><strong aria-hidden="true">4.9.</strong> FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13</a></li><li class="chapter-item expanded "><a href="../rust_book/15_smart_pointers.html" class="active"><strong aria-hidden="true">4.10.</strong> SMART POINTERS, ch 15</a></li></ol></li><li class="chapter-item "><a href="../example/example.html"><strong aria-hidden="true">5.</strong> Rust by example(번역)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello.html"><strong aria-hidden="true">5.1.</strong> Hello World 출력</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello/comment.html"><strong aria-hidden="true">5.1.1.</strong> Comments, 주석</a></li><li class="chapter-item "><a href="../example/hello/print.html"><strong aria-hidden="true">5.1.2.</strong> Formatted print, 출력에 관해</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello/debug_display.html"><strong aria-hidden="true">5.1.2.1.</strong> Debug & Display</a></li></ol></li><li class="chapter-item "><a href="../example/hello/testcase.html"><strong aria-hidden="true">5.1.3.</strong> TestCase: List(iter 개념과 Option 개념이 필요함)</a></li></ol></li><li class="chapter-item "><a href="../example/primitives.html"><strong aria-hidden="true">5.2.</strong> Primitives, 원시타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/primitives/arrays_and_slices.html"><strong aria-hidden="true">5.2.1.</strong> Arrays and Slices</a></li></ol></li><li class="chapter-item "><a href="../example/customtype.html"><strong aria-hidden="true">5.3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/customtype/testcase.html"><strong aria-hidden="true">5.3.1.</strong> TestCase: linked-list</a></li><li class="chapter-item "><a href="../example/customtype/constants.html"><strong aria-hidden="true">5.3.2.</strong> constants</a></li></ol></li><li class="chapter-item "><a href="../example/variablebinding.html"><strong aria-hidden="true">5.4.</strong> Variable Bindings,변수 바인딩</a></li><li class="chapter-item "><a href="../example/types.html"><strong aria-hidden="true">5.5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/types/casting_literals.html"><strong aria-hidden="true">5.5.1.</strong> casting_and_literals</a></li><li class="chapter-item "><a href="../example/types/inference_aliasing.html"><strong aria-hidden="true">5.5.2.</strong> inference_and_aliasing</a></li></ol></li><li class="chapter-item "><a href="../example/conversion/conversion.html"><strong aria-hidden="true">5.6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/conversion/from_and_into.html"><strong aria-hidden="true">5.6.1.</strong> From and Into, tryFrom and tryInto</a></li><li class="chapter-item "><a href="../example/conversion/to_and_from_strings.html"><strong aria-hidden="true">5.6.2.</strong> To and from Strings</a></li></ol></li><li class="chapter-item "><a href="../example/expressions.html"><strong aria-hidden="true">5.7.</strong> Expressions</a></li><li class="chapter-item "><a href="../example/flowAndControl/flow_and_control.html"><strong aria-hidden="true">5.8.</strong> Flow and Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/flowAndControl/for_and_iter.html"><strong aria-hidden="true">5.8.1.</strong> for_and_iter</a></li><li class="chapter-item "><a href="../example/flowAndControl/match.html"><strong aria-hidden="true">5.8.2.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/flowAndControl/pointer_and_ref.html"><strong aria-hidden="true">5.8.2.1.</strong> pointers/ref</a></li><li class="chapter-item "><a href="../example/flowAndControl/guards_and_binding.html"><strong aria-hidden="true">5.8.2.2.</strong> Guards/Binding</a></li></ol></li><li class="chapter-item "><a href="../example/flowAndControl/if_let_and_while_let.html"><strong aria-hidden="true">5.8.3.</strong> if let / while let</a></li></ol></li><li class="chapter-item "><a href="../example/functions/about_funtions.html"><strong aria-hidden="true">5.9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/functions/methods.html"><strong aria-hidden="true">5.9.1.</strong> Methods</a></li><li class="chapter-item "><a href="../example/functions/closures/closures.html"><strong aria-hidden="true">5.9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/functions/closures/capturing.html"><strong aria-hidden="true">5.9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="../example/functions/closures/as_input_parameters.html"><strong aria-hidden="true">5.9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="../example/functions/closures/as_output_parameters.html"><strong aria-hidden="true">5.9.2.3.</strong> As output parameters</a></li><li class="chapter-item "><a href="../example/functions/closures/iterator_searching_thro_iter.html"><strong aria-hidden="true">5.9.2.4.</strong> Examples in std</a></li></ol></li></ol></li><li class="chapter-item "><a href="../example/modules/modules.html"><strong aria-hidden="true">5.10.</strong> Modules</a></li><li class="chapter-item "><a href="../example/crates/crates.html"><strong aria-hidden="true">5.11.</strong> Crates</a></li><li class="chapter-item "><a href="../example/cargo/cargo.html"><strong aria-hidden="true">5.12.</strong> Cargo</a></li><li class="chapter-item "><a href="../example/attributes/attributes.html"><strong aria-hidden="true">5.13.</strong> Attributes, 속성</a></li><li class="chapter-item "><a href="../example/generics/generics.html"><strong aria-hidden="true">5.14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/generics/generic_associated_phantom.html"><strong aria-hidden="true">5.14.1.</strong> Associated items & Phantom type parameters</a></li></ol></li><li class="chapter-item "><a href="../example/scoping/scoping.html"><strong aria-hidden="true">5.15.</strong> Scoping rules-오너쉽, 참조, 라이프타임</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/scoping/ownership_move_borrowing.html"><strong aria-hidden="true">5.15.1.</strong> Ownership Move Borrowing</a></li><li class="chapter-item "><a href="../example/scoping/lifetimes.html"><strong aria-hidden="true">5.15.2.</strong> Lifetimes</a></li></ol></li><li class="chapter-item "><a href="../example/traits.html"><strong aria-hidden="true">5.16.</strong> Traits</a></li><li class="chapter-item "><a href="../example/macro.html"><strong aria-hidden="true">5.17.</strong> macro</a></li></ol></li><li class="chapter-item "><li class="part-title">Will be Deleted</li><li class="chapter-item affix "><li class="part-title">Datestructre and algorithms</li><li class="chapter-item "><a href="../dataStructureAndAlgorithms/intro.html"><strong aria-hidden="true">6.</strong> 데이터 구조와 알고리즘</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dataStructureAndAlgorithms/section1.html"><strong aria-hidden="true">6.1.</strong> Section 1</a></li></ol></li><li class="chapter-item "><a href="../rustOS/intro.html"><strong aria-hidden="true">7.</strong> writing an OS in Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rustOS/freestandingRustBinary.html"><strong aria-hidden="true">7.1.</strong> A Freestanding Rust Binary</a></li></ol></li><li class="chapter-item "><li class="part-title">SP Manual</li><li class="chapter-item "><a href="../spmanual/start.html"><strong aria-hidden="true">8.</strong> SP MANUAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spmanual/chapter_1.html"><strong aria-hidden="true">8.1.</strong> ch1</a></li><li class="chapter-item "><a href="../spmanual/chapter_2.html"><strong aria-hidden="true">8.2.</strong> ch2</a></li><li class="chapter-item "><a href="../spmanual/chapter_3.html"><strong aria-hidden="true">8.3.</strong> ch3</a></li><li class="chapter-item "><a href="../spmanual/chapter_4.html"><strong aria-hidden="true">8.4.</strong> ch4</a></li><li class="chapter-item "><a href="../spmanual/chapter_5.html"><strong aria-hidden="true">8.5.</strong> ch5</a></li><li class="chapter-item "><a href="../spmanual/etc.html"><strong aria-hidden="true">8.6.</strong> etc</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">tony</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="smart-pointers-ch-15"><a class="header" href="#smart-pointers-ch-15">SMART POINTERS, ch 15</a></h1>
<p>a pointer is a general concept for a variable that contains an address in memory. 
this pointer is point at some other data. </p>
<p><em>Smart Pointers</em> are data structrue not only act like pointer but also have additional metadata and capabilities. </p>
<p><em>reference counting</em> smart pointer type. 
* having a multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data. </p>
<h4 id="difference"><a class="header" href="#difference">difference</a></h4>
<ul>
<li>references are pointers that only borrow data, in contrast smart pointers own the data they point to. </li>
</ul>
<p>ex) String, Vec<T> 
* String ensuring its data will always be valid UTF-8 </p>
<ul>
<li>Smart pointers are usually implemented using structs. 
<ul>
<li>
<p>smart pointers implement the Deref and Drop traits. </p>
<ul>
<li>dref trait is let smart pointer act like a reference. </li>
<li>drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We'll cover the most common smart pointets in the standard library: </p>
<ul>
<li>
<p>Box<T> for allocating values on the heap </p>
</li>
<li>
<p>Rc<T>, a reference counting type that enables multiple ownership</p>
</li>
<li>
<p>Ref<T>, and RefMut<T>, accessed through RefCell<T>, a type that enforces the borrowing rules at runtime instead of compile time. </p>
</li>
<li>
<p>In addition, we'll cover the interior mutaiblity pattern where an immutable type exposes an API for mutating an interior value. </p>
</li>
<li>
<p>reference cycles : how they can leak memory and how to prevent them. </p>
</li>
</ul>
<h3 id="using-box-to-point-to-data-on-the-heap"><a class="header" href="#using-box-to-point-to-data-on-the-heap">Using Box<T> to Point to Data on the Heap</a></h3>
<ul>
<li>
<p>storing data on the heap rather than the stack. </p>
</li>
<li>
<p>Boxes don't have performance overhead</p>
</li>
<li>
<p>use case of Box<T></p>
<ul>
<li>
<p>when you have a type whose size can't be known at compile time and you want to use a value of that type in a context that requires an exact size</p>
<ul>
<li>Enabling Recursive Types with Boxes </li>
</ul>
</li>
<li>
<p>when you have a large amount of data and you want to transfer ownership but ensure the data won't be copied when you do so </p>
<ul>
<li>transferring ownership of large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store large amount of data on the heap in a box. then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. </li>
</ul>
</li>
<li>
<p>when you want to own a value and you care only that it's a type that implements a particular trait rather than being of a specific type</p>
<ul>
<li>chapter 17. </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="using-a-box-to-store-data-on-the-heap"><a class="header" href="#using-a-box-to-store-data-on-the-heap">Using a Box<T> to Store Data on the Heap</a></h3>
<p>Before  we discuss this use case for Box<T>, cover syntax and how to interact with values stored within a Box<T>. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let v = Box::new(value);

<span class="boring">}</span></code></pre></pre>
<h3 id="enabling-recursive-types-with-boxes"><a class="header" href="#enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></h3>
<p>Rust does not know how much space a value of a recursive type needs -&gt; boxes have a known size. </p>
<p>you can have recursive type in boxes. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum List {
	Cons(i32, List),
	nil,
}

// this can not compile because in the list of Cons's size is not known at compile time. 


enum List {
	Cons(i32, Box&lt;List&gt;),
	nil,
}

<span class="boring">}</span></code></pre></pre>
<p><img src="./img/infinite_cons.png" alt="infinite" width = 300 /> </p>
ex) image of List 
<h3 id="computing-the-size-of-a-nonrecursive-type"><a class="header" href="#computing-the-size-of-a-nonrecursive-type">Computing the Size of a NonRecursive Type</a></h3>
<pre><code class="language-Rust">
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

</code></pre>
<p>to determine how much space to allocate for a Message value, Rust goes through each of the variants to see which variant needs the most space. </p>
<p>contrast, Cons list need size of i32 and size of List. the important thing is the size of list is not known at compile time when you declear the enum.</p>
<h3 id="using-box-to-get-a-recursive-type-with-a-known-size"><a class="header" href="#using-box-to-get-a-recursive-type-with-a-known-size">Using Box<T> to get a Recursive type with a known size</a></h3>
<p>store the value indirectly by storing pointer to the value. </p>
<p>Box<T> is a pointer, rust know much size it needs. </p>
<p>so inside of List of Cons, we can put Box<T> that pointer to the value of List and so on. </p>
<pre><code class="language-rs">enum List {
    Cons(i32, Box&lt;List&gt;),
     Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}

</code></pre>
<p>so it looks like this. </p>
<p><img src="./img/box<t>_type.png" alt="box_type" width = 300 /> </p>
<p>usize is the pointer that point to the value in the heap memory. </p>
<h3 id="treating-smart-pointer-like-a-regular-reference-with-the-deref-trait"><a class="header" href="#treating-smart-pointer-like-a-regular-reference-with-the-deref-trait">Treating smart pointer like a regular reference with the deref trait.</a></h3>
<p>by implementing deref trait you can use it like a regular reference and also used as smart pointer.</p>
<h3 id="following-the-pointer-to-the-value-with-the-dereference-operator"><a class="header" href="#following-the-pointer-to-the-value-with-the-dereference-operator">Following the pointer to the value with the dereference operator.</a></h3>
<pre><code class="language-rs">
fn main() {

	let x = 5;
	let y = &amp;x;

	assert_eq!(x, y);
}

</code></pre>
<ul>
<li>this code will fail because x and y have different type. 
<ul>
<li>x is i32, y is reference i32. </li>
</ul>
</li>
</ul>
<h3 id="using-box-like-a-reference"><a class="header" href="#using-box-like-a-reference">Using Box<T> like a reference</a></h3>
<pre><code class="language-rs">
fn main() {

	let x = 5;
	let y = Box::new(x);  // y is the pointer to the value on the heap

	assert_eq!(x, *y);
}

</code></pre>
<h3 id="implementing-the-deref"><a class="header" href="#implementing-the-deref">Implementing the deref</a></h3>
<pre><code class="language-rs">
use std::ops::Deref;

struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
	fn new(val : T) -&gt; MyBox(T) {
		MyBox(val)
	}
}


impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
	type Target = T; 

	fn deref(&amp;self) -&gt; &amp;Target {
		&amp;self.0
	}

}

fn main() {

	let a = 5;
	let b = MyBox(a);

	assert_eq!(a, *b);

}


</code></pre>
<p>dref impl makes * operator returns reference to the value instead of return value without reference. 
because it cause deref fn takes ownership of parameter.</p>
<p>it actually looks like this *(a.deref()).</p>
<h3 id="implicit-deref-coersion-with-functions-and-methods"><a class="header" href="#implicit-deref-coersion-with-functions-and-methods">Implicit deref coersion with functions and methods</a></h3>
<p>deref coersion is reference changes into original type that functions and methods expected. </p>
<pre><code class="language-Rust  editable">
fn main() {

	fn hello(val : &amp;str) {
		println!(&quot; hey, {}&quot;, val);
	}


	let a = String::new(&quot;whats up&quot;);

	hello(&amp;a);
	
	// &amp;(*a)[..] -&gt; if we don't use deref coercion we should write down as it is. 
}


</code></pre>
<p>std lib also implement deref coersion on String struct thats why string to reference can be str to reference.</p>
<h3 id="how-deref-coercion-interact-with-mutability"><a class="header" href="#how-deref-coercion-interact-with-mutability">How deref coercion interact with mutability</a></h3>
<ul>
<li>
<p>From &amp;T to &amp;U when T: Dref&lt;Target=U&gt; </p>
</li>
<li>
<p>From &amp;mut T to &amp;mut U when T: DrefMut&lt;Target=U&gt;</p>
</li>
<li>
<p>From &amp;mut T to U when T: Dref&lt;Target=U&gt;</p>
<ul>
<li>note that mutable references can be changed into immutable but reverse is not possible. </li>
<li>think about ownership and borrowing rules. </li>
</ul>
</li>
</ul>
<h3 id="running-code-on-cleanup-with-the-drop-trait"><a class="header" href="#running-code-on-cleanup-with-the-drop-trait">Running code on cleanup with the drop trait</a></h3>
<ul>
<li>
<p>drop trait can be useful when we release resources like files or network connections. </p>
</li>
<li>
<p>drop trait is almost used to implement on smart pointer this is why we are introducting the trait in this chapter. </p>
<ul>
<li>Box<T> needs to drop to deallocate on heap memory. </li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
struct CustomSmartPointer {
      data: String,
  }

impl Drop for CustomSmartPointer {
      fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
      }
  }


</code></pre>
<h3 id="dropping-a-value-early-with-stdmendrop"><a class="header" href="#dropping-a-value-early-with-stdmendrop">Dropping a value early with std::men::drop</a></h3>
<p>Disabling drop isn't usually necessary; the whole point of the Drop triat is that is's taken care of automatically. 
however, you might want to clean up a value early. </p>
<p>one example is when using smart pointers that manage locks: you might want to force the drop method that release the lock to run so other code in the same scope can acquire the lock. </p>
<p>but rust does not let you call the Drop trait's drop method manually; instead you have to call the std::mem::drop function if you want to drop value before the end of the its scope. </p>
<p>and also using value.drop() method ealy is not allowed.</p>
<pre><code class="language-sh">
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed


</code></pre>
<ul>
<li>destructor is the general programming term for a function that cleans up an instance. </li>
<li>it causes double free error. rust would still automatically call drop on the value at the end of main. </li>
</ul>
<pre><code class="language-rs">
	 drop(value) // from std::mem::drop , it works. for early droping value 
</code></pre>
<h3 id="rc-the-reference-counted-smart-pointer"><a class="header" href="#rc-the-reference-counted-smart-pointer">Rc<T>, the reference counted smart pointer</a></h3>
<p>use Rc<T> type when we want to allocate some date on the heap for multiple parts of program to read and we can't determine at compile time which part will finish using the data last</p>
<ul>
<li>note that Rc<T> is only used in single thread scenario. </li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust_book/13_iterators_and_closures.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../example/example.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust_book/13_iterators_and_closures.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../example/example.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
