<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13 - tony</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="一切唯心造">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="../aboutNvim/nvim.html"><strong aria-hidden="true">2.</strong> aboutNvim&Linux</a></li><li class="chapter-item "><a href="../system/index.html"><strong aria-hidden="true">3.</strong> systemProgremming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../system/lecture1.html"><strong aria-hidden="true">3.1.</strong> lecture1</a></li><li class="chapter-item "><a href="../system/lecture2.html"><strong aria-hidden="true">3.2.</strong> lecture2</a></li></ol></li><li class="chapter-item expanded "><a href="../rust_book/intro.html"><strong aria-hidden="true">4.</strong> The Rust Programming Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rust_book/3_common_programming_concepts.html"><strong aria-hidden="true">4.1.</strong> Common Programming Concepts, Ch3</a></li><li class="chapter-item "><a href="../rust_book/4_understanding_ownership.html"><strong aria-hidden="true">4.2.</strong> UNDERSTANDING OWNERSHIP, Ch4</a></li><li class="chapter-item "><a href="../rust_book/5_using_structs_to_structure_related_data.html"><strong aria-hidden="true">4.3.</strong> USING STRUCTS TO STRUCTURE RELATED DATA, Ch5</a></li><li class="chapter-item "><a href="../rust_book/6_enums_and_pattern_matching.html"><strong aria-hidden="true">4.4.</strong> ENUMS AND PATTERN MATCHING, Ch6</a></li><li class="chapter-item "><a href="../rust_book/7_managing_growing_projects_with_packages_creates_and_modules.html"><strong aria-hidden="true">4.5.</strong> MANAGING GROWING PROJECTS WITH PACKAGES, CREATES, AND MODULES, Ch 7</a></li><li class="chapter-item "><a href="../rust_book/8_common_collections.html"><strong aria-hidden="true">4.6.</strong> COMMON COLLECTIONS, Ch 8</a></li><li class="chapter-item "><a href="../rust_book/9_error_handling.html"><strong aria-hidden="true">4.7.</strong> ERROR HANDLING, Ch 9</a></li><li class="chapter-item "><a href="../rust_book/10_generic_types_traits_and_lifetimes.html"><strong aria-hidden="true">4.8.</strong> GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10</a></li><li class="chapter-item expanded "><a href="../rust_book/13_iterators_and_closures.html" class="active"><strong aria-hidden="true">4.9.</strong> FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13</a></li><li class="chapter-item "><a href="../rust_book/14_more_about_cargo_and_creates_io.html"><strong aria-hidden="true">4.10.</strong> MORE ABOUT CARGO AND CREATES.IO, ch 14</a></li><li class="chapter-item "><a href="../rust_book/15_smart_pointers.html"><strong aria-hidden="true">4.11.</strong> SMART POINTERS, ch 15</a></li><li class="chapter-item "><a href="../rust_book/16_fearless_concurrency.html"><strong aria-hidden="true">4.12.</strong> Fearless Concurrency, Ch 16</a></li><li class="chapter-item "><a href="../rust_book/17_object-oriented_programming_features_of_rust.html"><strong aria-hidden="true">4.13.</strong> Object Oriented programming, Ch 17</a></li><li class="chapter-item "><a href="../rust_book/19_advanced_features.html"><strong aria-hidden="true">4.14.</strong> Advanced Features, Ch 19</a></li></ol></li><li class="chapter-item "><a href="../example/example.html"><strong aria-hidden="true">5.</strong> Rust by example(번역)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello.html"><strong aria-hidden="true">5.1.</strong> Hello World 출력</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello/comment.html"><strong aria-hidden="true">5.1.1.</strong> Comments, 주석</a></li><li class="chapter-item "><a href="../example/hello/print.html"><strong aria-hidden="true">5.1.2.</strong> Formatted print, 출력에 관해</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello/debug_display.html"><strong aria-hidden="true">5.1.2.1.</strong> Debug & Display</a></li></ol></li><li class="chapter-item "><a href="../example/hello/testcase.html"><strong aria-hidden="true">5.1.3.</strong> TestCase: List(iter 개념과 Option 개념이 필요함)</a></li></ol></li><li class="chapter-item "><a href="../example/primitives.html"><strong aria-hidden="true">5.2.</strong> Primitives, 원시타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/primitives/arrays_and_slices.html"><strong aria-hidden="true">5.2.1.</strong> Arrays and Slices</a></li></ol></li><li class="chapter-item "><a href="../example/customtype.html"><strong aria-hidden="true">5.3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/customtype/testcase.html"><strong aria-hidden="true">5.3.1.</strong> TestCase: linked-list</a></li><li class="chapter-item "><a href="../example/customtype/constants.html"><strong aria-hidden="true">5.3.2.</strong> constants</a></li></ol></li><li class="chapter-item "><a href="../example/variablebinding.html"><strong aria-hidden="true">5.4.</strong> Variable Bindings,변수 바인딩</a></li><li class="chapter-item "><a href="../example/types.html"><strong aria-hidden="true">5.5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/types/casting_literals.html"><strong aria-hidden="true">5.5.1.</strong> casting_and_literals</a></li><li class="chapter-item "><a href="../example/types/inference_aliasing.html"><strong aria-hidden="true">5.5.2.</strong> inference_and_aliasing</a></li></ol></li><li class="chapter-item "><a href="../example/conversion/conversion.html"><strong aria-hidden="true">5.6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/conversion/from_and_into.html"><strong aria-hidden="true">5.6.1.</strong> From and Into, tryFrom and tryInto</a></li><li class="chapter-item "><a href="../example/conversion/to_and_from_strings.html"><strong aria-hidden="true">5.6.2.</strong> To and from Strings</a></li></ol></li><li class="chapter-item "><a href="../example/expressions.html"><strong aria-hidden="true">5.7.</strong> Expressions</a></li><li class="chapter-item "><a href="../example/flowAndControl/flow_and_control.html"><strong aria-hidden="true">5.8.</strong> Flow and Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/flowAndControl/for_and_iter.html"><strong aria-hidden="true">5.8.1.</strong> for_and_iter</a></li><li class="chapter-item "><a href="../example/flowAndControl/match.html"><strong aria-hidden="true">5.8.2.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/flowAndControl/pointer_and_ref.html"><strong aria-hidden="true">5.8.2.1.</strong> pointers/ref</a></li><li class="chapter-item "><a href="../example/flowAndControl/guards_and_binding.html"><strong aria-hidden="true">5.8.2.2.</strong> Guards/Binding</a></li></ol></li><li class="chapter-item "><a href="../example/flowAndControl/if_let_and_while_let.html"><strong aria-hidden="true">5.8.3.</strong> if let / while let</a></li></ol></li><li class="chapter-item "><a href="../example/functions/about_funtions.html"><strong aria-hidden="true">5.9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/functions/methods.html"><strong aria-hidden="true">5.9.1.</strong> Methods</a></li><li class="chapter-item "><a href="../example/functions/closures/closures.html"><strong aria-hidden="true">5.9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/functions/closures/capturing.html"><strong aria-hidden="true">5.9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="../example/functions/closures/as_input_parameters.html"><strong aria-hidden="true">5.9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="../example/functions/closures/as_output_parameters.html"><strong aria-hidden="true">5.9.2.3.</strong> As output parameters</a></li><li class="chapter-item "><a href="../example/functions/closures/iterator_searching_thro_iter.html"><strong aria-hidden="true">5.9.2.4.</strong> Examples in std</a></li></ol></li></ol></li><li class="chapter-item "><a href="../example/modules/modules.html"><strong aria-hidden="true">5.10.</strong> Modules</a></li><li class="chapter-item "><a href="../example/crates/crates.html"><strong aria-hidden="true">5.11.</strong> Crates</a></li><li class="chapter-item "><a href="../example/cargo/cargo.html"><strong aria-hidden="true">5.12.</strong> Cargo</a></li><li class="chapter-item "><a href="../example/attributes/attributes.html"><strong aria-hidden="true">5.13.</strong> Attributes, 속성</a></li><li class="chapter-item "><a href="../example/generics/generics.html"><strong aria-hidden="true">5.14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/generics/generic_associated_phantom.html"><strong aria-hidden="true">5.14.1.</strong> Associated items & Phantom type parameters</a></li></ol></li><li class="chapter-item "><a href="../example/scoping/scoping.html"><strong aria-hidden="true">5.15.</strong> Scoping rules-오너쉽, 참조, 라이프타임</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/scoping/ownership_move_borrowing.html"><strong aria-hidden="true">5.15.1.</strong> Ownership Move Borrowing</a></li><li class="chapter-item "><a href="../example/scoping/lifetimes.html"><strong aria-hidden="true">5.15.2.</strong> Lifetimes</a></li></ol></li><li class="chapter-item "><a href="../example/traits.html"><strong aria-hidden="true">5.16.</strong> Traits</a></li><li class="chapter-item "><a href="../example/macro.html"><strong aria-hidden="true">5.17.</strong> macro</a></li></ol></li><li class="chapter-item "><a href="../dataStructureAndAlgorithms/intro.html"><strong aria-hidden="true">6.</strong> 데이터 구조와 알고리즘</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dataStructureAndAlgorithms/section1.html"><strong aria-hidden="true">6.1.</strong> Section 1</a></li></ol></li><li class="chapter-item "><li class="part-title">SP Manual</li><li class="chapter-item "><a href="../spmanual/start.html"><strong aria-hidden="true">7.</strong> SP MANUAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spmanual/chapter_1.html"><strong aria-hidden="true">7.1.</strong> ch1</a></li><li class="chapter-item "><a href="../spmanual/chapter_2.html"><strong aria-hidden="true">7.2.</strong> ch2</a></li><li class="chapter-item "><a href="../spmanual/chapter_3.html"><strong aria-hidden="true">7.3.</strong> ch3</a></li><li class="chapter-item "><a href="../spmanual/chapter_4.html"><strong aria-hidden="true">7.4.</strong> ch4</a></li><li class="chapter-item "><a href="../spmanual/chapter_5.html"><strong aria-hidden="true">7.5.</strong> ch5</a></li><li class="chapter-item "><a href="../spmanual/etc.html"><strong aria-hidden="true">7.6.</strong> etc</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">tony</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functional-language-featrues--iterators-and-closures-ch-13"><a class="header" href="#functional-language-featrues--iterators-and-closures-ch-13">FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13</a></h1>
<p>functional programming : functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth. </p>
<p>we' ll cover:</p>
<ul>
<li>
<p>Closures, a function like construct you can store in a variable. </p>
</li>
<li>
<p>Iterators, a way of processing a series of elements</p>
</li>
</ul>
<p>pattern matching and enums are influenced by the functional style. Mastering closures and iterators is a key to learn Rust. </p>
<h3 id="closures--anonymouse-functions-that-can-chapture-their-environment"><a class="header" href="#closures--anonymouse-functions-that-can-chapture-their-environment">Closures : Anonymouse functions that can chapture their environment</a></h3>
<ul>
<li>
<p>rust's closures are value that can contain function. </p>
</li>
<li>
<p>it can be passed as arguments to other functions. </p>
</li>
</ul>
<h3 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure type inference and annotation</a></h3>
<ul>
<li>
<p>function's type annotations are required on functions because they're part of an explicit interface exposed to your users.</p>
</li>
<li>
<p>closure definitions will have one concrete type inferred for each of their parameters and for their return value. </p>
<ul>
<li>types are locked into the closure. </li>
</ul>
</li>
</ul>
<h3 id="storing-closures-using-generic-parameters-and-the-fn-traits"><a class="header" href="#storing-closures-using-generic-parameters-and-the-fn-traits">Storing closures using generic parameters and the fn traits.</a></h3>
<ul>
<li>memoization or lazy evaluation. 
<ul>
<li>
<p>create struct that will hold the closure and the resulting value of calling the closure. the struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn't have to be responsible for saving and reusing the result. </p>
</li>
<li>
<p>Memoization refers to the technique of caching the results of a function call so that subsequent calls with the same arguments can be returned quickly from the cache instead of recomputing the result. This can be useful in cases where a function is computationally expensive or has side effects that can be avoided with caching. Memoization can be implemented using a HashMap or a similar data structure in Rust.</p>
</li>
</ul>
</li>
</ul>
<p>Lazy evaluation, on the other hand, refers to the evaluation of an expression only when its value is actually needed, rather than eagerly evaluating it before it is needed. This can be useful for optimizing performance and reducing memory usage in cases where not all values need to be computed or stored at once. In Rust, lazy evaluation can be implemented using closures, iterators, and the lazy_static crate.</p>
<p>Both memoization and lazy evaluation can be powerful techniques for optimizing Rust code, but they are best used judiciously and in cases where they provide a clear benefit.</p>
<pre><code class="language-rs">
struct Cacher&lt;T&gt; 
   where T: Fn(u32) -&gt; u32 {
   	calculation : T, 
   	value : Option&lt;u32&gt;, 
   }


</code></pre>
<ul>
<li>
<p>Note </p>
<p><em>functions can implement all three of the Fn traits, too. If what we want to do doesn not require capturing a value from the environment, we can use a function rather than a clousre where we need something that implements an Fn trait</em></p>
</li>
</ul>
<pre><code class="language-rs">impl&lt;T&gt; Cacher&lt;T&gt;
  ➊ where T: Fn(u32) -&gt; u32
{
  ➋ fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
      ➌ Cacher {
             calculation,
             value: None,
         }
     }
 ➍ fn value(&amp;mut self, arg: u32) -&gt; u32 {
         match self.value {
         ➎ Some(v) =&gt; v,
         ➏ None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
           },
         }
  }
}


</code></pre>
<pre><code class="language-rs">

fn generate_workout(intensity: u32, random_number: u32) {
  ➊ let mut expensive_result = Cacher::new(|num| {
         println!(&quot;calculating slowly...&quot;);
         thread::sleep(Duration::from_secs(2));
         num
     });


    if intensity &lt; 25 {
         println!(
             &quot;Today, do {} pushups!&quot;,
          ➋ expensive_result.value(intensity)
         );
         println!(
             &quot;Next, do {} situps!&quot;,
          ➌ expensive_result.value(intensity)
         );
     } else {
         if random_number == 3 {
             println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
         } else {
             println!(
                 &quot;Today, run for {} minutes!&quot;,
              ➍ expensive_result.value(intensity)
             );
	 }
    }
}


</code></pre>
<h3 id="limitations-of-the-cacher-implementation"><a class="header" href="#limitations-of-the-cacher-implementation">Limitations of the cacher implementation</a></h3>
<ul>
<li>
<p>problem is that the first time we called c.value with 1, the Cacher instance saved Some(1) in self.value. Thereafter, no matter what we pass in to the value method, it will always return 1.</p>
</li>
<li>
<p>to fix this problem using a hash map -&gt; the key will the are <strong>arg</strong> values that are passed in, and the value of key will be the result of caluation. </p>
</li>
</ul>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the environment with closures</a></h3>
<pre><code class="language-rs">
fn main() {

	let x = 4; 

	let equal_to_x = |z| z == x; 

	let y = 4; 

	assert!(equal_to_x(y));

}


</code></pre>
<ul>
<li>
<p>when a closure captures a value from its environment, it uses memory to store the values for use in the closure body</p>
</li>
<li>
<p>but this case is overhead so we do not want to pay in more common cases where we want to execute code such as funtions. </p>
</li>
</ul>
<h4 id="three-ways-of-capturing"><a class="header" href="#three-ways-of-capturing">three ways of capturing</a></h4>
<ul>
<li>
<p>taking ownership, borrowing mutably, and borrowing immutably. </p>
<ul>
<li>
<p><strong>FnOnce</strong> : taking ownership of a variable, it can be called only once. </p>
</li>
<li>
<p><strong>FnMut</strong> : mutably borrows values, can change the environment. </p>
</li>
<li>
<p><strong>Fn</strong> : borrows values from the environment immutably. </p>
</li>
</ul>
</li>
<li>
<p>rust infers which trait to use based on how the closure uses the values from the environment. </p>
</li>
<li>
<p>take ownership of the values, move keyword force to take the value of ownership. </p>
<ul>
<li>this technique is mostyly useful when passing a closure to a new thread to move the data so it's owned by the new thread </li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
fn main() {
 
	 let x = vec![1, 2, 3];
	 
	 let equal_to_x = move |z| z == x;
	 
	 // this print macro does not work because x has been moved. 
	 println!(&quot;can't use x here: {:?}&quot;, x);

	 let y = vec![1, 2, 3];
	 
	 assert!(equal_to_x(y));
}

</code></pre>
<h3 id="processing-a-series-of-items-with-iterators"><a class="header" href="#processing-a-series-of-items-with-iterators">Processing a Series of Items with Iterators</a></h3>
<p>An iterators is responsible for the logic of iterating over each item an determining when the sequence has finished. </p>
<p>In Rust, iterators are <strong>lazy</strong>, they have no effect until you call methods that consume the iterator to use it up. </p>
<pre><code class="language-rs">
let v1 = vec![1,2,3];

// creating iterator using iter() method that implemented on Vec&lt;T&gt;
let v1_iter = v1.iter();

</code></pre>
<h3 id="the-iterator-trait-and-the-next-method"><a class="header" href="#the-iterator-trait-and-the-next-method">The Iterator Trait and the next Method</a></h3>
<pre><code class="language-rs">
pub trait Iterator {
	type Item;
	
	fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
		//elided
	}

}

</code></pre>
<ul>
<li>
<p>type Item and Self::Item, defining an associated type with this trait. </p>
</li>
<li>
<p>talk about associated types in depth in chapter 19.</p>
</li>
<li>
<p>Implementing the Iterator trait requires that you also define an Item type, and this Item type is used in the return type of the next mehtod. </p>
</li>
<li>
<p>the <strong>Iterator</strong> trait only requires implementors to define one method: the <strong>next</strong> method, which returns one item of the iterator. </p>
</li>
<li>
<p>calling the <strong>next</strong> method on an iterator chages internal state so it needs to be mutable. </p>
</li>
<li>
<p>iterators uses to keep track of where it is in the sequence. </p>
</li>
<li>
<p>this called consumes or uses up the iterator. </p>
</li>
<li>
<p>each call to <strong>next</strong> eats up an item from the iterator. </p>
</li>
<li>
<p>iter_mut() - take mutable reference, into_iter() - take ownership, iter() - reference.</p>
</li>
</ul>
<h3 id="methods-that-consume-the-iterator"><a class="header" href="#methods-that-consume-the-iterator">Methods That Consume the Iterator.</a></h3>
<ul>
<li>
<p>Methods that call <strong>next</strong> are refered to as <strong>consuming adaptors</strong>.</p>
</li>
<li>
<p>also <strong>sum method</strong>. </p>
</li>
</ul>
<h3 id="methods-that-produce-otehr-iterators"><a class="header" href="#methods-that-produce-otehr-iterators">Methods That Produce Otehr Iterators.</a></h3>
<ul>
<li>
<p>change iteraotrs into different kinds of iterators, <strong>iterator adaptors</strong> </p>
</li>
<li>
<p>iterators are lazy, you need to call one of the consuming adaptor methods to get iterator adaptors.</p>
</li>
</ul>
<pre><code class="language-rs">
let v1 = vec![1,2,3];

v1.iter().map(|x| x + 1);

</code></pre>
<ul>
<li>
<p>warning - unused <code>std::iter::Map</code> which must be used: iterator adaptors are lazy and do nothing unless consumed.</p>
</li>
<li>
<p>to fix this issue, we need to call <strong>collect()</strong> method. </p>
<ul>
<li>consume the new iterator and create a vector. </li>
</ul>
</li>
</ul>
<h3 id="using-closures-that-capture-their-environment"><a class="header" href="#using-closures-that-capture-their-environment">Using Closures That Capture Their Environment.</a></h3>
<pre><code class="language-rs">#[derive(PartialEq, Debug)]
   struct Shoe {
       size: u32,
       style: String,
   }
 ➊ fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    ➋ shoes.into_iter()
        ➌ .filter(|s| s.size == shoe_size
        ➍ .collect()
   }
    #[test]
   fn filters_by_size() {
       let shoes = vec![
           Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
           Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
           Shoe { size: 10, style: String::from(&quot;boot&quot;) },
       ];
    let in_my_size = shoes_in_my_size(shoes, 10);
       assert_eq!(
           in_my_size,
           vec![
               Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
               Shoe { size: 10, style: String::from(&quot;boot&quot;) },
           ]
      );
   }


</code></pre>
<ul>
<li><strong>filter()</strong> method example.</li>
</ul>
<h3 id="creating-our-own-iterators-with-the-iterator-trait"><a class="header" href="#creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the Iterator Trait.</a></h3>
<pre><code class="language-rs">
struct Counter {
    count: u32,
}


impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}


impl Iterator for Counter {
    	
	type Item = u32;

	fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
	        if self.count &lt; 5 {
	            self.count += 1;
	            Some(self.count)
	        } else {
	            None
	        }
	    }
}


</code></pre>
<h3 id="using-otehr-iterator-triat-methods"><a class="header" href="#using-otehr-iterator-triat-methods">Using Otehr Iterator Triat Methods</a></h3>
<pre><code class="language-rs">
	fn using_other_iterator_trait_methods() {

		let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    
    		assert_eq!(18, sum);
	}

</code></pre>
<h3 id="comparing-performance--looks-vs-iterators"><a class="header" href="#comparing-performance--looks-vs-iterators">Comparing Performance : Looks vs. Iterators</a></h3>
<p>Iterators are one of Rust's zero-cose abstractions, no additional runtime overhead. </p>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<ul>
<li>Closures and iterators contribute to Rust's capability to clearly express high-level ideas at low-level perfromance. </li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust_book/10_generic_types_traits_and_lifetimes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../rust_book/14_more_about_cargo_and_creates_io.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust_book/10_generic_types_traits_and_lifetimes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../rust_book/14_more_about_cargo_and_creates_io.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
