<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>러스트 언어에 대한 지식 공유방</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="rust by example 공식 홈페이지 번역 &amp; 내 입맛에 맞게 주석">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item "><a href="example/example.html"><strong aria-hidden="true">1.</strong> 러스트 예제로 알아보기</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/hello.html"><strong aria-hidden="true">1.1.</strong> Hello World 출력</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/hello/comment.html"><strong aria-hidden="true">1.1.1.</strong> Comments, 주석</a></li><li class="chapter-item "><a href="example/hello/print.html"><strong aria-hidden="true">1.1.2.</strong> Formatted print, 출력에 관해</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/hello/debug_display.html"><strong aria-hidden="true">1.1.2.1.</strong> Debug & Display</a></li></ol></li><li class="chapter-item "><a href="example/hello/testcase.html"><strong aria-hidden="true">1.1.3.</strong> TestCase: List(iter 개념과 Option 개념이 필요함)</a></li></ol></li><li class="chapter-item "><a href="example/primitives.html"><strong aria-hidden="true">1.2.</strong> Primitives, 원시타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/primitives/arrays_and_slices.html"><strong aria-hidden="true">1.2.1.</strong> Arrays and Slices</a></li></ol></li><li class="chapter-item "><a href="example/customtype.html"><strong aria-hidden="true">1.3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/customtype/testcase.html"><strong aria-hidden="true">1.3.1.</strong> TestCase: linked-list</a></li><li class="chapter-item "><a href="example/customtype/constants.html"><strong aria-hidden="true">1.3.2.</strong> constants</a></li></ol></li><li class="chapter-item "><a href="example/variablebinding.html"><strong aria-hidden="true">1.4.</strong> Variable Bindings,변수 바인딩</a></li><li class="chapter-item "><a href="example/types.html"><strong aria-hidden="true">1.5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/types/casting_literals.html"><strong aria-hidden="true">1.5.1.</strong> casting_and_literals</a></li><li class="chapter-item "><a href="example/types/inference_aliasing.html"><strong aria-hidden="true">1.5.2.</strong> inference_and_aliasing</a></li></ol></li><li class="chapter-item "><a href="example/conversion/conversion.html"><strong aria-hidden="true">1.6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/conversion/from_and_into.html"><strong aria-hidden="true">1.6.1.</strong> From and Into, tryFrom and tryInto</a></li><li class="chapter-item "><a href="example/conversion/to_and_from_strings.html"><strong aria-hidden="true">1.6.2.</strong> To and from Strings</a></li></ol></li><li class="chapter-item "><a href="example/expressions.html"><strong aria-hidden="true">1.7.</strong> Expressions</a></li><li class="chapter-item "><a href="example/flowAndControl/flow_and_control.html"><strong aria-hidden="true">1.8.</strong> Flow and Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/flowAndControl/for_and_iter.html"><strong aria-hidden="true">1.8.1.</strong> for_and_iter</a></li><li class="chapter-item "><a href="example/flowAndControl/match.html"><strong aria-hidden="true">1.8.2.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/flowAndControl/pointer_and_ref.html"><strong aria-hidden="true">1.8.2.1.</strong> pointers/ref</a></li><li class="chapter-item "><a href="example/flowAndControl/guards_and_binding.html"><strong aria-hidden="true">1.8.2.2.</strong> Guards/Binding</a></li></ol></li><li class="chapter-item "><a href="example/flowAndControl/if_let_and_while_let.html"><strong aria-hidden="true">1.8.3.</strong> if let / while let</a></li></ol></li><li class="chapter-item "><a href="example/functions/about_funtions.html"><strong aria-hidden="true">1.9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/functions/methods.html"><strong aria-hidden="true">1.9.1.</strong> Methods</a></li><li class="chapter-item "><a href="example/functions/closures/closures.html"><strong aria-hidden="true">1.9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/functions/closures/capturing.html"><strong aria-hidden="true">1.9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="example/functions/closures/as_input_parameters.html"><strong aria-hidden="true">1.9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="example/functions/closures/as_output_parameters.html"><strong aria-hidden="true">1.9.2.3.</strong> As output parameters</a></li><li class="chapter-item "><a href="example/functions/closures/iterator_searching_thro_iter.html"><strong aria-hidden="true">1.9.2.4.</strong> Examples in std</a></li></ol></li></ol></li><li class="chapter-item "><a href="example/modules/modules.html"><strong aria-hidden="true">1.10.</strong> Modules</a></li><li class="chapter-item "><a href="example/crates/crates.html"><strong aria-hidden="true">1.11.</strong> Crates</a></li><li class="chapter-item "><a href="example/cargo/cargo.html"><strong aria-hidden="true">1.12.</strong> Cargo</a></li><li class="chapter-item "><a href="example/attributes/attributes.html"><strong aria-hidden="true">1.13.</strong> Attributes, 속성</a></li><li class="chapter-item "><a href="example/generics/generics.html"><strong aria-hidden="true">1.14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/generics/generic_associated_phantom.html"><strong aria-hidden="true">1.14.1.</strong> Associated items & Phantom type parameters</a></li></ol></li><li class="chapter-item "><a href="example/scoping/scoping.html"><strong aria-hidden="true">1.15.</strong> Scoping rules-오너쉽, 참조, 라이프타임</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/scoping/ownership_move_borrowing.html"><strong aria-hidden="true">1.15.1.</strong> Ownership Move Borrowing</a></li></ol></li></ol></li><li class="chapter-item "><a href="dataStructureAndAlgorithms/intro.html"><strong aria-hidden="true">2.</strong> 데이터 구조와 알고리즘</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dataStructureAndAlgorithms/section1.html"><strong aria-hidden="true">2.1.</strong> Section 1</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">러스트 언어에 대한 지식 공유방</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <!--# Introduction -->
<h3 id="about"><a class="header" href="#about">about</a></h3>
<p>어쩌다보니 러스트 언어를 단순 도구 이상으로 좋아하게 되었습니다. 
러스트를 깊게 이해하고 싶은 마음에 이 책 저 책을 뒤지며 공부하였지만 만족스럽지 못하였습니다.</p>
<p>제 생각에 지식이란 자기 머릿 속에 있는 정리된 것들 이라는 생각이 들었습니다.
그래서 제가 지금까지 봐 온 러스트 관련 서적들에 대해 다시 읽으며 정리할 생각입니다.</p>
<p>저의 작은 노력이 누군가에게 도움이 되길 바랍니다.</p>
<p>by 꾸준히 러스트를 좋아하는 사람</p>
<h4 id="정리-예정-책"><a class="header" href="#정리-예정-책">정리 예정 책.</a></h4>
<ul>
<li>Rust by example.</li>
<li>Hands-On - Data structure and algorithms with Rust .</li>
<li>Rust language book by Carol Nichols.</li>
<li>Rust in acion by McNamara.</li>
<li>Rust for rustaceans by jon gjngest</li>
</ul>
<p>전체적인 내용에 대해 한번 정리 후에는 기본적인 문법 관련 내용들은 배제하고 제가 중요하다고 생각하는 부분에서
참고하여 정리할 예정입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-by-example"><a class="header" href="#rust-by-example">Rust by example</a></h1>
<p>제가 정리할 러스트 예제는 <a href="https://doc.rust-lang.org/stable/rust-by-example/">RustByExample</a>을 
정독하며 번역과 요약을 통해 올릴 예정입니다. </p>
<p>부족함이 많고 영어가 출중하신 분들은 위에 링크된 페이지를 통해 공부하시는 것도 좋은 방법입니다.</p>
<p>공홈에 있는 책을 먼저 읽고 보는 것이 좋다고 생각되나 프로그래밍에 대한 지식이 조금 있으시면 바로 예제를 보시는 것도 나쁘지 않다고 생각하며 예제도 상당히 좋다고 생각합니다.</p>
<p>참고하여 제 생각대로 번역하고 정리한 것임으로 부족함이 많습니다. 고려하여 참고 부탁드립니다.</p>
<p>감사합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h1>
<p>간단하게 출력 그리고 포맷팅 출력에 대해 알아보자.</p>
<p>먼저 main.rs 파일을 만들어 직접 컴파일해서 출력하는 방법을 알아보자.</p>
<pre><code class="language-bash">
$vi main.rs 

</code></pre>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {
	
	println!(&quot;Hello World!&quot;);

}

</code></pre></pre>
<p><code>rustc</code> 로 컴파일하기.</p>
<pre><code class="language-bash">
$rustc hello.rs 
./hello

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-주석"><a class="header" href="#comments-주석">Comments, 주석</a></h1>
<ul>
<li>
<p>주석은 컴파일러에 의해 무시된다. 즉 사용자가 코드에 대한 설명 등을 작성할 때 주로 사용된다. </p>
</li>
<li>
<p>종류</p>
<ul>
<li>// 라인 주석</li>
<li>/* 블록 주석</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

	/*
	 * 설명이 긴 주석이 필요로 할 때에는 블록 주석을 
	 * 통해 추가할 수 있습니다.
	 */


	 // 변수 a 와 b 를 통해 원하는 String 을 나타낼 수 있다.
         let a = String::from(&quot;러스트를 배워보자&quot;); 
         let b = String::from(&quot;예제를 통해&quot;); 
         println!(&quot;{} {} &quot;, b, a)	

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatted-print-형식에-맞춰-출력하기"><a class="header" href="#formatted-print-형식에-맞춰-출력하기">Formatted print, 형식에 맞춰 출력하기.</a></h1>
<p>러스트에서 print 는 macros 로 짜여져있다. 후반에 macro 에 대해 자세히 다룰 예정이다. 
또한 macro 는 standard lib 인 std::fmt 에 포함되어 있다.</p>
<ul>
<li>포맷 종류
<ul>
<li><code>format!</code>: 어떠한 text 를 String 으로 포맷팅한다. </li>
<li><code>print!</code>: 포맷과 비슷하지만 입력된 text 는 콘솔에 표현된다 (io::stdout).</li>
<li><code>println!</code>: print 와 동일하지만 ln 을 보면 알겠지만 한 줄 추가된다(엔터 친 효과).</li>
<li><code>eprint!</code>: 포맷과 같지만 text가 standard error 로 프린트된다(io::stderr).</li>
<li><code>eprintln!</code>: eprint!와 같지만 한 줄 추가된다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

        let a = &quot;ln이 없을 경우와 있을 경우.&quot;.to_string(); 
        let b = &quot;ln이 있을 경우와 없을 경우.&quot;.to_string();
        print!(&quot;{a} :&quot;);
        print!(&quot;한 줄 추가 없이 그대로 나열됨.\n&quot;); 
        println!(&quot;-----------------------------&quot;);
        println!(&quot;{b} :&quot;);
        print!(&quot;한 줄 추가된 채로 나열됨. \n &quot;);
     

        println!(&quot;{1} 보다 {0} 을 먼저 갖춰라.&quot;, &quot;인&quot;, &quot;예&quot;);
 
        //변수 이름 지정
        println!(&quot;{first}은 바람을 거역해서  {second} 를 낼 수 없지만, {third}이 풍기는 향기는 바람을 거역해서 사방으로 퍼진다.&quot;,   
              first=&quot;꽃&quot;,    
              second=&quot;향기&quot;,  
              third=&quot;선하고 어진 사람&quot;);    
   
   	
		// : 를 이용해서 포맷하기.
        println!(&quot;10 진수 {}&quot;,   69420);
        println!(&quot; 2 진수 {:b}&quot;, 69420);
        println!(&quot; 8 진수 {:o}&quot;, 69420);
        println!(&quot;16 진수 {:x}&quot;, 69420);
   
   
        // 공백 나타내기.
        println!(&quot;{number:&gt;5}&quot;, number=1);
   
        // 공백 값 지정하기.
        println!(&quot;{number:0&gt;5}&quot;, number=1);
   
        //공백 값을 변수에 지정하기.
        println!(&quot;{number:0&gt;width$}&quot;, number=1, width=5);

}


</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug--display"><a class="header" href="#debug--display">Debug &amp; Display</a></h1>
<p>러스트 내에 <code>std</code> library 에 포함된 타입들은 자동으로 프린트 매서드가 구현되어있다. 
이외의 다른 타입들은 <em>무조건</em> 구현해야만 프린트 할 수 있다. </p>
<p>구현할 수 있는 방법은 기본적으로는 두가지가 존재한다.</p>
<p>바로 Debug 와 Display 이다.</p>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>그 중 Debug에 대해 먼저 알아보자.</p>
<p><code>fmt::Debug trait</code>은 굉장히 사용자 편의성이 좋은 편이다. <code>derive</code> 를 선언하면 자동으로 <code>fmt::Debug</code> 를 구현한다. 
ex) 자바의 애너테이션 개념과 비슷하다고 표현해도 무방할듯..</p>
<p>예제와 같이 알아보자.</p>
<p>참고 - Debug 사용 시, 프린트 매크로에는 항상 {:?} 또는 {:#?} 을 사용하셔야 합니다. </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {


// 기본 타입들은 프린트가 가능.
let t = &quot;hello_world&quot;;
let tt = 3; 

println!(&quot;프린트 == {t}, {tt}  == 가능&quot;);

//사용자 지정타입, 즉 std library 에서 제공되지 않음 -&gt; 프린트 불가.
struct CanNotPrint(i32);

//아래 코드는 주석을 풀면 에러가 납니다.
//println!(&quot;{:?}&quot;, CanNotPrint(3));


//Debug 선언
#[derive(Debug)]
struct CanPrintWithDebug(i32);

println!(&quot;{:?}&quot;, CanPrintWithDebug(3));


#[derive(Debug)]
struct Person&lt;'a&gt; {
	name: &amp;'a str,
	age:u8
}

let tony = Person { name : &quot;과노&quot;, age : 34 };

//{:?}, {:#?} 비교 
println!(&quot;{:?}&quot;, tony);
println!(&quot;{:#?}&quot;, tony);


}

</code></pre></pre>
<h3 id="display"><a class="header" href="#display">Display</a></h3>
<p>Display 에 대해 알아보자.</p>
<p><code>Debug</code> 가 <code>derive</code> 를 통해 자동으로 프린트를 구현하였다면 <code>Display</code> 는 조금 더 손이 많이 간다. 즉 사용자가 직접 구현해야한다는 말이다. 다시 말하면 프린트하는 포맷을 내 입맛에 맛에 손 볼 수 있다. </p>
<p>예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">  use std::fmt::Display;

  struct PrintWithDisplay(i32);

  impl Display for PrintWithDisplay {
      // Display 를 구현함에 따라 Display 에 존재하는 default 함수를 가져와서 이를 구현한다.

      /*
       *다소 이해가 가지 부분들이 있으리라 생각됩니다만, 앞으로 나올 내용이니 너무 고민마시&gt;  고
       * 추후 배울 내용을 미리 눈으로 익힌다는 느낌으로 보시는 게 좋을 듯 합니다.
       */

      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
          write!(f, &quot;내가 원하는 입맛대로 출력하기. {}&quot;, self.0)
      }
  }

  fn main() {
      let t = PrintWithDisplay(3);     
      // 단순히 {} 만 사용하여도 출력가능 -&gt; Display 구현했기 때문.
      println!(&quot;{}&quot;, t);
  }
</code></pre></pre>
<h3 id="비교"><a class="header" href="#비교">비교</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">  use std::fmt::Display;


  #[derive(Debug)]
  struct DebugAndDisplay {
      x: String,
      y: String,
  }


  impl Display for DebugAndDisplay {
      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
          write!(f, &quot;내 기준에서 y가 먼저지! {} 그리고 {}&quot;, self.y, self.x)
      }
  }



  fn main() {
      let t = DebugAndDisplay{ x: &quot;다른 프로그래밍 언어...&quot;.to_string(), y: &quot;러스트&quot;.to_string() }; 

      println!(&quot;Debug  : {:?}&quot;, t);
      println!(&quot;Display : {}&quot;, t);
  }

</code></pre></pre>
<h3 id="참고"><a class="header" href="#참고">참고</a></h3>
<p><code>Vec&lt;T&gt;</code> 타입과 같은 경우는 <code>Display</code> 를 구현할 수가 없는데, <code>제네릭</code>의 경우는 어떠한 포맷으로 구현할지 타입마다 다르기 때문에 애매하다. 따라서 <code>Vec&lt;T&gt;</code> 는 <code>Display</code> 로 구현되지 않는다는 점을 알아두자. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testcase-listiter-개념과-option-개념이-필요함"><a class="header" href="#testcase-listiter-개념과-option-개념이-필요함">TestCase: List(iter 개념과 Option 개념이 필요함)</a></h1>
<p>그렇다면 배열이 있는 <code>struct</code> 일 경우, <code>fmt::Display</code> 로는 어떤 식으로 구현할까?</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">  use std::fmt::Display;


  #[derive(Debug)]
  struct ListVec(Vec&lt;i32&gt;);

  impl ListVec {
      fn new() -&gt; Self {
          ListVec(vec![1,2,3,4,5,6,7])
      }
  }

  impl Display for ListVec {

      // iter() 는 for 문의 형태로 쓰인다는 점에 알아두자.
      // 리턴 타입이 Result 인데, 이는 ? 를 사용할 수 있다는 의미이다. 
      // 간단히 눈으로 익히고 뒤에 자세히 알아보자.

      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
	  
          write!(f, &quot;list start &quot;);     
          for (count, n) in self.0.iter().enumerate() { 
              if count != (self.0.len() - 1) {
	      	write!(f, &quot;{} -&gt; &quot;, n)?;
	      }else{
	      	write!(f, &quot;{}&quot;, n);
	      }
          }

          write!(f, &quot; finished.&quot;)
      }
  }

  fn main(){
      println!(&quot;{}&quot;, ListVec::new());

      println!(&quot;{:?}&quot;, ListVec::new());

  }

</code></pre></pre>
<p>다른 예제를 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
  use std::fmt::Display;

  struct City {
       
       // &amp;'static 에 대해서 후반에 다룰 예정이니 String 포인터 개념이지만 스택에 올라간
       // 데이터라고 생각하고 넘어가자.

      name : &amp;'static str,
      lat : f32,
      lon : f32
  }

  impl Display for City {

      // 여기서 `f` 는 버퍼인데 간단하게 부하를 줄이기 위해 잠시 데이터를 저장하는 공간
      // String 포맷으로 구현하되 이를 버퍼에 저장한다고 생각하자.
      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {

          let location_of_latitude = if self.lat &gt; 0.0 { 'N' } else { 'S' }; 

          let location_of_longitude = if self.lon &gt; 0.0 { 'E' } else { 'W' };

          write!(f, &quot;location of {} : {:.3}, {}, {:.3}, {}&quot;,
                 self.name, self.lat, location_of_latitude,
                 self.lon, location_of_longitude
                 )
      }
  }



  fn main() {

      let t = City{ name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 };
      println!(&quot;{t}&quot;);

  }



</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives-원시타입"><a class="header" href="#primitives-원시타입">Primitives, 원시타입</a></h1>
<p>러스트 언어는 타입 지정이 우선시 되어야 한다. 항상 이를 염두하자.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<ul>
<li>
<p>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> and <code>isize</code> (pointer size)</p>
</li>
<li>
<p>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> and <code>uisze</code>(pointer size)</p>
</li>
<li>
<p>floating point: <code>f32</code>, <code>f64</code></p>
</li>
<li>
<p><code>char</code> Unicode 인 <code>'a'</code>, <code>'α'</code> and <code>'∞'</code> (4 bytes each) </p>
</li>
<li>
<p><code>bool</code> either <code>true</code> or <code>false</code></p>
</li>
<li>
<p>and unit type <code>()</code>, empty typle 이라고 하는데 아래에서 알아보자.</p>
</li>
</ul>
<p>튜플 타입 임에도 불구하고 컴파운드 타입으로 고려되지 않는 것은 하나의 타입으로 지정되어 있기 때문이다.</p>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<ul>
<li>
<p>arrays like <code>[1,2,3]</code></p>
</li>
<li>
<p>tuples like <code>(1, true)</code></p>
</li>
</ul>
<p>타입 지정할 때 숫자는 suffix 로 지정할 수 있다.
숫자는 default 타입이 존재하는데 Int 는 i32, float는 f64 가 있다.
또한 러스트는 타입 infer 시스템을 가지고 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

      let _logical: bool = true;

      let _a_float: f64 = 1.0; // Regular annotation

      let _suffix_integer = 3i32; // Suffix annotation i32

      let _default_float = 3.0; // default f64

      let _default_integer = 7; // default i32                                                               
      //주석을 풀면 에러남.
      //println!(&quot;{default_integer}&quot;);

      // 러스트는 기본적으로 변수가 immutable 이기 때문에 mut 를 변수 앞에 선언할 수 있다.

      let mut can_change = &quot;나는 예전엔 어리석었다.&quot;.to_string(); 

      println!(&quot;{can_change}&quot;);

      can_change = &quot;현재는 무지에서 벗어났다&quot;.to_string();

      println!(&quot;{can_change}&quot;);


      //아래 코드는 주석을 풀면 에러가 난다. 같은 타입에서만 변화만 가능하다.
      //사람이 제 아무리 노력해서 변화한다 한들 다람쥐나 고래가 될 수 없듯이
      //can_change = 3;

      }

</code></pre></pre>
<h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>튜플 타입은 () 으로 지정한다. 
(type1, type2, type3...) 과 같은 방식으로 선언할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
  fn reverse_tuple( pair : (i32, bool) ) -&gt; (bool, i32) {
      let (reverse_bool, reverse_i32) = pair; i32, bool
      (reverse_i32, reverse_bool)
  }


  fn main() {

     let t = (33, true); (i32, bool)
     let result_t = reverse_tuple(t); (bool, i32)

     println!(&quot;{:?}&quot;, result_t);

  }

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-slices"><a class="header" href="#arrays-and-slices">Arrays and Slices</a></h1>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<ul>
<li><code>Array</code> 는 스택 메모리에 인접하게 저장되어 있는 객체들을 말한다. </li>
<li>[] 을 사용하여 선언한다.</li>
<li>[] 의 길이는 컴파일 타임에 알 수 있다(미리 선언되기 때문이며 Array 는 길이 변화가 불가능하기 때문)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
	//배열 선언
	let arrays : [i32; 5] = [1,2,3,4,5];
	let ys : [i32; 500] = [0; 500];

	//배열 안에 데이터 접근
	println!(&quot;{}&quot;, arrays[0]);

}
</code></pre></pre>
<h3 id="slices"><a class="header" href="#slices">Slices</a></h3>
<ul>
<li><code>Slices</code> 는 <code>arrays</code> 와 비슷하지만 길이를 컴파일 타임에 알 수 없다. </li>
<li><code>Slice</code> 는 두 단어로된 객체인데, 첫번째 단어는 저장된 데이터를 가르키는 포인터, 두번째 단어는 해당 포인터의 길이(usize)로 표현된다.</li>
</ul>
<p>러스트의 참조 개념과 스트링 슬라이스에 대한 이해는 사실 초보자들에겐 쉽지만은 않다.
스스로도 무지한 상태에서 이를 이해하는데 꽤나 오랜 시간이 걸린 것 같다. 
눈으로 익혀 두고 기회가 되면 러스트 책 또는 다른 곳에서 이해할 수 있길 바란다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let s = &quot;hello world&quot;.to_string(); 

let world = &amp;hello_world[6..11]; 

<span class="boring">}
</span></code></pre></pre>
<img src="example/primitives/string_slice.svg" alt="drawing" width="300">
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<p>커스텀 타입에는 <code>struct</code> 와 <code>enum</code> 그리고 Constants가 있다.</p>
<h3 id="structrues"><a class="header" href="#structrues">Structrues</a></h3>
<p><code>struct</code> 키워드로 생성할 수 있다. </p>
<ul>
<li>Tuple structs, 안에 튜플을 가진 객체이다.</li>
<li>The classic C structs. C언어 스타일의 객체</li>
<li>Unit structs 필드는 존재하지 않는다. Generic 제니릭 부분에서 유용하게 쓰인다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>//튜플 struct
struct Pair(i32, f32);

struct Point {
	x: i32,
	y: f32,
}

struct Unit;


<span class="boring">}
</span></code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p><code>enum</code> 키워드로 생성할 수 있다.</p>
<p>*선언된 enum 안에 필드는 struct과 동일하게 여러 타입들이 선언될 수 있다.
*선언된 enum 안에 필드는 C 언어 처럼 0, 1, 2 인덱싱이 가능하다.</p>
<p>type aliases</p>
<p><code>enum</code> 명이 길다면 aliases 선언 가능.</p>
<p>ex)</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum verylongverboseEnum {
	A,
	B
}

type short = verylongverboseEnum;

fn main(){
	let x = short::A;
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testcase-linked-list"><a class="header" href="#testcase-linked-list">TestCase: linked-list</a></h1>
<p>흔히들 사용하는 간단한 링크드 리스트 배열을 구현해보자. 
내용이 어렵기 때문에 설명은 간략하게 할 것이며 눈으로 익히는 정도만 해도 충분하다. </p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[derive(Debug)]
enum List {
    //Box 를 사용하는 것은 메모리를 정확히 알 수 없을 경우 사용한다. 힙에 저장됨.
    // List 가 몇개나 들어갈지 알 수 없기 때문에 Box 사용하며 자세한 내용은 뒤에서 설명하겠다.
    Cons(u32, Box&lt;List&gt;),
    Nil,
}

impl List {
	
    // 배열 첫번째에 숫자를 넣는 경우, 객체 그 자체가 새로 만들어지기 때문에 &amp; 없이 self 변수가 들어간다.
    fn insert_to_fth(self, fth_num: u32) -&gt; Self {
        List::Cons(fth_num, Box::new(self))
    }
	
    // associated function 이라고 하는데 객체의 구현 시, 파라미터가 없이 사용할 수 있는 함수이다. static method 와 비슷한 개념이다.
    fn new() -&gt; Self {
        List::Nil
    }
    
    // 해당 리스트의 길이를 알려주는 함수인데 tail.len() 재귀함수 방식으로 구현한다. 
    // match 와 래퍼런스 개념이 필요한데 눈으로 익히고 추후에 자세하게 설명하겠다.
    // 간단하게 설명하면 객체 자체를 파라미터로 넣으면 해당 객체는 더이상 사용할 수 없게 됨으로 참조하여 사용하며
    // match 사용 시, 러스트 컴파일러는 참조된 것으로 파악해서 match &amp;self 로 쓰지 않아도 &amp;self 된 것 처럼 사용할 수 있다.
    fn len(&amp;self) -&gt; u32 {
        match self {
            List::Cons(_, tail) =&gt; 1 + tail.len(),
            List::Nil =&gt; 0,
        }
    }

    
    fn stringify(&amp;self) -&gt; String {
        match self {
            List::Cons(head, tail) =&gt; {
                    format!(&quot;{}  {} &quot;, head, tail.stringify())
            },
            List::Nil =&gt; {
                format!(&quot;&quot;)
            }
        }
    }
}

fn main() {
    let t_list = List::new();
    println!(&quot;{:?}&quot;, t_list);

    let mut new_list = t_list.insert_to_fth(3);
    println!(&quot;{:?}&quot;, new_list);
    for n in 1..10 {
        new_list = new_list.insert_to_fth(n);
        match &amp;new_list {
            List::Cons(_, ref tail) =&gt; {
                println!(&quot;List : {:?} : len : {:?}&quot;, new_list, tail.len());
            }
            List::Nil =&gt; todo!(),
        }
    }
    let print = new_list.stringify();
    println!(&quot;{}&quot;, print);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">constants</a></h1>
<p>러스트에는 두 종류의 불 변수가 존재한다. </p>
<ul>
<li><code>const</code> : 불변하는 value(주로 사용)</li>
<li><code>static</code> : static 이라는 라이프 타임을 지정하며 <code>mut</code>able 하게 변수 지정할 수 있다. mutable static 변수에 접근하거나 변경하는 것은
<code>unsafe</code> 를 사용한다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">


// constants 타입은 어디든 선언이 가능하다.
static LANGUAGE : &amp;str = &quot;러스트&quot;; // 변수명은 항상 대문자
const THRESHOLD : i32 = 10;

fn main() {
    
    println!(&quot;{LANGUAGE}&quot;);

    println!(&quot;{THRESHOLD}&quot;);
   
    // 불변수에는 재선언 불가능
    // THRESHOULD = 5; 
    // LANGUAGE = &quot;rust&quot;; 

}


</code></pre></pre>
<p><code>static</code> 개념에 대해서는 추후에 자세하게 다룰 예정이다. 눈으로 이런 문법이 있다 정도면
익히고 넘어가면 된다. </p>
<p>개인적인 생각으로는 러스트는 다른 언어에 비해 러닝커브가 까다롭다. 여러번 훑어본다는 느낌으로 전체를 이해하고 이해한 후에 코드를 짜다보면 조금씩 나아진다. Rust! </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-bindings변수-바인딩"><a class="header" href="#variable-bindings변수-바인딩">Variable Bindings,변수 바인딩</a></h1>
<p>러스트는 static typing 을 통한 type safety 제공한다. 타입은 변수 선언시 지정할 수 있지만
대부분 컴파일러에 의해 타입이 선언될 수 있다. </p>
<h3 id="mutability"><a class="header" href="#mutability">Mutability</a></h3>
<p>러스트는 기본으로 불변수인데 mut 를 사용하면 수정이 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	

	let last_name = &quot;lee&quot;;
	// 불가능
	// last_name = &quot;kim&quot;;
	
	//mut
	let mut name = &quot;hello&quot;;
	name = &quot;world&quot;;
	println!(&quot;{name}&quot;);
}
</code></pre></pre>
<h3 id="scope-and-shadowing"><a class="header" href="#scope-and-shadowing">Scope and Shadowing</a></h3>
<p>러스트에서 Scope 영역은 해당 변수의 드랍 여부를 나타내는 중요한 지표이다. 
(드랍이라는 것은 더 이상 참조가 불가능하며 바로는 아니지만 메모리에 제거 된다는 말이다.)</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
	
	// Scope

	let scope = 1;
	{
	 let inner_scope = 2;

	 println!(&quot;{inner_scope}&quot;);

	}
	// 이 블록 영역이 지나면 호출 불가능, 드랍된다.
	//println!(&quot;{inner_scope}&quot;);
	
	println!(&quot;{scope}&quot;);
	

	//Shadowing

	let shadow = 1;
	
	{
		let shadow = &quot;shadow&quot;;
		println!(&quot;{shadow}&quot;);
	}
	// 같은 이름으로 선언하였지만 드랍되어 쓰일 수 없다.
	println!(&quot;{shadow}&quot;);
}
</code></pre></pre>
<h3 id="declare-first-변수-선언과-초기화"><a class="header" href="#declare-first-변수-선언과-초기화">Declare first, 변수 선언과 초기화</a></h3>
<p>러스트는 변수를 선언하고 그 후에 초기화 하는 것이 가능하다. 그러나 초기화하지 않고 사용하는 것은 컴파일 에러를 나타낸다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	//선언
	let declare;
	{
		let a = 2;
		declare = a * a;

	}	
	//위에 초기화값은 블록 안에서도 가능한다. 왜냐하면 변수는 상위에 선언되고 블록 안에서는 상위에 선언된 변수가 value 값만 들어가기 때문이다. (Move 개념_ 추후 설명) 
	println!(&quot;{declare}&quot;);
	
	//선언 후 초기화 작업 없이는 사용 불가능
	//let a_declare;
	//println!(&quot;{a_declare}&quot;);
}

</code></pre></pre>
<h3 id="freezing"><a class="header" href="#freezing">Freezing</a></h3>
<p>데이터가 mut 하게 선언되었다가 다시 immut 로 선언되면 이것을 freez 라고 한다. 
더 이상 mutable 하게 사용이 불가능하기 때문이다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

fn main() {
	let mut number = 3;

	{
	// 해당 변수에 value 값만 들어간다. 쉐도잉으로 새롭게 선언된 변수는 immut 하다.
	let number = number;
	
	//그렇기에 아래와 같은 구문은 불가능하다.
	//number = 1; 

	}
	// 위의 문장들은 블록 영역이 끝이 나면서 드랍되기 때문에 더 이상 쓸모 없게 되며

	// 맨 위 mut number 변수에 영향을 받는다.
	number = 6;

	println!(&quot;{number}&quot;);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>러스트 타입 매커니즘</p>
<ul>
<li>기본 타입에 대한 형변환과 정의</li>
</ul>
<ol>
<li>기본형에 대한 형변환</li>
<li>literals</li>
<li>type inference</li>
<li>aliasing </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting_and_literals"><a class="header" href="#casting_and_literals">casting_and_literals</a></h1>
<h3 id="casting"><a class="header" href="#casting">Casting</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let decimal = 65.4321_f32;

    //let integer : u8 = decimal; u8 이라는 타입을 지정하여도 value 값에 지정한 게 아니기 때문에
    //명확하게 표현된 것이라 보기 어렵다.

    let integer = decimal as u8; // value 값에 변환 타입을 명확히 지정
    let character = integer as char;

    // decimal 에서 바로 char 로 변환하는 것은 가능한가
    //let char = decimal as char;  //소수에서는 utf8 로 매칭되는 게 없기 때문에 불가능하다.

    println!(&quot;Casting : {decimal} -&gt; {integer} -&gt; {character}&quot;); // 가능


    // 8비트에서 16이나 32비트로 형변환 하는 것은 문제가 없다. 그렇다면 16비트에서 8비트, 더 적은
    // 비트 수로 변환하는 것은 어떻게 될까
   
    let bit_16 = 300.0_f32;

    let answer = bit_16 as u8;
   
    // unsigned 8, u8은 255 까지 밖에 표현되지 못하기 때문에 300이 나오지 못한다.
    println!(&quot;{answer}&quot;);
  
    // overflow. unsafe 는 자주 사용되진 않지만 시스템 쪽을 구현해야하 할때 종종 사용하는 듯 하다.
    // runtime cost가 존재하기 때문에 완벽히 이해한 후 사용해야한다.
    unsafe {
        // 300.0 is 44
        println!(&quot;300.0 is {}&quot;, bit_16.to_int_unchecked::&lt;u8&gt;());
    }

}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {

    // value 값과 타입을 한번에 지정한 literals
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;
    
    // 타입을 지정하진 않고 사용됨에 따라 타입이 지정됨.
    let i = 1;
    let f = 1.0;

    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inference_and_aliasing"><a class="header" href="#inference_and_aliasing">inference_and_aliasing</a></h1>
<h3 id="inference-타입-추론"><a class="header" href="#inference-타입-추론">Inference 타입 추론</a></h3>
<p>러스트에 존재하는 타입 추론 엔진은 특별한 타입이나 상황을 제외하고는 직접 타입을 지정하지 않아도 된다.</p>
<ul>
<li>변수에 값을 선언하였을 시 추론 가능</li>
<li>변수 선언 후 추후에 값을 지정해도 추론 가능</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let elem = 5; //변수에 값 지정, 타입 추론 가능
	

	let mut vec = Vec::new(); // Array 계열인 빈 벡터 선언, 컴파일러는 아직 타입을 알지 못함. Vec&lt;_&gt; 타입인 상태

	vec.push(elem);
	
	// vec의 타입은 Vec&lt;i32&gt; 가 된다. 러스트는 자연수 default 는 i32 이기 때문이다.
	println!(&quot;{:?}&quot;, vec);
	

	//여기서 알아둬야 할 부분은 선언 후 초기화를 하지 않으면 컴파일 에러가 난다. 컴파일 타임에 메모리의 양을 알 수 없거니와
	//타입 지정 추론이 아예 불가능하기 떄문이다. 
	//만약 변수 선언만 하고 초기화는 하지 않고 싶다 또는 추후에 하고 싶다면 변수 선언 시 타입을 지정하여야 한다. 
	let typed_vec::Vec&lt;i32&gt;;  
	let typed_num::i32; 

	
}

</code></pre></pre>
<h3 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h3>
<p>linux를 조금이라도 써본 사용자라면 alias 가 얼마나 유용한지 알 수 있다. 러스트에서도 비슷한 맥락으로 사용된다. 
타입에 대한 alias 선언을 알아보자. - 추후 많은 타입에 대해서도 alias 가 가능한데, 개념만 알면 자연스럽게 익히게 된다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
type NanoSecond = u64; // u64는 NanoSecond 라는 타입으로 사용할 수 있다.
type Inch = u64; // 러스트에서 Alias 는 UpperCamelCase 를 활용한다.

fn main() {
	
	let nanosec : NanoSecond = 5;

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversion"><a class="header" href="#conversion">Conversion</a></h1>
<p>앞서 배웠듯이 원시 타입은 casting 을 통해 타입 변환이 가능하다.
나아가 custom types 인 <code>struct</code> 와 <code>enum</code> 에서도 traits 를 사용하면 가능하다. 
이번 챕터에서는 이러한 trait 에 대한 이해와 사용법에 대해 알아본다.</p>
<ul>
<li>
<p>Generic conversion 인 경우 From 과 Into Trait 를 사용한다. </p>
</li>
<li>
<p>String 에서 사용되는 to 와 from Trait 을 사용한다. </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into">From and Into</a></h1>
<p>From 과 Into 매우 유용하며 개념만 이해한다면 쉽게 사용할 수 있다. </p>
<p>간단하게 설명하고 예제로 알아보자. 
먼저 A 라는 enum 또는 struct 이 존재한다고 하자. 
A 는 B를  가져와서 A 화 할 수 있다.</p>
<p>마찬가지로 B 도 원하면 A 가 될 수 있다. 말이 이상한데 예제로 살펴보자.
앞에서 종종 나왔지만 String::from 과 같은 trait 를 구현한 것이다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Gwano {
    kind: String, 
}


// std::lib 에 구현된 from tait 를 이용하여 gwano Struct 을 구현하였다. 
impl From&lt;String&gt; for Gwano {
    fn from(value : String) -&gt; Self {
        Gwano {
            kind : value,
        }
    }
}


fn main() {
   
   let k = Gwano::from(&quot;good&quot;.to_string()); 

   println!(&quot;{:?}&quot;, k);
   

   //into 는 from 을 구현하면 자동으로 구현된다고 생각하자. 
   //주의해야할 점은 into() 함수 사용 시, 타입을 필수로 지정해야 한다. 그래야 컴파일러가 어떤 타입으로 converting 할지 
   //알 수 있다.

   let kk = &quot;veryGood&quot;.to_string();
   let answer:Gwano = kk.into();
   
   println!(&quot;{:?}&quot;, answer);
}


</code></pre></pre>
<h1 id="tryfrom-and-tryinto"><a class="header" href="#tryfrom-and-tryinto">TryFrom and TryInto</a></h1>
<p>from and into 와 비슷한데, 리턴 값이 Err 일 수 있는 상황에서 유용하다. Result&lt;&gt; 타입은 추후에 자세히 다룬다. 
이런 것이 있다 정도만 알아두자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Gwano {
    kind: String, 
}

// 구현된 tryform trait 을 이용해 gwano 를 impl 한다. 
impl TryFrom&lt;String&gt; for Gwano {
    type Error = ();

    fn try_from(value: String) -&gt; Result&lt;Self, Self::Error&gt; {
        if value == &quot;answer&quot;.to_string() {
            let answer = Gwano {
                kind : value ,
            };
            Ok(answer)
        } else { 
           Err(()) 
        }
    }
}


fn main() {
    
    let check = &quot;answer&quot;.to_string();
    let n_check = &quot;not&quot;.to_string();

    let an1 = Gwano::try_from(check);
    
    println!(&quot;{:?}&quot;, an1);
    let an2 = Gwano::try_from(n_check);
    println!(&quot;{:?}&quot;, an2);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-and-from-strings"><a class="header" href="#to-and-from-strings">To and from Strings</a></h1>
<h3 id="converting-to-string"><a class="header" href="#converting-to-string">Converting to String</a></h3>
<p>어떤 타입이든 String 타입으로 변환하는 것은 어렵지 않다. <code>fmt::Display</code> trait 에서 편하게 <code>toString</code> 함수를 제공하기 때문이다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fmt::Display;

struct PhoneNumList {
    num : Vec&lt;i32&gt;,
}

impl Display for PhoneNumList {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;number list -- {:?}&quot;, self.num)
    }   
}


fn main() {
   
    // 폰번호 맨 앞자리 0이 사라지는 이유 알아보기 
    let list = PhoneNumList {
        num: vec![01029166767, 01029166766]
    };

    println!(&quot;{}&quot;, list);



}



</code></pre></pre>
<h3 id="parsing-a-string-문자열-형변환"><a class="header" href="#parsing-a-string-문자열-형변환">Parsing a String, 문자열 형변환</a></h3>
<p>러스트에선 문자열을 형변환 하는 것은 실제로는 까다로운데 String 문자열은 [u8] 형태로 구성되어 있기 때문이다.
그래서인지 러스트에서는 <code>FromStr</code> trait 를 std::lib 에서 여러 타입에 제공하고 있다. 그래서 <code>primative</code> 타입들 중에 <code>FromStr</code> 을 구현한 타입들은 쉽게 형변환이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 타입 지정이 필요함. 뭘로 형변환 해야할지 알지 못함.
    let parsed:i32 = &quot;5&quot;.parse().unwrap();
    
    // turbofish syntax, 유용하니 눈 여겨 봐두자.
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    println!(&quot;parse : {parsed}, turbofish : {turbo_parsed}&quot;);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>개인적으로 개념을 제대로 암기 후 이해하고 있는 것이 가장 중요하다고 생각한다.
그럼 러스트의 Expressions 을 알아보자.</p>
<p>statements - &quot;구문&quot; 이며 expressions - &quot;표현식&quot; 이라 말한다.</p>
<h3 id="표현과-식"><a class="header" href="#표현과-식">표현과 식</a></h3>
<ul>
<li>
<p>식은 법 식이라는 한자이며 방정식, 등식, 수식 등에 쓰인다. 즉 어떤 것에 대한 표현.</p>
</li>
<li>
<p>구문은 얽을 구에 글월 문이다. 말 그대로 글자들이 나열된 것을 말한다. </p>
</li>
</ul>
<p>이제 간단하게 구분할 수 있다</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let x = 3u32; // 변수에 value 를 바인딩하였다.구문이다.
	
	let y = {}; // 여기서 {} 은 구문일까 식일까? 당연히 구문이다. 리턴 값은 () 

	let z = 3 + x; // 3 + x 는 식이다.

	//그렇다면 러스트에선 구문 안에서 구문과 식을 나눈 것을 알아보자.
	
	let x_ = {
		let t = 3 + x; // 이렇게 뒤에 ; 을 넣어버리면 이것은 끝나지 않았다는 뜻으로 구문으로 정의된다.
		t + 3 // 이 문장은 뒤에 ; 이 없기 떄문에 이 구문 안에서는 식으로 정의되며 x_ 변수에 9가 들어간다. 
	}; 

}

</code></pre></pre>
<p>꽤나 복잡하게 설명하고 복잡한듯 보이지만 익숙해지면 아주 쉽다. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-and-control"><a class="header" href="#flow-and-control">Flow and Control</a></h1>
<ul>
<li>if - else </li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {
    let t = 3;

    let init: i32;

    if t &gt; 3 {
        init = 4;
    } else if t &lt; 3 {
        init = 2
    } else {
        init = 30
    }
    println!(&quot;init value : {init}&quot;);

    let return_value = if init &gt; 40 {
        50
    } else if init == 30 {
        init * 10
    } else {
        init / 10
    };

    println!(&quot;return value : {return_value}&quot;)
}


</code></pre></pre>
<ul>
<li>loop </li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

	let mut t = 3i32;

	loop {
		t += 1;
		if t == 10 {
			println!(&quot;t is finally 10&quot;);
			continue;
		}
		
		if t &lt; 10 {
			println!(&quot;t is not yet 10, t is {}&quot;, t);
		}

		if t == 11 {
			println!(&quot;bye..&quot;);
			break;
		} 
	}
}
</code></pre></pre>
<ul>
<li>while </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	let mut n = 1u32;

	while n &lt; 50 {
		if n % 2 == 0 {
		 	println!(&quot;짝 : {n}&quot;);
		}else{
			println!(&quot;홀 : {n}&quot;);
		}
		n += 1;	
	}

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-and-iterators"><a class="header" href="#for-and-iterators">for and iterators</a></h1>
<p>for문과 iterators에 대해 알아보자.</p>
<h3 id="for-문"><a class="header" href="#for-문">For 문</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	for n in 1..101 {
		println!(&quot;{n}&quot;);
	}

	for n in 1..=100 {
		
		println!(&quot; 숫자 100까지 출력 {n}&quot;);

	} 

}
</code></pre></pre>
<h3 id="iterators"><a class="header" href="#iterators">Iterators</a></h3>
<p>iterators 형은 for문 형태로 적용이 가능한 포맷을 말한다. 다시 말하면 loop 문이 가능하다. 
또한 러스트에는 iter 종류가 3가지 존재한다. </p>
<ul>
<li><code>iter</code> - borrows, 데이터를 참조만 할 수 있다.</li>
<li><code>iter_mut</code> - mutably borrows, 변환 가능하게 참조한다. </li>
<li><code>into_iter</code> - consumes, 러스트에서 데이터에서 끄내온 객체는 더 이상 그 객체의 데이터는 사용이 불가능하다. 
해당 소비된 데이터는 move 이동하였기 때문이다.</li>
</ul>
<h4 id="iter"><a class="header" href="#iter">iter()</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let name1 = vec![&quot;hell&quot;, &quot;low&quot;, &quot;world&quot;];

    for n in name1.iter() {
        // 참조로 사용하는 중
        match n {
            &amp;&quot;hell&quot; =&gt; {
                println!(&quot;name : {}&quot;, n);
            }
            _ =&gt; {
                println!(&quot;others&quot;);
            }
        }
    }
}
</code></pre></pre>
<h4 id="iter_mut"><a class="header" href="#iter_mut">iter_mut()</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){

    let mut name2 = vec![&quot;hell&quot;, &quot;low&quot;, &quot;world&quot;];
    for (index,n) in name2.iter_mut().enumerate() {
        // mutable 하게 사용 가능.
	// *는 ref된 데이터를 온전한 데이터로 사용한다는 것을 의미한다. 즉 온전한 데이터이기 때문에 다른 value 값을 넣을 수 있다.
        *n = match n {
            &amp;mut &quot;world&quot; =&gt; &quot;tony&quot;,
            _ =&gt; if index == 0 {
                &quot;finally&quot;
            }else {
                &quot;i found &quot;
            }
        }

    }
    println!(&quot;{:?}&quot;, name2);

}
</code></pre></pre>
<h4 id="into_iter"><a class="header" href="#into_iter">into_iter()</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
    
    let name3 = vec![&quot;hell&quot;, &quot;low&quot;, &quot;world&quot;];

    for n in name3.into_iter() {
    	//데이터 이동 중...
        match n {
           &quot;world&quot; =&gt; println!(&quot;hii&quot;),
            _ =&gt; println!(&quot;...&quot;)
        }
    }
    //move, consume 되었기 때문에 더 이상 사용이 불가능하다.
    //println!(&quot;{:?}&quot;, name3);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<p>러스트에서는 C <code>switch</code> 와 비슷한 개념으로 패턴 매치를 제공하는데 기본적인 테크닉을 익히면 아주 유용하게 사용할 수 있다.</p>
<p>간단히 설명하면 value 값을 매칭 시켜 분기를 태울 수 있다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
	let say = &quot;hello&quot;;
	// _ 의미는 else 개념으로 이해하면 된다.
	match say {
		&quot;hello&quot; =&gt; println!(&quot;he said {}&quot;, say),
		_ =&gt; println!(&quot;nothing&quot;)
	}
}

</code></pre></pre>
<p>match Destructure 에 대해 알아보자.</p>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<p>예제는 tuple 로만 표현했지만 struct, enum, array 으로도 destructure 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let tuple_match = (0, 1, 2);
	
	match tuple_match {

		(0, y, z) =&gt; println!(&quot;first is 0, then random y: {}, z :{}&quot; ,y ,z),
		(1, ..) =&gt; println!(&quot;first is 1, then ...&quot;),
		_ =&gt; println!(&quot;I dont care what first number is ..&quot;),
	}
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointersref"><a class="header" href="#pointersref">pointers/ref</a></h1>
<p>포인터와 참조 개념을 알아보자. </p>
<p>일단 매치에서 쓰이는 포인터와 참조 개념에 대해서 알아보자.</p>
<ul>
<li>
<p>참조된 값을 reference, &amp; 로 표현하며 반대로 참조된 값을 참조에서 벗길때는 *을 사용하며 Derefencing 이라고 한다.</p>
</li>
<li>
<p>매치에서 Destructuring 할 떄에는 &amp;, ref 와 ref mut 을 사용한다. </p>
</li>
</ul>
<p>추후 다른 단원에서 이러한 개념에 대해 깊게 다루니 그때 이해하면 되니까 너무 이해하려고 하지말자.</p>
<p>단박에 이해가 되면 좋지만 그렇지 못함으로 반복과 집중을 통해 이해를 높이자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let ref_val = &amp;3;

    // 여기서 ref_val 는 &amp;3 이다.
    match ref_val {
        &amp;v =&gt; println!(&quot;&amp; 를 이용한 match&quot;),
    }

    // &amp;3 -&gt; 3 으로 매치  
    match *ref_val {
        v =&gt; println!(&quot;value 를 dereferencing 함.&quot;)
    }

    
    let not_ref_val = 3;
    
    // 선언 시 변수 앞에 ref 를 추가하여 &amp;변수로 구현할 수 있다.
    let ref change_ref_val = not_ref_val;

    let value = 3;
    let mut mut_value = 3;
    

    match value {
        // value -&gt; &amp;val 로 출력할 수 있다. 
        ref r =&gt; println!(&quot;Create a ref val : {}&quot;, r),
    }

    //mutable 한 value를 ref mut 로 구현 후 dereferencing 하여 변환
    match mut_value {
         ref mut m =&gt; {
            *m += 10;
            println!(&quot;ref mut val : {}&quot;, m)
        }
    }

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guardsbinding"><a class="header" href="#guardsbinding">Guards/Binding</a></h1>
<h3 id="guards"><a class="header" href="#guards">Guards</a></h3>
<p>매치에서 쓰이는 guard 는 filter 의 기능으로 사용할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let pair = (3, 3);

	println!(&quot;the pair is {:?}&quot;, pair);

	match pair {
		(x, y) if x &gt; y =&gt; println!(&quot;x is bigger than y &quot;),
		(x, y) if x == y =&gt; println!(&quot;x is same as y&quot;),
		_ =&gt; println!(&quot;x is smaller than y&quot;),
	}

}

</code></pre></pre>
<h3 id="binding"><a class="header" href="#binding">Binding</a></h3>
<p>말 그대로 변수에 특정 value 를 @ 을 통해 바인딩 할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn get_value() -&gt; u32 {
	33
}
fn main() {
	// return 값이 u32 이기 때문에 u32 에 대한 모든 수를 매치 시켜줘야 한다. 말이 된다?
	match get_value() {
		n @ 1 ..=19 =&gt; println!(&quot;미성년&quot;),
		n @ 20 ..=30 =&gt; println!(&quot;성인, 이립&quot;),
		n @ 31 ..=40 =&gt; println!(&quot;어른, 불혹&quot;),
		n @ 41 ..=50 =&gt; println!(&quot;지천명&quot;),
		n @ 51 ..=60 =&gt; println!(&quot;이순&quot;),
		n @ 61 ..=70 =&gt; println!(&quot;종심&quot;),
		_ =&gt; println!(&quot;망구&quot;),

	}
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let--while-let"><a class="header" href="#if-let--while-let">if let / while let</a></h1>
<p>match 보다 간결하게 쓸 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	let optional = Some(7);

	match optional {
		Some(i) =&gt; println!(&quot;use match, value is {}&quot;, i),
		_ =&gt; println!(&quot;none&quot;),
	}

	let use_if_let = Some(7);

	if let Some(i) = use_if_let {
		println!(&quot;use if let, value is : {}&quot;, i);
	} else {
		println!(&quot;none&quot;);
	}
}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    
    let mut value = Some(0);
    // 굳이 설명하자면 while let 은 Some(i) 인 형태일 때까지 구문을 실행한다.
    while let Some(i) = value {
        if i  &gt; 9 {
            println!(&quot;got 10!!, quit&quot;);
            value = None
        }else{
            println!(&quot; not reached yet... value is {}&quot;, i);
            value = Some(i+1)
        }

    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<ul>
<li>러스트에서 function,함수는 <code>fn</code> 키워드로 선언하며 함수 안에 변수는 타입 지정이 필수이다.</li>
<li>함수에서 리턴 값이 있으면 <code>-&gt;</code> 로 표시하며 그 뒤에 타입을 입력한다. </li>
<li>함수 안에 리턴 값은 구문이 아닌 식으로 표현해야 하기 때문에 <code>;</code>이 없어야 한다. (앞선 챕터 expression 참고)</li>
<li>만약 <code>if</code> 구문으로 인하여 아래 구문들이 실행되기 전에 <code>return</code> 해야 한다면 <code>return</code> 뒤에 <code>리턴값</code>을 입력하면 된다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">//함수 선언
fn make_fn(num1 : i32, num2 : i32) -&gt; i32 {
	num1 * num2  //식, return value 
}


fn no_return_fn(num1 : i32, num2 : i32) -&gt; () {
	println!(&quot;no return fn, 여기선 -&gt; () 입력하였지만 생략 가능. &quot;); // 구문 
}

fn return_value_at_num1(num1 : i32) -&gt; i32 {
	if num1 == 1 {
	 	return num1 * 100
	}else{
		num1 * 0
	}

}

fn main() {
	let num1 = 1;
	let num2 = 3;

	println!(&quot;make_fn : {}&quot;, make_fn(num1, num2));

	no_return_fn(num1, num2);

	println!(&quot;return_value_at_num1 : {}&quot;, return_value_at_num1(num1));

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<h3 id="associated-functions--methods"><a class="header" href="#associated-functions--methods">Associated functions &amp; Methods</a></h3>
<p>러스트에서 Associated fn 과 Methods 라고 불리는 함수가 존재한다. 
자바의 static method 라고 불리는 것이 Associated fn 이다.</p>
<p>객체 생성없이 해당 객체의 함수를 호출할 수 있는 함수를 Associated fn 이라 하며 생성된 객체, 인스턴스의 함수를
method 라 한다. </p>
<p>예를 통해 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Point {
    x : f64,
    y : f64
}

impl Point {
	//Associated fn 객체 생성 없이 호출 가능.
    fn new() -&gt; Point {
        Point { x : 0.0, y : 0.0}
    }

	// method 생성된 객체, 인스턴스에서 호출할 수 있는 함수.
    fn transrate(&amp;mut self, x: f64, y: f64) {
        self.x = x;
        self.y = y;
    }
	// move 개념인데 눈으로만 익히고 넘어가면 곧 자세히 설명할 수 있는 챕터가 나온다. 
    fn drop_point(self) {
        let move_to_here = self;
        println!(&quot;point was dropped&quot;);
    }
}



fn main() {
    
     let mut point = Point::new();
     
     println!(&quot;new : {:?}&quot;, point);
     
     point.transrate(3.3, 3.3);
     
     println!(&quot;transrate : {:?}&quot;, point);

     point.drop_point();
	// 이미 move 된 후 drop 되었기 때문에 해당 인스턴스는 메모리에서 없어짐.
     // println!(&quot;can't call this {:?}&quot;, point);

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>클로져에 대해 알아보는 시간이다. 클로져는 무엇일까? 모던 언어에서는 클로져를 종종 볼 수 있다.
먼저 예제를 통해 클로져를 알아보자.</p>
<pre><code class="language-rsut  editable">
fn main() {
		
	let x = 3;
	// () 대신 || 사용.
	// 구문이 한 줄이라 {} 생략 가능.
	// 아래 클로져에서 x 는 캡쳐되어 사용 가능.
	let closure = | val:i32 | val + x ;

	println!(&quot; closure fn : {}&quot;, closure(3));	
	

}

</code></pre>
<ul>
<li>input value를 사용하기 위해 <code>()</code> 대신 <code>||</code> 을 사용한다.</li>
<li><code>{}</code> 구문 부분에서 생략 가능, 하지만 구문이 한줄이 아니라면 <code>{}</code> 사용한다. </li>
<li>클로져를 사용 시에는 다른 변수를 사용할 수 있다. Capturing 이라고 표현.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capturing"><a class="header" href="#capturing">Capturing</a></h1>
<p>클로져는 타입을 지정하고 선언하는 데 있어 상당히 자유롭게 작용하며 대부분 컴파일러가 알아서 파악한다. 
즉 캡쳐링 함에 있어 해당 변수를 borrow 할지 mut borrow 할 지, move 할 지 클로져 함수에 따라 컴파일러가 알아서 알아낸다.</p>
<ul>
<li>borrow &amp;T 참조만 하는 경우.</li>
<li>mut borrow &amp;mut T 변환가능하게 참조하는 경우.</li>
<li>T 데이터를 아예 가져오는 경우. </li>
</ul>
<p>크게는 이 세가지로 분류하며 이 경우를 잘 파악하고 인지하고 있어야 러스트를 깊이 있게 이해할 수 있다. </p>
<p>예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let color = String::from(&quot;red&quot;);
    // 캡쳐해서 변수의 값을 가져오는데, 이때는 &amp; 참조로만 사용한다.
    let print = || println!(&quot;참조만 하기 -&gt; {color}&quot;);
    // print() 클로져에서 color 를 참조로만 사용했기 때문에 다른 변수에 참조로 값을 선언할 수 있다.
    let t = &amp;color;

    print();
    // 하지만 color 를 그대로 참조없이 다른 변수에 넣어버리면 더 이상 print() 클로져를 사용할 수
    // 없게 된다.  즉 아래 변수 선언은 컴파일 에러가 난다.
    // let move_color = color;
    print();

    let mut count = 0;
    // inc() 클로져의 경우 count 를 캡쳐 한 후 숫자 1 씩 추가하는 함수인데, 이렇게 하기 위해선
    // 단순히 borrow 가 아닌 &amp;mut 또는 아예 가져와야하는데, 이럴 때에는 &amp;mut 를 컴파일러가 알아서
    // 사용한다.
    let mut inc = || {
        count += 1;
        println!(&quot;&amp;mut 변환가능한 참조 하기 -&gt; increase count by 1, current number is : {count}&quot;);
    };

    inc();
    // inc() 클로져에서 이미 count 변수를 &amp;mut 하게 사용하기 때문에 다른 변수에 선언할 수 없다.
    //let _count_borrowed = &amp;mut count;
    inc();
    inc();

    //카피가 되지 않는 타입으로 선언. 힙에 저장된 변수.
    let movable = Box::new(3);

    //drop 함수는 std::lib 에 존재하는 함수인데, 데이터 객체 그 자체를 필요로 하기 때문에 아예
    //move한다.
    let consume = || {
        println!(&quot;객체를 아예 옮겨버리기 -&gt;  movable : {:?}&quot;, movable);
        drop(movable);
    };

    consume();
    // 그렇기 때문에 아래 변수는 사용될 수 없다. 이미 consume 클로져에서 선언되었고 move했기
    // 때문이다. 모순 발생.
    //println!(&quot;{:?}&quot;, movable);

    let haystack = vec![1, 2, 3];
    
    //move 키워드를 사용하면 캡쳐링한 변수는 클로져로 이동하게 되어 사용할 수 없다.
    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;3));
    //아래 haystack 을 프린트 하는 함수를 사용하면 컴파일 에러가 난다. 
    //println!(&quot;{:?}&quot;, haystack);
    println!(&quot;{}&quot;, contains(&amp;4));
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-input-parameters"><a class="header" href="#as-input-parameters">As input parameters</a></h1>
<p>그렇다면 <code>Closure</code> 을 input parameter 로 받을 때에는 타입 지정을 어떻게 해야할까?
<code>std::lib</code> 에 지정된 trait 을 이용하는데 3가지 trait 을 이용하여 타입을 지정한다.</p>
<ul>
<li><code>Fn</code> - &amp;T -&gt; 오직 참조</li>
<li><code>FnMut</code> - &amp;mut T -&gt; 참조 그리고 변환</li>
<li><code>FnOnce</code> - T -&gt; 참조 변환 그리고 이동</li>
</ul>
<p>예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn use_fn&lt;F&gt;(fn_: F)
where
    F: Fn(),
{
    fn_()
}

fn use_fn_mut&lt;F&gt;(fn_mut: &amp;mut F)
where
    F: FnMut(),
{
    fn_mut()
}

fn use_fn_once&lt;F&gt;(fn_once: F)
where
    F: FnOnce(),
{
    fn_once()
}

fn main() {
    

    //Fn 을 사용한 경우
    let x = &quot;just using this value as ref&quot;;
    let fn_closure = || {
        println!(&quot;Fn : use fn as parameter : {x}&quot;);
    };

    use_fn(fn_closure);

    //println!(&quot;Fn : still can use this closure {:?}&quot;, fn_closure());
    

    //FnMut 사용한 경우

    let mut y = &quot;using fn mut and see how it works&quot;.to_string();

    let mut fnmut_closure = || {
        println!(&quot;FnMut : the sentence was -- {}&quot;, y);
        y = &quot;it works&quot;.to_string();
        println!(&quot;FnMut : the sentence changed -- {}&quot;, y);
    };

    use_fn_mut(&amp;mut fnmut_closure);

    //println!(&quot;FnMut : still can use this closure {:?}&quot;, fnmut_closure());

    //fnonce 사용한 경우
    
    let z = &quot;using this value as FnOnce&quot;.to_string();

    let fnonce_closure = || {
        println!(&quot;FnOnce : let's using this value as fnonce.&quot;);
        //두가지 방법으로 이동 시킬 수 있는데, 직접 변수에 캡쳐링 한 값을 넣는 경우
        // let move_this_value_to = z;
        //std::lib 에 있는 drop 함수를 이용해서 메모리에서 드랍 시키는 경우
        drop(z);
    };

    use_fn_once(fnonce_closure);
    //아래 주석을 풀면 컴파일 에러가 난다.
    // println!(&quot;{z}&quot;);
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-output-parameters"><a class="header" href="#as-output-parameters">As output parameters</a></h1>
<p>인풋 타입으로 클로져를 파라미터로 사용하는 것이 가능한 것 처럼 아웃풋 파라미터로도 사용이 가능하다.
하지만 클로져 자체가 익명함수이기 때문에 반환 값으로 타입을 지정하기가 애매하다. 
이럴땐 trait 로 리턴 값을 지정하면 된다.</p>
<p><code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 가 <code>trait</code> 로 구현된 것이기 때문이다. 추후에 <code>trait</code> 챕터에서 자세하게 다룰 예정이니 
눈으로 익히고 넘어가시길 바랍니다.</p>
<p>각 예제 마다 <code>move</code> 키워드를 사용했는데 왜 사용했을까?</p>
<p><code>move</code>와 <code>참조</code> 개념과 관련이 있는데, 블록 안에서는 변수 사용이 가능하지만 블록 밖으로 나가면 해당 변수는 메모리에서 드랍된다. (드랍에 대해서도 추후 챕터에서 나온다.) 
드랍된 변수는 더 이상 사용이 불가능하기 때문에 해당 <code>closure</code>는 변수 사용이 불가능하기에 컴파일 에러가 난다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn create_fn() -&gt; impl Fn() {
    let fn_text = &quot;fn_text&quot;.to_string();

    move || println!(&quot;this is a : {fn_text}&quot;)
}

fn create_fnmut() -&gt; impl FnMut() {
    let fnmut_text = &quot;fnmut_text&quot;.to_string();

    move || println!(&quot;this is a : {fnmut_text}&quot;)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let fnonce_text = &quot;fnonce_text&quot;.to_string();

    move || println!(&quot;this is a {fnonce_text}&quot;)
}

fn main() {
	// return 값이 클로져이다. 클로져를 실행하자. 
    let fn_function = create_fn();
    fn_function();

    let mut fnmut_function = create_fnmut();
    fnmut_function();

    let fnonce_function = create_fnonce();
    fnonce_function();
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-in-std-standard-lib-에-존재하는-예제"><a class="header" href="#examples-in-std-standard-lib-에-존재하는-예제">Examples in std, standard Lib 에 존재하는 예제</a></h1>
<h3 id="iteratorany-iter에-있는-any라는-함수에-대해"><a class="header" href="#iteratorany-iter에-있는-any라는-함수에-대해">Iterator::any, iter에 있는 any라는 함수에 대해</a></h3>
<p>any라는 함수는 해당 iter 객체에서 나온 element 가 예상한 어떤 value 값과 비교하여 맞으면 true 아니면 false 를 반환하는 함수이다.</p>
<p>std::lib 에서는 어떻게 구현했는지 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
//std::lib 에 구현된 iter trait 
pub trait Iterator {
    //해당 iter의 type 을 item 이라 지정한다.
    type Item;
    
    //any 함수는 자신을 파라미터로 받고 클로져도 파라미터로 받는다. return 값은 bool type. 
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        // 클로져에 대한 타입과 return 값으 지정한다. 클로저 파라미터 또한 해당 iter 객체의
        // 아이템인 것을 알 수 있다. 왜 이렇게 하는가?
        F: FnMut(Self::Item) -&gt; bool;
}

fn main() {
    let any_test = vec![1, 2, 3, 4, 5];
    // iter 로 변환할 수 있는데 Vec 타입의 변수를 구현하고
    // any 함수를 호출한다. 이때 any 함수는 파라미터로 자기 자신과 클로져를 받는다는 것을 알 수있다.
    // 호출할 때 자기 자신이 파라미터로 포함되었다. 그럼 클로져만 파라미터로 넣으면 된다.
    // || 를 사용하여 파라미터를 클로져를 구현하고 뒤에 리턴 값인 bool type 이 나올 수 있게 식을
    // 구현한다.
    let answer = any_test.iter().any(|&amp;x| x == 2);

    println!(&quot;{answer}&quot;);
}


</code></pre></pre>
<h3 id="iteratorfind-iter에-있는-find-라는-함수에-대해"><a class="header" href="#iteratorfind-iter에-있는-find-라는-함수에-대해">Iterator::find, iter에 있는 find 라는 함수에 대해</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Iterator {
    //해당 iter의 type 을 item 이라 지정한다.
    type Item;

    fn find&lt;P&gt;(&amp;mut self, p: P) -&gt; Option&lt;Self::Item&gt;
    where
        //find function 의 클로져는 iter 의 아이템을 &amp; 로 받음.
        P: FnMut(&amp;Self::Item) -&gt; bool;

    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        //any function 의 클로져는 iter 의 아이템을 &amp; 없이 받음.
        F: FnMut(Self::Item) -&gt; bool;
}

fn main() {
    let string_list = vec![&quot;hi&quot;.to_string(), &quot;bye&quot;.to_string()];
    //iter 를 통해 |x| 는 &amp;string 이 된다
    let answer_any = string_list.iter().any(|x| x == &quot;hi&quot; );
    println!(&quot;{}&quot;, answer_any);
    let str_list = vec![&quot;hi&quot;, &quot;bye&quot;];
    // iter 를 통해 |x| &amp;&amp;str 가 되고  == str에 &amp;를 붙이면 &amp;&amp; 가 되므로 비교 가능
    let str = str_list.iter().any(|x| x == &amp;&quot;hi&quot;);
    println!(&quot;{}&quot;, str);
    let num_list = vec![1,2,3,4,5];
    // iter 를 통해 |x| &amp;i32 가 되고 == i32 에 &amp;를 붙이면 &amp;i32 == &amp;i32 되므로 비교 가능
    let num = num_list.iter().any(|x| x == &amp;3);
    println!(&quot;{}&quot;, num);
    // find fn 는 &amp;를 추가한 item 값을 받는데 이유는 return 해야하기 때문이다.
    // &amp;&amp;string 이 되므로 == &amp;&amp;str 이랑 비교한다.
    let answer_find = string_list.iter().find(|&amp;x| x == &amp;&quot;hi&quot;);
    println!(&quot;{:?}&quot;, answer_find);
    let str_list = vec![&quot;hi&quot;, &quot;bye&quot;];
    //iter() 를 통해 &amp;str 가 되고 find 는 &amp;를 추가한 item 을 받기에 &amp;x 추가한다. 
    let find_str_list = str_list.iter().find(|&amp;x| x == &amp;&quot;hi&quot;);
    println!(&quot;find_str_list : {:?}&quot;, find_str_list);
    let fin_num_list = num_list.iter().find(|&amp;x| x == &amp;3);

    // iter 을 통해 |x| 값은 각 각 &amp;String, &amp;&amp;str, &amp;i32 가 된다. 
    // &amp;str 와 i32 는 Copy type 이다. &amp;x pattern 에 의해 destruct 된다.
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-모듈"><a class="header" href="#modules-모듈">Modules 모듈</a></h1>
<p>모듈이란 function, structs, traits, <code>impl</code> 블록 또는 다른 모듈 을 포함한 영역을 설명한다.코드의 영역을 나누거나 할 때 쓰인다. </p>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<ul>
<li><code>mod</code> - module 영역 선언</li>
<li><code>super</code> - 상위 단계에서 사용할 수 있도록 선언</li>
<li><code>private</code> - default </li>
</ul>
<p>러스트에서 default 는 private 이며 pub 선언 시 다른 영역에서 사용이 가능하다. 예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
pub mod my_mod {
    use self::nested::nested_fn_only_called_by_super_mod;

  
    pub fn test() {
        println!(&quot;hello tony good morning&quot;);
    }

    fn private_fn() {
        println!(&quot;it is private but can called by same module fn&quot;)
    }

    pub fn will_call_private_fn() {
        private_fn();
    }

    mod nested {
  
        fn nested_fn() {
            println!(&quot;nested fn&quot;);
        }

        pub(super) fn nested_fn_only_called_by_super_mod() {
            nested_fn();
        }

    }

    pub fn can_call_nested_fn_can_nested_private_fn() {
        nested_fn_only_called_by_super_mod();
    }

}

fn main() {
    my_mod::test();
    my_mod::will_call_private_fn();
    my_mod::can_call_nested_fn_can_nested_private_fn();
}

</code></pre></pre>
<p>mod 이라고 선언하는 것이 하나의 파일을 만들어 그 안에 작성하는 것과 거의 동일한 역할을 한다. ex)
test.rs 라는 파일 안에 pub hello fn 을 구현하고 현재 파일 내에서 mod test; 하면 해당
모듈(파일내함수) 들을 import 하여 쓰는 것과 동일한다.</p>
<h3 id="struct-visibility-and-use-keyword"><a class="header" href="#struct-visibility-and-use-keyword">Struct Visibility and use keyword</a></h3>
<p>다른 언어에서와 비슷하게 동작한다. 크게 어렵지 않게 이해할 수 있다.</p>
<ul>
<li><code>mod</code> - module 선언</li>
<li><code>associated fn</code> - new function </li>
<li><code>use</code>, <code>crate</code>, <code>as</code> - Alias 사용가능</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
mod my {
    pub struct OpenBox&lt;T&gt; {
        pub contents : T,
    }

    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        pub fn new(contents: T) -&gt; Self {
            ClosedBox { contents: contents }
        }
    }
}

use crate::my::ClosedBox as CBox;
fn main() {
    let open_box = my::OpenBox { contents: &quot;can put anything, it is public&quot; };
   
    // let closed_box = my::ClosedBox { contents: &quot;can't put anything, it is private&quot; };
    let closed_box = my::ClosedBox::new(&quot;struct can only be created when you use new associated fuction.&quot;);

    let t = CBox::new(&quot;I will call this CBox&quot;);

    println!(&quot;{:?}&quot;, t);
}


</code></pre></pre>
<h3 id="super-and-self"><a class="header" href="#super-and-self">super and self</a></h3>
<ul>
<li>super and self 개념은 자바스크립트나 자바에서 말하는 this == self, super 는 부모 모듈을 말한다. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<ul>
<li>
<p>crate 은 컴파일 유닛 - rustc some.rs 가 실행되면 해당 파일은 crate file 로 여겨진다.</p>
</li>
<li>
<p>crate 은 바이너리 또는 라이브러리 파일로 컴파일되며 default 는 바이너리. <code>--crate-type</code> flag 를 통해 지정도 가능. </p>
</li>
</ul>
<h3 id="creating-a-library-file"><a class="header" href="#creating-a-library-file">creating a library file.</a></h3>
<p>rary.rs 라는 파일 만든 후에 아래 코드를 작성한다. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub fn rary_fn() {
	println!(&quot; rary function &quot;);
}

<span class="boring">}
</span></code></pre></pre>
<p>shell 에서 라이브러리 타입으로 컴파일한다. 
lib은 default, prefix name 이고 뒤에 붙는 것이 우리가 생성한 파일 이름이다. </p>
<ul>
<li><code>--crate-name</code> 옵션으로 변경 가능.</li>
</ul>
<pre><code class="language-shell">$ rustc --crate-type=lib rary.rs 
$ ls lib*

library.rlib

</code></pre>
<h3 id="using-a-library"><a class="header" href="#using-a-library">Using a Library</a></h3>
<p>rlib 파일을 --extern 이름 지정 = library.rlib 에 추가하여 실행할 파일 추가한다. 
해당 파일에서 라이브러리 사용 가능.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	rary::public_fn();

}

</code></pre></pre>
<pre><code class="language-shell">
$ rustc main.rs --extern rary=library.rlib --edition=2021 &amp;&amp; ./main

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code> 공식적으로 러스트에서 지원하는 패키지 매니지먼트 툴이다. </p>
<ul>
<li>Dependency 관리를 쉽게 할 수 있음. <a href="https://crates.io">crates.io</a> - official package registry of rust</li>
<li>유닛테스트 지원</li>
<li>버전관리 용이</li>
</ul>
<p>카고에 대한 자세한 내용은 <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a> 참고하시길 바랍니다.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<ul>
<li>binary project 생성 방법</li>
<li>library project 생성 방법</li>
</ul>
<pre><code class="language-shell">
# A binary
$cargo new foo

# OR A library
$cargo new --lib foo 

</code></pre>
<h3 id="cargo-structure"><a class="header" href="#cargo-structure">Cargo Structure</a></h3>
<ul>
<li>Cargo.toml - config file </li>
<li>src - rs files</li>
</ul>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<ul>
<li>name - 프로젝트 이름</li>
<li>version - 버전 정보</li>
<li>authors - 작성자</li>
<li>dependencies - 추가할 디펜던시를 추가할 섹션 </li>
</ul>
<p>디펜던스 사이트
<a href="https://crates.io">crates.io</a></p>
<pre><code class="language-txt">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # from crates.io 
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # from online repo
bar = { path = &quot;../bar&quot; } # from a path in the local filesystem


</code></pre>
<p>참고 사이트 about Cargo
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">The Cargo book_format</a></p>
<h4 id="build--run"><a class="header" href="#build--run">build &amp; run</a></h4>
<ul>
<li>cargo build - 디펜덴시 다운로드 및 추가, 빌드</li>
<li>cargo run - 빌드 후 실행</li>
</ul>
<h3 id="conventions-바이너리-파일-실행"><a class="header" href="#conventions-바이너리-파일-실행">Conventions, 바이너리 파일 실행</a></h3>
<ul>
<li>main.rs 파일 외 다른 파일 실행하기 </li>
</ul>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
    └── other
          └── other_main.rs
</code></pre>
<pre><code class="language-shell">
$cargo r --bin other_main

</code></pre>
<p>카고에 대한 내용이 생각보다 방대하고 알아두면 좋은 지식들이 많기에 사이트를 둘러보는 것을 추천한다.</p>
<h3 id="cargo-test--build-scripts"><a class="header" href="#cargo-test--build-scripts">cargo test &amp; Build scripts</a></h3>
<p>추후 자세히 알아보자.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes-속성"><a class="header" href="#attributes-속성">Attributes, 속성</a></h1>
<p>모듈, 크래이트, 아이템 등에 적용되는 것을 말하는데 이 속성에는 metadata 가 들어있어 그 속성이 적용된다.</p>
<ul>
<li>컴파일할 때 조건 적용</li>
<li>크래이트 이름, 버전, 타입 setting</li>
<li>warnings 표시 유무</li>
<li>macros, glob imports 적용</li>
<li>외부 라이브러리와 연결</li>
<li>함수에 unit 테스트라고 표시</li>
</ul>
<p>예제)</p>
<ul>
<li>crate 적용 시 - #![crate_attribute], bash script 처럼 샤뱅 적용. </li>
<li>모듈이나 아이템에 적용 시 -  #[item_attribute] </li>
</ul>
<pre><code class="language-txt">
#[attribute(value, value2)]

#[attribute(value, value2, value3, value4)]

</code></pre>
<h3 id="dead_code"><a class="header" href="#dead_code">dead_code</a></h3>
<p>러스트 코드를 짤 때 unused function 에 대해 warnings 을 나타내는데 꽤나 귀찮을 때도 있다.
이때 dead_code attribute 를 사용하면 표시되지 않는다.</p>
<pre><code class="language-txt">
#[allow(dead_code)]
fn unused_function() {}

</code></pre>
<p>책에서 말하기를 사용되지 않는 코드는 아예 지우는 편을 추천한다. 물론 동의하는 바이다. 같이 일하는 사수가
귀에 딱지가 앉도록 코드 정리가 중요하다고 얘기하고 있는데 감사하게 생각한다.... 많이 배우고 있다.... 
thank to Min 부장님..</p>
<h3 id="cfg"><a class="header" href="#cfg">cfg</a></h3>
<p>Configuration 의 약자이며  OS 체크 시 유용하다.</p>
<ul>
<li>cfg 는 attribute.</li>
<li>cfg! macro </li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">//  attribute를 이용한 os 체크
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
	println!(&quot;yes. running on linux!&quot;);
}
// attribute 
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
	println1(&quot; Not running on linux!&quot;);
}


fn main() {

	are_you_on_linux();
	// 매크로를 사용하여 체크
	if cfg!(target_os = &quot;linux&quot;) {
		println!(&quot; yes yes. It is linux&quot;);
	}

}

</code></pre></pre>
<h3 id="custom"><a class="header" href="#custom">Custom</a></h3>
<p>target_os 와 같은 몇몇은 rustc 에 의해 제공된다. 하지만 입맛대로 생성하여 조건을 맞출 수 있다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[cfg(custom_my_condition)]
fn my_custom_condition() {
	println!(&quot; condition met! &quot;);
}


fn main() {
	my_custom_condition();
}

</code></pre></pre>
<p><code>cargo r</code> 하면 컴파일 에러가 나온다. 해당 컨디션을 컴파일러에게 미리 말해주어야 한다.</p>
<pre><code class="language-shell">$ rustc --cfg custom_my_condition main.rs ** ./main 

</code></pre>
<p>해당 컨디션은 컴파일에게 알려지고 컴파일 후 해당 함수가 실행된다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-제네릭"><a class="header" href="#generics-제네릭">Generics, 제네릭</a></h1>
<p>개인적으로 러스트에서 중요하게 생각하는 개념이 있는데 오너쉽, 트레이트, 그리고 제네릭 3가지라 생각한다.
그 중 제네릭에 대해 알아보자. 예제만 잘 숙달하여도 이해하는데 큰 문제는 없다고 생각한다. </p>
<p>말 그대로 제네릭은 포괄적인 타입을 말한다. 그래서 제네릭 타입을 나타낼 때에도 타입을 특정하지 않고 <code>camel case</code> 방식으로 &lt;Aaa, Bbb&gt; 로 표현한다. </p>
<h3 id="functions--implementation"><a class="header" href="#functions--implementation">Functions &amp; Implementation</a></h3>
<ul>
<li>struct 에 제네릭 타입을 사용할 때에는 이름 뒤에 <T> 를 사용한다. </li>
<li>impl 에 사용할 떄에는 impl, Struct 뒤에 사용한다. </li>
</ul>
<p>하나의 struct 으로 여러 타입의 struct 인스턴스 생성이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

#[derive(Debug)]
struct SGen&lt;T&gt; {
    random : T,
}

impl&lt;T&gt; SGen&lt;T&gt; {
    fn get_value(&amp;self) -&gt; &amp;T {
            &amp;self.random
    }
}


fn main() {  
       let gen = SGen { random : 3}; 
        println!(&quot;{:?}&quot;, &amp;gen);
       let gen2 = SGen { random : 3.3};
        println!(&quot;{:?}&quot;, &amp;gen2);
       let gen3 = SGen { random : &quot;hello&quot;.to_string()};
        println!(&quot;{:?}&quot;, &amp;gen3);
       let gen4 = SGen { random : &quot;Hi&quot;};
        println!(&quot;{:?}&quot;, &amp;gen4);
}

</code></pre></pre>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<p>trait 도 제네릭으로 활용할 수 있다. <code>Drop</code> <code>trait</code> 를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

#[derive(Debug)]
struct Empty;

#[derive(Debug)]
struct Null;

trait DoubleDrop&lt;T&gt;  {
    fn double_drop(self, _: T);
}

// impl 할 struct 을 제네릭 타입 U 로 추가하였다. 현재 crate 에선 모든 타입이
// double_drop 을 사용할 수 있게 된다. 

impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    fn double_drop(self, _: T) {}
}

fn main() { 
    let e = Empty;
    println!(&quot;{:?}&quot;, e);
    
    let n = Null; 
    println!(&quot;{:?}&quot;, n);

    // double_drop 함수 실행 후 더 이상 n, e는 사용할 수 없게 된다.
    n.double_drop(e);
    // println!(&quot;{:?}&quot;, n);
}


</code></pre></pre>
<h3 id="bounds"><a class="header" href="#bounds">Bounds</a></h3>
<p>제네릭의 타입을 정하고 제한하는 것을 바운드라고 한다.</p>
<p>바운드 표현 방식에 대해 알아보자</p>
<ul>
<li>타입 뒤에 <code>:</code> 후 바운드</li>
<li>리턴 값 지정하기 전에 where 구문을 뒤에 바운드</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">

use std::fmt::Display;

// 타입 뒤에 바로 바운드
fn printer&lt;T: Display&gt;(t: &amp;T) {
    println!(&quot;{}&quot;, t);
}

// 타입 지정 후 리턴 값 넣기 전에 where T : 방법으로 바운드
fn printer_&lt;T&gt;(t: &amp;T)
where
    T: Display,
{
    println!(&quot;{}&quot;, t);
}


fn main() {
   
    //struct 자체에는 display 가 되지 않기에 따로 구현 필요. 
    struct NoDisplayTrait(i32);

    //생성 시점 부터 display 를 구현한 타입만 받을 수 있게 바운드 처리.
    struct NeedDisplayTrait&lt;T: Display&gt;(T);

    let string_p = &quot;tony&quot;.to_string();


    printer(&amp;string_p);


    printer_(&amp;string_p);


    let nodisplay =NoDisplayTrait(3);
    
    // struct 은 display trait 이 구현되지 않았기에 printer 함수 실행 불가.
    
    // printer(&amp;nodisplay);
   
    // vec 타입은 display trait 을 구현하지 않았기에 아예 생성 조차 불가능.

    // let vec_is_not_impl_display = NeedDisplayTrait(vec![1,2,3]);
   


}

</code></pre></pre>
<p>예제를 통해 자세히 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    length: f64,
    height: f64,
}

struct Triangle {
    length: f64,
    height: f64,
}

//trait HasArea 생성 후 함수만 생성
trait HasArea {

    fn area(&amp;self) -&gt; f64;

}


// HasArea 를 impl 한 Rec 
impl HasArea for Rectangle {

	// 함수식 구현
    fn area(&amp;self) -&gt; f64 {

        println!(&quot;this is rectangle&quot;);
        self.length * self.height
    
    }
}

// HasArea 를 impl 한 Tri 
impl HasArea for Triangle {

	// 함수식 구현
    fn area(&amp;self) -&gt; f64 {

        println!(&quot;this is triangle&quot;);
        (self.length * self.height) / 2.0
    
    }
}


// where 를 이용한 바운드
// 하나의 함수를 만들고 제네릭 타입을 받고 바운드 처리 후 
// 해당 trait 를 구현한 타입에 한해서 함수 실행.

fn get_area&lt;T&gt;(objec: &amp;T) -&gt; f64
where
    T: HasArea,
{
    objec.area()
}

fn main() {
    let rec = Rectangle {
        length: 3.0,
        height: 3.0,
    };

    let tri = Triangle {
        length: 3.0,
        height: 3.0,
    };

    let rec_area = get_area(&amp;rec);
    println!(&quot;{:?}&quot;, rec_area);

    let tri_area = get_area(&amp;tri);
    println!(&quot;{:?}&quot;, tri_area);
}

</code></pre></pre>
<h4 id="testcase-empty-bounds"><a class="header" href="#testcase-empty-bounds">Testcase: empty bounds</a></h4>
<p>trait 에 함수가 없어도 유용하게 쓰일 수 있다. 예로 Copy 와 Eq trait 이 그러하다.</p>
<p>예제를 통해 어떻게 타입을 바운드 하는지 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Rectangle {
    length: f64,
    height: f64,
}

struct Korea;
struct China;

trait Hanbok {}

// 이렇게 Korea 란 struct 을 impl 하는 것으로 해당 struct 의 타입은 Hanbok 으로 바운드 된다.
impl Hanbok for Korea {}


// 해당 함수는 Hanbok 이란 타입으로 제한하고 있다. 
fn ownership&lt;T&gt;(_: &amp;T) -&gt; &amp;'static str
where
    T: Hanbok,
{
    &quot;한복&quot;
}

fn main() {
    let k = Korea;
    let c = China;


	// 함수 호출 불가능
    // println!(&quot;{:?}&quot;, ownership(&amp;c));

	// 호출 가능    
    println!(&quot;{:?}&quot;, ownership(&amp;k));
}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-items--phantom-type-parameters"><a class="header" href="#associated-items--phantom-type-parameters">Associated items &amp; Phantom type parameters</a></h1>
<p>말 그대로 Associated item 을 제네릭 타입과 결합하여 어떻게 활용할 수 있는지 알아보자.</p>
<p>trait 에서도 다른 제네릭 타입을 받을 수 있으며 이를 활용할 수 있는데, 
아래 예제에서 처럼 제네릭을 선언할 수 있다. 하지만 이렇게 선언해버리면 코드 짜기가 여간 불편한 게 아니다. </p>
<h3 id="associated-items"><a class="header" href="#associated-items">Associated items</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Contains&lt;A, B&gt; {
    ....
}


<span class="boring">}
</span></code></pre></pre>
<p>해당 trait 를 impl 할 떄 예제이다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            // 타입 A, B를 추가해야함 
impl Contains&lt;i32, i32&gt; for SomeThing {


}

   // 해당 trait 을 이용한 함수를 선언할 때에도 A, B, C 타입에 대해서도 
   // 선언해야 한다.  
fn diff&lt;A, B, C&gt;(con : &amp;C) -&gt; i32 
   where C : Contains&lt;A, B&gt;  {
   
   }

<span class="boring">}
</span></code></pre></pre>
<p>이러한 문제를 해결해보자.
바로 trait 안에 타입을 선언하는 것이다. 예제를 통해 알아보자.</p>
<pre><code class="language-initrust editable">
	// 해당 trait 안에 A, B 타입 선언
trait Contains {
    type A;
    type B;
    
   	// 함수에 위에서 선언한 타입을 이용 
    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;

    fn first(&amp;self)-&gt; i32;
    
    fn last(&amp;self) -&gt; i32;
}

struct Container(i32, i32);

	// 구현할 struct 내부에서 타입 선언
impl Contains for Container {
    type A = i32;
    type B = i32;

    fn contains(&amp;self, a: &amp;Self::A, b: &amp;Self::B) -&gt; bool {
        self.0 == *a &amp;&amp; self.1 == *b
    }

    fn first(&amp;self)-&gt; i32 {
        self.0
    }

    fn last(&amp;self) -&gt; i32 {
        self.1
    }
}

	// 함수 선언 시에도 하나의 타입만 선언하면 된다.
fn difference&lt;C&gt;(con : &amp;C) -&gt; i32 
    where C : Contains {
        con.last() - con.first()
    }



fn main() {
    let t = 3;
    let tt = 3;

    let c = Container(3, 3);
    let result = c.contains(&amp;t, &amp;tt);
    println!(&quot;{:?}&quot;, result);

    println!(&quot;{:?}&quot;, difference(&amp;c));

}

</code></pre>
<p>기존에는 A = B = C 가 같은 영역 안의 타입으로 지정되었다면,<br />
Associated type 을 활용하면 C 영역 안에 A와 B 타입이 선언된다. 
당연히 C type 을 구현할(impl) 타입에서 A와 B을 선언하니 A, B 타입을 따로 선언할 필요가
없게 된다.</p>
<h3 id="phantom-type"><a class="header" href="#phantom-type">Phantom type</a></h3>
<p>팬텀 타입은 런타임에는 나타나지 않고 컴파일 타임에 나타나 체크하는 타입을 말합니다.
데이터 타입은 제네릭 타입을 파라미터로 활용하여 표시용이나 컴파일 타입에 체크용으로 활용할 수 있습니다.
이러한 타입은 메모리에 어떠한 데이터도 갖고 있지 않으며 런타임에도 아무 영향을 미치지 못합니다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::marker::PhantomData;

#[derive(PartialEq)]
struct PhantomTuple&lt;A, B&gt;(A, PhantomData&lt;B&gt;);

#[derive(PartialEq)]
struct PhantomStruct&lt;A, B&gt; {
    first: A,
    phantom: PhantomData&lt;B&gt;,
}

// 메모리에 'A' 타입은 지정되어 있지만 'B'는 지정되어 있지 않다.

fn main() {
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);

    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    println!(&quot; tuple 1 == tuple 2 can not be compared because they are different type&quot;);

    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'S',
        phantom: PhantomData,
    };

    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'S',
        phantom: PhantomData,
    };

    // println!(&quot; struct 1 == struct 2 비교할 수가 없다. 이 둘의 타입이 다르기 때문 : {}&quot;, _struct1 == _struct2);
}


</code></pre></pre>
<h3 id="testcase--unit-clarification"><a class="header" href="#testcase--unit-clarification">TestCase : Unit clarification</a></h3>
<p>팬텀타입에 관해 활용 케이스를 알아보자.</p>
<p><a href="https://www.youtube.com/watch?v=Qr9PhKURf2g">영상으로 배우기</a></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::Add;
use std::marker::PhantomData;


// Add 함수에서 객체가 카피되기 때문에 Clone과 Copy를 구현하였다.
#[derive(Debug, Clone, Copy)]
enum Inch {}

#[derive(Debug, Clone, Copy)]
enum Mm {}



// Length는 Unit 을 제네릭으로 받는 Struct이다. 
// 여기서 팬텀 타입은 타입 체크를 위해 추가한 것.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);


impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
    type Output = Length&lt;Unit&gt;;

	// length Struct 에서 첫번째 값만 연산을 하고 두번째 팬텀데이터는 타입 체크를 위해 활용되기 때문에, PhantomData 라고 추가하여 리턴한다.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // '+' 를 사용하면  Add 함수를 호출한다. 
        Length(self.0 + rhs.0, PhantomData)
    }

}


fn main() {
	    
	    // 동일한 타입만 연산됨. 
    let inch_1: Length&lt;Inch&gt; = Length(3.0, PhantomData);

    let return_inch = inch_1 + Length(12.0, PhantomData);

    println!(&quot;{:?}&quot;, return_inch);

    let mm_1 : Length&lt;Mm&gt; = Length(1000.0, PhantomData); 
    let mm_2 : Length&lt;Mm&gt; = Length(1000.0, PhantomData); 

    
    let return_mm = mm_1 + mm_2; 

    println!(&quot;{:?}&quot;, return_mm);


}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoping-rules오너쉽-참조-라이프타임"><a class="header" href="#scoping-rules오너쉽-참조-라이프타임">Scoping rules(오너쉽, 참조, 라이프타임)</a></h1>
<p>Scoping rules - ownership 과 borrowing 그리고 lifetimes 에서 중요한 역할을 한다. </p>
<h3 id="part-1---raii-resource-acquistion-is-initialization"><a class="header" href="#part-1---raii-resource-acquistion-is-initialization">part 1 - RAII (Resource Acquistion Is Initialization)</a></h3>
<p>러스트에서 변수는 데이터를 스택에 저장하는 것만 하는 것은 아니다. --&gt; 리소스를 소유하고 있다. 
예로 Box<T> 는 힙에 저장된 메모리를 소유하고 있다. 
러스트는 RAII 를 강요하는데, 특정 객체가 스코프를 벗어나게 되면, 이 객체는 destructor 를
호출하고 소유하고 있던 리소스 또한 없어진다. </p>
<p>이러한 행위는 리소스 누수 버그를 예방하고 수동적으로 메모리를 없앨 필요가 없다. 
예제를 통해 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn create_box() {
    // Allocate an integer on the heap, 힙에 지정 i32 type 
    let _box1 = Box::new(3i32); 

    // `_box1` is destroyed here, and memory gets freed, scope 가 끝나는 시점에서 메모리에서 없어짐. 
}


fn main() {

    // Allocate an integer on the heap, 힙에 i32 타입 지정
    let _box2 = Box::new(5i32);


    // A nested scope:  scope 만들기. 
    {
        // Allocate an integer on the heap, scope 안에서 힙에 i32 타입 지정
        let _box3 = Box::new(4i32);

        // `_box3` is destroyed here, and memory gets freed, scope 끝나는 시점에서 destructor 호출 -&gt; drop 
    }

    // Creating lots of boxes just for fun
    // There's no need to manually free memory!,

    //1000 개를 힙에 저장시키지만 단 한 개도 남지 않는다. 
    
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` is destroyed here. 


}

</code></pre></pre>
<h3 id="part-2-destructor"><a class="header" href="#part-2-destructor">part 2 Destructor</a></h3>
<p>스코프를 벗어날 때 호출되는 destructor 는 러스트가 제공하는 <code>Drop</code> trait 에 의해 실행된다.
자동으로 실행되며 따로 코드를 impl 할 필요는 없지만 필요하다면 구현할 수도 있다. 
변수가 scope 를 벗어나려는 순간, destructor 는 호출되며 drop 이 실행된다. </p>
<pre><pre class="playground"><code class="language-rust edition2021">
    // part 2 
    struct ToDrop;
    impl Drop for ToDrop {
        fn drop(&amp;mut self) {
            println!(&quot;이 객체는 dropped 된다.&quot;);
        }
    }
    fn main() {

    let x = ToDrop;
    println!(&quot;곧 드랍될 예정&quot;);

}


</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-move-borrowing"><a class="header" href="#ownership-move-borrowing">Ownership, Move, Borrowing</a></h1>
<h3 id="part-1-오너쉽-그리고-이동-ownership-and-moves"><a class="header" href="#part-1-오너쉽-그리고-이동-ownership-and-moves">part 1 오너쉽 그리고 이동 (Ownership and moves)</a></h3>
<p>메모리에 저장된 리소스는 오직 한 변수만을 오너로 삼는다. 참고할 것은 모든 변수가 리소스를 소유하고 있는 것은 아니다. 레퍼런스를 가질 때도 있기 때문이다. </p>
<p><code>let x = y</code>를 선언하거나 foo라는 함수에 <code>foo(x)</code> 를 적용하였을 시에는 오너쉽이 이동하게 된다. 
y는 x 변수 안으로, 함수에서 x는 foo라는 함수 안으로 이동.</p>
<p>러스트에서는 이러한 이동을 <code>move</code>라고 얘기한다. </p>
<p>이렇게 이동하게 된 값, 즉 y나 함수에서 사용된 x값은 더 이상 사용할 수 없다. 
이렇게 하면 dangling pointers 를 예방할 수 있다. </p>
<h3 id="part-2-변환-mutability"><a class="header" href="#part-2-변환-mutability">part 2 변환 (Mutability)</a></h3>
<p>오너쉽이 다른 변수로 이동하였을 때, 변환타입(immutable -&gt; mutable) 변경이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span> let immut_box = Box::new(5u32);

 let mut mut_box = immut_box;

<span class="boring">}
</span></code></pre></pre>
<h3 id="part-3-부분-이동partial-moves"><a class="header" href="#part-3-부분-이동partial-moves">part 3 부분 이동(Partial moves)</a></h3>
<p>변수를 destructuring 할 때, <code>by-move</code>, <code>by-reference</code> 패턴 바인딩이 동시에 가능하다. 
다만 이렇게 할 때, 부분적으로 변수가 이동하게 된다. 즉 변수의 한 부분이 이동할 때 다른 한 부분은 변수에 머물게 된다. 
이런 경우는 해당 변수는 전체로써 사용은 불가능하지만 부분적으로는 사용이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {


     #[derive(Debug)]
     struct Person {
         name : String,
         age : Box&lt;u8&gt;
     }
      
     let person = Person { name: String::from(&quot;Tony&quot;), age: Box::new(35) };
    
     let Person { name, ref age } = person;
   
     println!(&quot;what is your name : {:?}&quot;, name);
     let name_move = name;
    
     println!(&quot;{:?}&quot;, name_move);
    
     println!(&quot;{:?}&quot;, person.age);
     // println!(&quot;{:?}&quot;, person); // 전체 객체로는 사용이 불가능
}

</code></pre></pre>
<h3 id="part-4-빌림-borrowing"><a class="header" href="#part-4-빌림-borrowing">part 4 빌림 (Borrowing)</a></h3>
<p>대부분 데이터에 접근할 때 오너쉽을 가져와서 사용하지 않는다. 이때 러스트에서는 빌림 메커니즘을 이용한다(borrowing mechanism). 
값을 (<code>T</code>) 를 그대로 던져주는 것이 아닌 (<code>&amp;T</code>) 를 사용한다.</p>
<p>러스트 컴파일러는 정적인 상태에서도 (borrow checker 를 통해) 우리가 사용 중인  reference 에 대해 항상 값이 존재하는 것을 보장한다. 
즉 참조값이 존재한다는 것은 해당 객체가 없어지는 않는다는 것이다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {


     fn eat_box_i32(boxed_i32 : Box&lt;i32&gt;) {
         println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
     }
   
     fn borrow_i32(borrowed_i32 : &amp;i32) {
         println!(&quot;This int is : {}&quot;, borrowed_i32);
     }
   
     let boxed_i32 = Box::new(5_i32);
     let stacked_i32 = 6_i32;
     
     borrow_i32(&amp;boxed_i32);
     borrow_i32(&amp;stacked_i32);
   
     {
         let _ref_to_i32 = &amp;boxed_i32;
         println!(&quot;{:?}&quot;, _ref_to_i32);
     } 
     // &amp;boxed_i32 값은 _ref_to_i32 로 이동하였지만 {} 스쿠핑 룰에 의해 참조값은 드랍된다. 
     // 온전한 값으로 다시 사용 가능.
    eat_box_i32(boxed_i32);
   }

</code></pre></pre>
<h3 id="part-5-변환-mutability"><a class="header" href="#part-5-변환-mutability">part 5 변환 (Mutability)</a></h3>
<p>변환 데이터 (Mutable data) 는 <code>&amp;mut T</code> 를 이용하여 mutably borrowed 가 가능하다. 이를 <em>mutable reference</em> 라 하며 참조값에 대해 읽기/쓰기 접근이 가능하다. 반대로 <code>&amp;T</code> 는 immutably borrowed 가 가능하며 <em>immutable reference</em> 하며 참조값에 대해 읽기 접근만 가능하다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

fn main() {
  
    struct Book {
        author : &amp;'static str,
        title : &amp;'static str,
        year : u32,
    }

    fn borrow_book(book : &amp;Book) {
        println!(&quot;immutably borrowed {} - {} edition&quot;, book.title, book.year);
    }

    fn new_edition(book : &amp;mut Book) {
        book.title = &quot;Rust란&quot;;
        book.year = 2014;
        println!(&quot;mutably borrowed {} - {} edition&quot;, book.title, book.year);
    }

    let mut immutabook = Book {
        author: &quot;tony&quot;,
        title: &quot;rust란&quot;,
        year: 2020,
    };


    borrow_book(&amp;immutabook);

    new_edition(&amp;mut immutabook);

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="러스트-데이터-구조와-알고리즘"><a class="header" href="#러스트-데이터-구조와-알고리즘">러스트 데이터 구조와 알고리즘</a></h1>
<h3 id="chapters"><a class="header" href="#chapters">Chapters</a></h3>
<p>section 1</p>
<ul>
<li>about lifetime, generics that are most important in rust</li>
</ul>
<p>section 2</p>
<ul>
<li>sorting an algorithm complexity.</li>
</ul>
<p>section 3</p>
<ul>
<li>lists and tress (linked lists, binary tress etc)</li>
</ul>
<p>section 4</p>
<ul>
<li>about graph ( pathfinding algorithms)</li>
</ul>
<p>section 5 </p>
<ul>
<li>HashMap data structure</li>
</ul>
<p>section 6</p>
<ul>
<li>Organizing your data by type with Entity Component Systems</li>
</ul>
<p>section 7</p>
<ul>
<li>Persistent Storage Data structure ( something like a HashMap as a file)</li>
</ul>
<h3 id="goals"><a class="header" href="#goals">Goals</a></h3>
<ul>
<li>Confidence using Rust's Lifetime system.</li>
<li>Understanding of common algorithms (library algorithm).</li>
<li>Confidence building your own libraries based on.</li>
<li>Understanding of the design decisions made in building useable algorithms.</li>
<li>Knowing when to choose which kind of structure. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="section-1"><a class="header" href="#section-1">Section 1</a></h1>
<h3 id="results-and-options"><a class="header" href="#results-and-options">Results and Options</a></h3>
<p>this section, we are going to learn about Results and Options in rust.</p>
<p>Before using Results and Options in rust std lib, we are going to make our own result.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">//lets build our own result type.

#[derive(Debug)]
enum Res&lt;T, E&gt; {
    Thing(T),
    Error(E),
}

//우리가 만든 Res, result 타입은 T, E 제네릭 타입으로 어떤 타입으로도 생성이 가능하다.
//아래 함수에서 쓰일 T, E 의 타입은 i32, String 으로 정한다.
fn divide(a: i32, b: i32) -&gt; Res&lt;i32, String&gt; {
    if b == 0 {
        // b 가 0 이면 divide 가 불가능함으로 바로 return 한다.
        return Res::Error(&quot;0으로 나누는 것은 불가능합니다.&quot;.to_string());
    }
    Res::Thing(a / b)
}

fn main() {
    let a = divide(3, 0);

    if let Res::Error(e) = a {
        println!(&quot;error : {e}&quot;);
    }
}


</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">pub struct Stepper {
    curr: i32,
    step: i32,
    max: i32,
}

impl Stepper {
    fn new() -&gt; Self {
        Stepper {
            curr: 1,
            step: 3,
            max: 55,
        }
    }
}
impl Iterator for Stepper {
    // 현재 iter 를 구현한 stepper 의 item type 은 i32 이며
    type Item = i32;

    // next 함수 호출 시, max 값 보다 적을 때만 값을 리턴한다.
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.max &lt; self.curr {
            return None;
        }
        // 현재 값을 리턴하고 curr 값에는 step 만큼 증가 시킨다.
        let res = self.curr;
        self.curr += self.step;
        Some(res)
    }
}

fn main() {
    // associate fn 을 이용하여 객체를 생성
    let mut step = Stepper::new();
    
    // 현재 값이 맥스 값 보다 작을 때에만 while 진행
    while step.curr &lt; step.max {
        //match 를 사용하여 증가 값을 보여주며 분기 적용.
        match step.next() {
            Some(v) =&gt; {
                println!(&quot;the current value is {:?}&quot;, v);
            }
            None =&gt; {
                println!(&quot;the step can not go higher anymore, the current value is {:?}, and max value is {:?}&quot;,                    step.curr, step.max);
            }
        }
    }
}

</code></pre></pre>
<!-- ### Stack Data Strutrue in Rust  -->
<!---->
<!--  what is a Stack ? -->
<!---->
<!--  * It is a list where items are added at one end and removed from the same endd -->
<!--  * For instance, like a stack of plates -->
<!--  * This mostly used in rapidly changing objects, parsers, and graphic processing like JavaScript Canvas operations -->
<h3 id="mutability-variables-copying-and-cloning"><a class="header" href="#mutability-variables-copying-and-cloning">Mutability, Variables, Copying, and Cloning</a></h3>
<p>we are going to learn about copying and cloning </p>
<ul>
<li>heap, and stack memory that can copy or not </li>
<li>type that implements copy trait and clone trait</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
// 일반적으로 러스트에서는 struct를 복사하는 것은 불가능하다. 다른언어와는 다르기 때문에 이점을 많이 어려워한다.
// 예제를 살펴보자.

#[derive(Debug)]
struct Person {
    name : String,
    age : i32,
}

fn main() {
    let p = Person {
        name: &quot;Tony&quot;.to_string(),
        age: 35,
    };

    let p2 = p;

    println!(&quot;{:?}&quot;, p2);

    // p can not print because it is not impl copy trait. and String value is stored in the heap
    // memory. only stack memory implements copy trait automatically.
    
    // println!(&quot;{:?}&quot;, p);

    // but if we implements Clone trait, we can copy String into another section of memory

}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
// 하지만 derive 라는 컴포넌트 자바에 @하고 Service 등 하는 것과 비슷하다. 
// derive 로 Clone 을 implements 하게 되면 해당 struct 과 String 필드는 Clone 이 가능하다. 
// 즉 struct 이 복사가 가능해진다.

#[derive(Debug, Clone)] //  String 타입은 Clone trait 을 impl 함 
struct Person {
    name : String, 
    age : i32,
}



fn main() {
    let mut p = Person {
        name: &quot;Tony&quot;.to_string(),
        age: 35,
    };

    let p2 = p.clone();
    p.name.push_str(&quot;lee&quot;);
    println!(&quot;{:?}&quot;, p2);
    
    // p can not print because it is not impl copy trait. and String value is stored in the heap
    // memory. only stack memory implements copy trait automatically.

    println!(&quot;{:?}&quot;, p);

    // Copy 를 implements 한 타입 적용.
    #[derive(Debug, Clone, Copy)] // 안에 필드는 copy trait 를 impl 한 타입이라 copy 를 적용해야
                                 // 함. 단 Clone 도 해야하는데, 이유는 객체도 복사해야되기 때문. 
    struct Point {
        x : i32,
        y : i32,
    }

    let pnt = Point {x: 3, y: 3};

    let pnt2 = pnt; // .copy() 를 호출할 필요 없음 
   		    // copy trait 와 clone trait 의 차이점이 존재. -- copy 는 호출할 필요 없음.  
    println!(&quot;{:?}&quot;, pnt);
    
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>

        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>

        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
