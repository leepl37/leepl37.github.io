<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>tony</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="一切唯心造">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="rustOS/intro.html"><strong aria-hidden="true">2.</strong> writing_OS_with_Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rustOS/freestandingRustBinary.html"><strong aria-hidden="true">2.1.</strong> rust_binary_and_kernel_and_VGA_text</a></li></ol></li><li class="chapter-item "><a href="system/index.html"><strong aria-hidden="true">3.</strong> systemProgremming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="system/lecture1.html"><strong aria-hidden="true">3.1.</strong> lecture1</a></li><li class="chapter-item "><a href="system/lecture2.html"><strong aria-hidden="true">3.2.</strong> lecture2</a></li></ol></li><li class="chapter-item "><a href="rust_book/intro.html"><strong aria-hidden="true">4.</strong> Summary of The Rust Programming Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="rust_book/3_common_programming_concepts.html"><strong aria-hidden="true">4.1.</strong> Common Programming Concepts, Ch3</a></li><li class="chapter-item "><a href="rust_book/4_understanding_ownership.html"><strong aria-hidden="true">4.2.</strong> UNDERSTANDING OWNERSHIP, Ch4</a></li><li class="chapter-item "><a href="rust_book/5_using_structs_to_structure_related_data.html"><strong aria-hidden="true">4.3.</strong> USING STRUCTS TO STRUCTURE RELATED DATA, Ch5</a></li><li class="chapter-item "><a href="rust_book/6_enums_and_pattern_matching.html"><strong aria-hidden="true">4.4.</strong> ENUMS AND PATTERN MATCHING, Ch6</a></li><li class="chapter-item "><a href="rust_book/7_managing_growing_projects_with_packages_creates_and_modules.html"><strong aria-hidden="true">4.5.</strong> MANAGING GROWING PROJECTS WITH PACKAGES, CREATES, AND MODULES, Ch 7</a></li><li class="chapter-item "><a href="rust_book/8_common_collections.html"><strong aria-hidden="true">4.6.</strong> COMMON COLLECTIONS, Ch 8</a></li><li class="chapter-item "><a href="rust_book/9_error_handling.html"><strong aria-hidden="true">4.7.</strong> ERROR HANDLING, Ch 9</a></li><li class="chapter-item "><a href="rust_book/10_generic_types_traits_and_lifetimes.html"><strong aria-hidden="true">4.8.</strong> GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10</a></li><li class="chapter-item "><a href="rust_book/13_iterators_and_closures.html"><strong aria-hidden="true">4.9.</strong> FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13</a></li><li class="chapter-item "><a href="rust_book/14_more_about_cargo_and_creates_io.html"><strong aria-hidden="true">4.10.</strong> MORE ABOUT CARGO AND CREATES.IO, ch 14</a></li><li class="chapter-item "><a href="rust_book/15_smart_pointers.html"><strong aria-hidden="true">4.11.</strong> SMART POINTERS, ch 15</a></li><li class="chapter-item "><a href="rust_book/16_fearless_concurrency.html"><strong aria-hidden="true">4.12.</strong> Fearless Concurrency, Ch 16</a></li><li class="chapter-item "><a href="rust_book/17_object-oriented_programming_features_of_rust.html"><strong aria-hidden="true">4.13.</strong> Object Oriented programming, Ch 17</a></li><li class="chapter-item "><a href="rust_book/19_advanced_features.html"><strong aria-hidden="true">4.14.</strong> Advanced Features, Ch 19</a></li></ol></li><li class="chapter-item "><a href="example/example.html"><strong aria-hidden="true">5.</strong> Rust by example(번역)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/hello.html"><strong aria-hidden="true">5.1.</strong> Hello World 출력</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/hello/comment.html"><strong aria-hidden="true">5.1.1.</strong> Comments, 주석</a></li><li class="chapter-item "><a href="example/hello/print.html"><strong aria-hidden="true">5.1.2.</strong> Formatted print, 출력에 관해</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/hello/debug_display.html"><strong aria-hidden="true">5.1.2.1.</strong> Debug & Display</a></li></ol></li><li class="chapter-item "><a href="example/hello/testcase.html"><strong aria-hidden="true">5.1.3.</strong> TestCase: List(iter 개념과 Option 개념이 필요함)</a></li></ol></li><li class="chapter-item "><a href="example/primitives.html"><strong aria-hidden="true">5.2.</strong> Primitives, 원시타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/primitives/arrays_and_slices.html"><strong aria-hidden="true">5.2.1.</strong> Arrays and Slices</a></li></ol></li><li class="chapter-item "><a href="example/customtype.html"><strong aria-hidden="true">5.3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/customtype/testcase.html"><strong aria-hidden="true">5.3.1.</strong> TestCase: linked-list</a></li><li class="chapter-item "><a href="example/customtype/constants.html"><strong aria-hidden="true">5.3.2.</strong> constants</a></li></ol></li><li class="chapter-item "><a href="example/variablebinding.html"><strong aria-hidden="true">5.4.</strong> Variable Bindings,변수 바인딩</a></li><li class="chapter-item "><a href="example/types.html"><strong aria-hidden="true">5.5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/types/casting_literals.html"><strong aria-hidden="true">5.5.1.</strong> casting_and_literals</a></li><li class="chapter-item "><a href="example/types/inference_aliasing.html"><strong aria-hidden="true">5.5.2.</strong> inference_and_aliasing</a></li></ol></li><li class="chapter-item "><a href="example/conversion/conversion.html"><strong aria-hidden="true">5.6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/conversion/from_and_into.html"><strong aria-hidden="true">5.6.1.</strong> From and Into, tryFrom and tryInto</a></li><li class="chapter-item "><a href="example/conversion/to_and_from_strings.html"><strong aria-hidden="true">5.6.2.</strong> To and from Strings</a></li></ol></li><li class="chapter-item "><a href="example/expressions.html"><strong aria-hidden="true">5.7.</strong> Expressions</a></li><li class="chapter-item "><a href="example/flowAndControl/flow_and_control.html"><strong aria-hidden="true">5.8.</strong> Flow and Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/flowAndControl/for_and_iter.html"><strong aria-hidden="true">5.8.1.</strong> for_and_iter</a></li><li class="chapter-item "><a href="example/flowAndControl/match.html"><strong aria-hidden="true">5.8.2.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/flowAndControl/pointer_and_ref.html"><strong aria-hidden="true">5.8.2.1.</strong> pointers/ref</a></li><li class="chapter-item "><a href="example/flowAndControl/guards_and_binding.html"><strong aria-hidden="true">5.8.2.2.</strong> Guards/Binding</a></li></ol></li><li class="chapter-item "><a href="example/flowAndControl/if_let_and_while_let.html"><strong aria-hidden="true">5.8.3.</strong> if let / while let</a></li></ol></li><li class="chapter-item "><a href="example/functions/about_funtions.html"><strong aria-hidden="true">5.9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/functions/methods.html"><strong aria-hidden="true">5.9.1.</strong> Methods</a></li><li class="chapter-item "><a href="example/functions/closures/closures.html"><strong aria-hidden="true">5.9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/functions/closures/capturing.html"><strong aria-hidden="true">5.9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="example/functions/closures/as_input_parameters.html"><strong aria-hidden="true">5.9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="example/functions/closures/as_output_parameters.html"><strong aria-hidden="true">5.9.2.3.</strong> As output parameters</a></li><li class="chapter-item "><a href="example/functions/closures/iterator_searching_thro_iter.html"><strong aria-hidden="true">5.9.2.4.</strong> Examples in std</a></li></ol></li></ol></li><li class="chapter-item "><a href="example/modules/modules.html"><strong aria-hidden="true">5.10.</strong> Modules</a></li><li class="chapter-item "><a href="example/crates/crates.html"><strong aria-hidden="true">5.11.</strong> Crates</a></li><li class="chapter-item "><a href="example/cargo/cargo.html"><strong aria-hidden="true">5.12.</strong> Cargo</a></li><li class="chapter-item "><a href="example/attributes/attributes.html"><strong aria-hidden="true">5.13.</strong> Attributes, 속성</a></li><li class="chapter-item "><a href="example/generics/generics.html"><strong aria-hidden="true">5.14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/generics/generic_associated_phantom.html"><strong aria-hidden="true">5.14.1.</strong> Associated items & Phantom type parameters</a></li></ol></li><li class="chapter-item "><a href="example/scoping/scoping.html"><strong aria-hidden="true">5.15.</strong> Scoping rules-오너쉽, 참조, 라이프타임</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="example/scoping/ownership_move_borrowing.html"><strong aria-hidden="true">5.15.1.</strong> Ownership Move Borrowing</a></li><li class="chapter-item "><a href="example/scoping/lifetimes.html"><strong aria-hidden="true">5.15.2.</strong> Lifetimes</a></li></ol></li><li class="chapter-item "><a href="example/traits.html"><strong aria-hidden="true">5.16.</strong> Traits</a></li><li class="chapter-item "><a href="example/macro.html"><strong aria-hidden="true">5.17.</strong> macro</a></li></ol></li><li class="chapter-item "><a href="dataStructureAndAlgorithms/intro.html"><strong aria-hidden="true">6.</strong> 데이터 구조와 알고리즘</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="dataStructureAndAlgorithms/section1.html"><strong aria-hidden="true">6.1.</strong> Section 1</a></li></ol></li><li class="chapter-item "><a href="spManual/createDid.html"><strong aria-hidden="true">7.</strong> SP_manual</a></li><li class="chapter-item affix "><li class="part-title">SP Manual</li><li class="chapter-item "><a href="spmanual/start.html"><strong aria-hidden="true">8.</strong> SP MANUAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="spmanual/chapter_1.html"><strong aria-hidden="true">8.1.</strong> ch1</a></li><li class="chapter-item "><a href="spmanual/chapter_2.html"><strong aria-hidden="true">8.2.</strong> ch2</a></li><li class="chapter-item "><a href="spmanual/chapter_3.html"><strong aria-hidden="true">8.3.</strong> ch3</a></li><li class="chapter-item "><a href="spmanual/chapter_4.html"><strong aria-hidden="true">8.4.</strong> ch4</a></li><li class="chapter-item "><a href="spmanual/chapter_5.html"><strong aria-hidden="true">8.5.</strong> ch5</a></li><li class="chapter-item "><a href="spmanual/etc.html"><strong aria-hidden="true">8.6.</strong> etc</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">tony</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h3 id="hi"><a class="header" href="#hi">Hi.</a></h3>
<p>I'm a guy who like to study about computer programming language. </p>
<p>specifically <em>Rust</em>. </p>
<p>this blog is about me, and Rust. </p>
<!-- tonypl3737@gmail.com  -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-an-os-in-rust"><a class="header" href="#writing-an-os-in-rust">writing an OS in Rust</a></h1>
<p>small operating system 을 구현해보자 . </p>
<p>출처 Philipp Oppermann's blog [https://os.phil-opp.com/]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a-freestanding-rust-binary"><a class="header" href="#a-freestanding-rust-binary">A Freestanding Rust Binary</a></h1>
<img src=./images/os-01.jpg>
<img src=./images/os-02.jpg>
<img src=./images/os-03.jpg>
<img src=./images/os-04.jpg>
<img src=./images/os-05.jpg>
<img src=./images/os-06.jpg>
<img src=./images/os-07.jpg>
<img src=./images/os-08.jpg>
<img src=./images/os-09.jpg>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시스템-프로그래밍"><a class="header" href="#시스템-프로그래밍">시스템 프로그래밍</a></h1>
<p>개발자 첫 취업을 응용어플리케이션 쪽으로 하다보니 항상 시스템 쪽 프로그래밍에 대한 뭔가 조금 더 근본적인 것에 대한 갈망이 항상 존재해왔다.</p>
<p>그러다보니 로우레벨 언어인 러스트에 더욱 관심을 가졌는지도 모르겠다. </p>
<p>우연찮게 알게된 한양대 교수님의 강의가 유투브에 무료로 올라와 있는 것을 발견하였고</p>
<p>보다가 강의가 너무 좋아 조금씩 강의를 들으면서 정리하고자 한다. </p>
<p>감사합니다 잘 볼게요 교수님 :) </p>
<h3 id="수업-개요"><a class="header" href="#수업-개요">수업 개요</a></h3>
<ol>
<li>수업 내용에 대해(Course introduction)</li>
<li>유닉스와 리눅스(Unix and Linux Basics)</li>
<li>c 프로그래밍 리뷰(C Programming review)</li>
<li>쓰레드와 프로세스(Threads and processes)</li>
<li>스케쥴링(Scheduling)</li>
<li>동기화(Synchronization)</li>
<li>프로세스 간 통신(Inter-process communication)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lecture1"><a class="header" href="#lecture1">lecture1</a></h1>
<p>시스템 프로그래밍은 Embedded Software 또는 Hardware 부분에 속해 있다. </p>
<p><img src="system/./img/softwareANDhardware.png" alt="softwareANDhardware" /></p>
<ul>
<li>
<p>Software Curriculum</p>
<ul>
<li>컴퓨터 시스템 내에서 어떻게 적용이 되며 어떤 일이 일어나는지에 대해 고려하면서 프로그래밍 하는 것을 배운다.</li>
<li>데이터 구조</li>
<li>운영 체제(메모리 관리, os 기능 등)</li>
</ul>
</li>
<li>
<p>Hardware</p>
<ul>
<li>마이크로프로세서(하드웨어) 이해하고 프로그래밍하는 것이 중요</li>
<li>컴퓨터 구조</li>
<li>알고리즘 ( 데이터 구조에서 진보된 챕터)</li>
</ul>
</li>
<li>
<p>배울 내용에 대해 간단히 도식화 해보자. </p>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>Computer systems</th><th>Embedded systems</th></tr></thead><tbody>
<tr><td><p><img src="system/./img/computersystem.png" alt="softwareANDhardware" /></p></td><td><p><img src="system/./img/embeddedsystem.png" alt="softwareANDhardware" /></p></td></tr>
<tr><td>내용</td><td>서로 다른 시스템이라 불리지만 흡사한 일련의 과정을 거쳐서 어플리케이션을 동작시킨다.</td></tr>
<tr><td>궁금</td><td>하드웨어와 OS가 어떻게 동작하는지에 대해 궁금함..</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p>하드웨어</p>
<ul>
<li>입력 장비 ( 키보드, 마우스) -&gt; cpu (hdd, ram)
<ul>
<li>ex( cpu -&gt; x86, arm..)</li>
</ul>
</li>
<li>출력 장비 (모니터, 프린터, 스피커)</li>
</ul>
</li>
<li>
<p>운영체제 </p>
<ul>
<li>
<p>커널 스페이스</p>
<ul>
<li>Architecture dependent kernel( 하드웨어와 가장 처음 맞닿는 영역, 하드웨어에 의존적)</li>
<li>커널(운영체제의 코어 영역), *핵심은 파일시스템과 프로세스 관리
<ul>
<li>파일 시스템(ex -exd2, 각 os 마다 사용하는 파일 시스템이 다름)</li>
<li>Inter-process communication ( 프로세스 간의 통신 - 추후 자세히 안내)</li>
<li>I/O and device management</li>
<li>Process management</li>
</ul>
</li>
<li>System call interface ( api 같은, 함수화 되어 있는 기능, 파일 열기 등 )</li>
</ul>
</li>
<li>
<p>유저 인터페이스 </p>
<ul>
<li>Libraries ( system call interface lib )</li>
<li>User applications </li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>아래 표는 위의 내용 도식화한 것이다. </li>
</ul>
<p><img src="system/./img/operatingsystem.png" alt="os" /></p>
<ul>
<li>
<p>하드웨어가 발전함에 따라 멀티 쓰레딩, 멀티 프로세싱도 함께 발전. </p>
</li>
<li>
<p>OS의 타입</p>
<ul>
<li>배치 </li>
<li>멀티 프로그래밍 </li>
<li>멀티프로세서</li>
<li>분산 OS (물리적으로 컴퓨터가 분산된 상태에서 사용)</li>
<li>리얼타임 OS (미사일 무기) </li>
</ul>
</li>
<li>
<p>이 수업에서는 Linux 를 주로 사용한다. </p>
<ul>
<li>유닉스와 동일하게 동작한다. (단지 개인 피씨에서 사용됨)</li>
</ul>
</li>
<li>
<p>C Program Development Environment </p>
</li>
</ul>
<ol>
<li>editor -&gt; disk (코드 입력 및 저장)</li>
<li>Preprocessor -&gt; disk ( 컴파일될 라이브러리, ex: include stdio.h .. 을 가져와 소스에 추가) </li>
<li>Compiler -&gt; disk (코드 메모리 영역에 배치, 코드를 어셈블리화 하고 바이너리(오브젝트코드) 를 만듦)</li>
<li>Linker -&gt; disk (오브젝트를 코드를 다 붙인다. ex: inlclude 된 함수, 다른 곳에 있는 lib을 링크시킴)</li>
<li>Loader -&gt; disk (실행, 메모리에 올림, 메모리 영역도 다섯가지 정도로 분산 배치 됨) </li>
<li>cpu -&gt; 하나하나 씩 읽어와서 코드를 실행시킴 </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lecture2"><a class="header" href="#lecture2">lecture2</a></h1>
<h3 id="about-text-editor"><a class="header" href="#about-text-editor">about text editor</a></h3>
<p>vi 편집기는 패스! 이미 충분히 익숙함</p>
<h3 id="gcc"><a class="header" href="#gcc">GCC</a></h3>
<ul>
<li>
<p>gnu c/c++ compiler </p>
</li>
<li>
<p>gcc is C code </p>
</li>
<li>
<p>g++ is C++ </p>
</li>
<li>
<p>console-based compiler (터미널에 커맨드 입력을 통해) </p>
</li>
<li>
<p>gcc perfoms the followings</p>
<ul>
<li>preprocessing,</li>
<li>complilation,</li>
<li>assembly,</li>
<li>linking</li>
</ul>
</li>
<li>
<p>More Info, &quot; man gcc &quot;</p>
</li>
</ul>
<h3 id="gcc-options--or-flags"><a class="header" href="#gcc-options--or-flags">GCC Options ( or Flags)</a></h3>
<ul>
<li>
<p>-c : perfomrs compilation and assembly of source file without linking.</p>
<ul>
<li>outfile is object file, if it compiles with link, then output file is excutive file. </li>
</ul>
</li>
<li>
<p>-o : specify output file name, if not specify the flag output file name is default. ex) a.out </p>
</li>
<li>
<p>-g : debug flag, </p>
</li>
<li>
<p>-Wall : show all warning. </p>
</li>
<li>
<p>-I<path> : specify the path where the headerfile is located. </p>
</li>
<li>
<p>-L<path> : specify the path where the libs is located.</p>
</li>
<li>
<p>-l<libname> : specify the lib name.</p>
</li>
<li>
<p>-Werror : Treat warning as errors. </p>
</li>
</ul>
<h4 id="example"><a class="header" href="#example">example</a></h4>
<p><img src="system/./img/gcc_example.png" alt="softwareANDhardware" /></p>
<p><img src="system/./img/makefileexample.png" alt="softwareANDhardware" /></p>
<그림1>
<p><img src="system/./img/makefileexample2.png" alt="softwareANDhardware" /></p>
<그림2>
<ul>
<li>
<p>그림1과 그림2는 alias 를 걸어둔 것만 차이가 있으며 동일하게 사용할 수 있다.</p>
</li>
<li>
<p>compile 시 c에서 c++ 을 사용하거나 이름을 변경할 때 &lt;그림2&gt; 상단만 alias 부분만 수정하면 되서 편리함.</p>
</li>
</ul>
<h4 id="componets-of-a-makefile"><a class="header" href="#componets-of-a-makefile">Componets of a makefile</a></h4>
<ul>
<li>
<p>Comments </p>
<ul>
<li>a comment is indicated by the character &quot;#&quot;</li>
</ul>
</li>
<li>
<p>Rules </p>
<ul>
<li>2 lines. </li>
</ul>
<pre><code class="language-rs">	hello.o : hello.c   // rull name : Dependency
		gcc -c hello.c  // 명령어 
</code></pre>
</li>
<li>
<p>Dependency Lines </p>
<pre><code>hello.exe: main.o hello.o  // dependency line 
	gcc main.o hello.o -o hello.exe 	
</code></pre>
</li>
<li>
<p>Shell Lines </p>
<pre><code>hello.exe: main.o hello.o  
	gcc main.o hello.o -o hello.exe // shell line, \t 이 필수 
</code></pre>
</li>
<li>
<p>Macro </p>
<pre><code>home = /home/user1 //alias 와 동일하게 사용가능
lib = $(home) // 사용 시 $()  
</code></pre>
</li>
<li>
<p>Inference Rules </p>
<pre><code>%.o : %.c  // the &quot;%&quot; is used to indicate a wild card 
	$(cc) $ (FLAGS) -c $(SRC) 
</code></pre>
</li>
</ul>
<p><img src="system/./img/example3.png" alt="os" /></p>
<ul>
<li>설명
cc = gcc
DIR = /home/user1/lib 
CFLAGS = -g -I$ (DIR) -I. -c   // compile 시 다른 옵션을 주기 위함 
LFLAGS = -g 
std : 룰 이름 / analysis.o 디펜던시 추가 </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-rust-progamming-language-by-carol-nichols"><a class="header" href="#the-rust-progamming-language-by-carol-nichols">The Rust Progamming Language by Carol Nichols</a></h1>
<p>러스트 기본서 라고 불리는 책이다. 
공식 홈페이지에서도 제공되고 현재 번역본과 원서 두가지가 제공되고 있긴 하지만 필자는 원서로 공부하였다. </p>
<ul>
<li>그냥 읽는 것은 내 머리 수준으로는 정리가 되지 않았다.</li>
<li>3회 정도 훑어보았지만 부족함을 느꼈다. </li>
<li>아예 필사를 해보자 하였지만 이마저도 큰 도움이 되지 않는 거 같앴다.</li>
<li>다시 꼼꼼히 읽으면 각 챕터별 중요한 문장을 밑줄치고 그것을 정리하는 것이 좋을 것 같다는 것이 나의 결론이다. </li>
<li>그래서 정리한다. </li>
</ul>
<h3 id="아-개인적으로-이-책을-정말-좋아한다"><a class="header" href="#아-개인적으로-이-책을-정말-좋아한다">아 개인적으로 이 책을 정말 좋아한다.</a></h3>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-programming-concepts-ch3"><a class="header" href="#common-programming-concepts-ch3">Common Programming Concepts, ch3</a></h1>
<h2 id="summary"><a class="header" href="#summary">Summary:</a></h2>
<p>this chapter introduces essential programming concepts that are common not only in Rust but also in many other languages.
The chapter covers variables, data types, functions, comments, and control flow.</p>
<h3 id="key-concepts"><a class="header" href="#key-concepts">key Concepts:</a></h3>
<h4 id="1variables-and-mutablility"><a class="header" href="#1variables-and-mutablility">1.Variables and Mutablility</a></h4>
<ul>
<li><code>Variables</code> and <code>Mutability</code>:
<ul>
<li><code>Variables</code> are immutable by default in Rust. </li>
<li>To make a variable mutable, use the <code>mut</code> keyword.</li>
</ul>
</li>
</ul>
<h5 id="example-1"><a class="header" href="#example-1">Example:</a></h5>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	
	
	let x = 5; // Immutable variable
	
	let mut y = 6; // Mutable variable

	// x += 1; //Not allowed.
	y += 1; //Allowed because y is mutable

	println!(&quot; result of `y` : {}&quot;, y);

}</code></pre></pre>
<h4 id="2-data-types"><a class="header" href="#2-data-types">2. Data Types:</a></h4>
<ul>
<li>Scalar - integers, floating-point numbers, Booleans and characters. 
<ul>
<li>int - signed, unsigned : 8 ~ 128 bit and isize, usize. </li>
</ul>
</li>
<li>Compound - tuples, arrays 
<ul>
<li>Can take user-defined <code>struct</code> and <code>enumeration</code>. </li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	
	let a: i32 = 10;
	
	let b = 3.14; // Type inference 

	let x : i32 = -1;

	let y : u32 = 1;

	let pi: f64 = 3.14159265359;

	let is_true : bool = true;

	let c : char = 'a';

	//Tuples : can contain mutiple values of different types.
	let person : (i32, f64, &amp;str) = (25, 5.9, &quot;Ho&quot;);

	//Arrays : only contains the same type.
	let numbers : [i32, 3] = [3,2,1];
}
</code></pre></pre>
<h4 id="3-functions"><a class="header" href="#3-functions">3. Functions:</a></h4>
<ul>
<li>Functions are defined using the <code>fn</code> keyword.</li>
<li>Parameters must have their types explicitly annotated.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn add(x : i32, y : i32) -&gt; i32 {
	 x + y 
}

fn main() {
	 println!(&quot; x + y = {}&quot;, add(3, 5));
}
</code></pre></pre>
<h4 id="4-comments"><a class="header" href="#4-comments">4. Comments:</a></h4>
<ul>
<li>Single-line comments start with <code>//</code></li>
<li>Multi-line comments are rarely used but start with <code>/*</code> and end with <code>*/</code>.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
	
	// This is a single-line comment

	/* This is a 
		 muti-line comment */

}</code></pre></pre>
<h5 id="5-control-flow"><a class="header" href="#5-control-flow">5. Control Flow:</a></h5>
<ul>
<li><code>if-else</code>, <code>loop</code>, <code>while</code>, and <code>for</code> are available for control flow.</li>
</ul>
<h5 id="6-statements-and-expressions"><a class="header" href="#6-statements-and-expressions">6. Statements and Expressions</a></h5>
<ul>
<li>
<p>Statements: These are instructions that perform some action and do not return a value. They usually end with a semicolon(<code>;</code>).</p>
</li>
<li>
<p>Expressions : These are pieces of code that evaluate to a value and do not end with a semicolon. </p>
<ul>
<li>Expressions can be part of a statement. </li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

		let x = 5; //Statement : This initializes the variable `x` with the value 5.

		let y = (x + 1); // Expression : ` x + 1 ` evaluates to a value (6 in this case).
		
		
		let x1 = 5;  // statement

		let y1 = {
				let z = 3;  // statement
				z + 1 // expression
		}; // this block is also an ??

		println!(&quot; y = {}&quot;, y1);


}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><img src="rust_book/./img/ownership/ownership_01.jpg" alter="ownership images">
<img src="rust_book/./img/ownership/ownership_02.jpg" alter="ownership images">
<img src="rust_book/./img/ownership/ownership_03.jpg" alter="ownership images">
<img src="rust_book/./img/ownership/ownership_04.jpg" alter="ownership images">
<h1 id="understanding-ownership-ch4"><a class="header" href="#understanding-ownership-ch4">UNDERSTANDING OWNERSHIP, ch4</a></h1>
<p>it enables Rust to make memory safety guarntees without needing a garbage collector. </p>
<p>in this chapter, we will talk about </p>
<ul>
<li>ownership </li>
<li>borrowing, slices, how rust lays data out in memory ( stack &amp; heap )</li>
</ul>
<h3 id="what-is-ownership"><a class="header" href="#what-is-ownership">What is Ownership?</a></h3>
<p>Some languages have garbage collector, and C lang use explicitly allocate and free the memory
but rust use different kind of system.</p>
<ul>
<li>Memory is managed through a system of ownership with a set of rules that the compliler checks at compile time. </li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>the stack and the heap</th></tr></thead><tbody>
<tr><td>All data stored on the stack must have a known, fixed size. Data with an unkown size at compile time or size that might change must be stored on the heap instead</td></tr>
</tbody></table>
</div>
<h3 id="ownership-rules"><a class="header" href="#ownership-rules">Ownership Rules</a></h3>
<ul>
<li>Each value has a variable that's called its owner. </li>
<li>There can be only one owner at a time.</li>
<li>When the owner goes out of scope, the value will be dropped. </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	{
		let s = &quot;who are you?&quot;;
		println!(&quot;{}&quot;, s); 
	}  // s variable will be dropped after this scope 
}</code></pre></pre>
<ul>
<li>When s comes into scope, it is valid. </li>
<li>It remains valid until it goes out of scope. </li>
</ul>
<h3 id="the-string-type"><a class="header" href="#the-string-type">The String Type</a></h3>
<p>String type is allocated on the heap and as such is able to store an amount of text that is unknown to us at compile time. </p>
<ul>
<li>String </li>
<li>str, &amp;String </li>
</ul>
<p>the difference is how these two topes deal with memory. </p>
<h3 id="memory-and-allocation"><a class="header" href="#memory-and-allocation">Memory and Allocation</a></h3>
<p>str case, we know this comtents of size at compile time. </p>
<p>pros -&gt; fast and efficient.</p>
<p>cons -&gt; can not change the value.</p>
<ul>
<li>we can not put a blob of memory into the binary for each piece of text whose size is unknown at conpile time and whoese size might change while running the program. </li>
</ul>
<p>In other to grow and mutable piece of text, we need to allocate an amount of memory on the HEAP </p>
<ul>
<li>
<p>The memory must be requested from the operating system at runtime.</p>
<ul>
<li>ex) String::from().. etc </li>
</ul>
</li>
<li>
<p>We need to way of returning this memory to the operating system when we are done with our String. </p>
<ul>
<li>ex) drop </li>
</ul>
</li>
</ul>
<h4 id="the-memory-is-automatically-returned-once-the-variable-that-owns-it-goes-out-of-the-scope"><a class="header" href="#the-memory-is-automatically-returned-once-the-variable-that-owns-it-goes-out-of-the-scope">the memory is automatically returned once the variable that owns it goes out of the scope.</a></h4>
<ul>
<li>when the variable goes out of scope, rust program automatically calls the drop method that drops the varable and free the memory. </li>
</ul>
<h3 id="ways-that-variable-and-data-interact--move"><a class="header" href="#ways-that-variable-and-data-interact--move">Ways That Variable and Data Interact : Move</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	let s1 = String::from(&quot;hello&quot;);
	let s2 = s1; 

}
</code></pre></pre>
<ul>
<li>value </li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>s1</th><th>status</th></tr></thead><tbody>
<tr><td>name</td><td>value</td></tr>
<tr><td>ptr</td><td>pointer to heap memory</td></tr>
<tr><td>len</td><td>5</td></tr>
<tr><td>capacity</td><td>5</td></tr>
</tbody></table>
</div>
<ul>
<li>pointer to heap memory </li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>index</th><th>value</th></tr></thead><tbody>
<tr><td>0</td><td>h</td></tr>
<tr><td>1</td><td>e</td></tr>
<tr><td>2</td><td>l</td></tr>
<tr><td>3</td><td>l</td></tr>
<tr><td>4</td><td>o</td></tr>
</tbody></table>
</div>
<ul>
<li>value's pointer is pointing to the heap memory that holding the value &quot;hello&quot;.</li>
</ul>
<p>when s1 is copied to s2 then s1 and s2 have same pointer. 
what if we drop s2 and keep the s1, this will cause memory loss. s1's pointer can not find value that holding in the heap. </p>
<p>So rust uses &quot;move&quot;.</p>
<p>s1 is moved to s2 then s1 is no longer valid. </p>
<h3 id="ways-that-variables-and-data-interact--clone"><a class="header" href="#ways-that-variables-and-data-interact--clone">Ways that Variables and Data Interact : Clone</a></h3>
<ul>
<li>Heap data does get coppied. </li>
</ul>
<h3 id="stack-only-data--copy"><a class="header" href="#stack-only-data--copy">Stack-Only Data : Copy</a></h3>
<p>if a type have a copy trait, an older variable is still usable after assignment. rust won't allow to use copy trait if the type implement drop trait. </p>
<p>then what types are Copy ? -&gt; scala type. </p>
<ul>
<li>integer, bool, char, floating, tuple that only contains scala type. </li>
</ul>
<h3 id="mutable-references"><a class="header" href="#mutable-references">Mutable References</a></h3>
<p>Mutable reference has one bing restriction -&gt; can not allow borrow once it mutably borrow. </p>
<p>The benefit of having this restriction is that rust can prevent data races at compile time.
A data race is similar to a race condtion and happens when these three behaviors occur :</p>
<ul>
<li>
<p>Two or more pointers access the same data at the same time. </p>
</li>
<li>
<p>At least one of the pointers is being used to write to the data. </p>
</li>
<li>
<p>There's no mechanism being used to synchronize access to the data. </p>
</li>
</ul>
<h3 id="dangling-references"><a class="header" href="#dangling-references">Dangling References</a></h3>
<p>a pointer that references a location in memory that may have been given to someone else, by freeing some memory while preserving a pointer to that memory. </p>
<ul>
<li>rust ensure that the data can not be dangle when you compile the code. </li>
<li>compiler let you know where the dangling occurs. </li>
</ul>
<h3 id="the-rules-of-references"><a class="header" href="#the-rules-of-references">The Rules of References</a></h3>
<ul>
<li>
<p>At any given time, you can have either but not both of the following: one mutable reference or any number of immutable references. </p>
</li>
<li>
<p>References must always be valid. </p>
</li>
</ul>
<h3 id="the-slice-type"><a class="header" href="#the-slice-type">The Slice Type</a></h3>
<p>Another data that does not have ownership is the slice. 
Slices let you reference a contiguous sequence of elements in a collection. </p>
<p>-&gt; String slices.  its same &amp;String and &amp;str.</p>
<h3 id="summary-1"><a class="header" href="#summary-1">Summary</a></h3>
<p>Ownership, borrowing, and slices ensure memory safety in Rust at compile time. </p>
<div style="break-before: page; page-break-before: always;"></div><img src="rust_book/./img/struct/struct_01.jpg" alter="struct images">
<img src="rust_book/./img/struct/struct_02.jpg" alter="struct images">
<h1 id="using-structs-to-structure-related-data-ch5"><a class="header" href="#using-structs-to-structure-related-data-ch5">USING STRUCTS TO STRUCTURE RELATED DATA, ch5</a></h1>
<p>Custome data type. </p>
<p>Struct and Enums are the building blocks for creating new types in your program's domain to take full advantage of rust's compile time type checking. </p>
<ul>
<li>
<h3 id="when-you-use-mut-keyword-on-struct-entire-instance-must-be-mutable"><a class="header" href="#when-you-use-mut-keyword-on-struct-entire-instance-must-be-mutable">when you use mut keyword on struct, entire instance must be mutable.</a></h3>
</li>
<li>
<h3 id="using-the-field-init-shorthand-when-variables-and-field-have-the-same-name"><a class="header" href="#using-the-field-init-shorthand-when-variables-and-field-have-the-same-name">using the field init shorthand when variables and field have the same name.</a></h3>
</li>
<li>
<h3 id="creating-instances-from-other-instances-with-struct-update-sysntax--user1"><a class="header" href="#creating-instances-from-other-instances-with-struct-update-sysntax--user1">creating instances from other instances with struct update sysntax ( ..user1)</a></h3>
<ul>
<li>ex) User { ..user1 }; </li>
</ul>
</li>
<li>
<h3 id="using-tuple-structs-without-named-field-to-create-different-types"><a class="header" href="#using-tuple-structs-without-named-field-to-create-different-types">using tuple structs without named field to create different types</a></h3>
<ul>
<li>ex) struct Color(i32, i32, i32);</li>
<li>ex) struct Point(i32, i32, i32);</li>
</ul>
</li>
<li>
<h3 id="unit-like-structs-without-any-fields"><a class="header" href="#unit-like-structs-without-any-fields">Unit-Like structs without any fields</a></h3>
<ul>
<li>ex) struct A(); </li>
<li>ex) implements trait with unit-like struct is useful. you can distingush with just unit-like struct </li>
</ul>
</li>
<li>
<h3 id="method"><a class="header" href="#method">method</a></h3>
<ul>
<li>ex) impl User { fn method(self, &amp;self, &amp;mut self) }</li>
<li>rust has a feature called automatic referencing and dereferencing
<ul>
<li>
<p>object.something(), rust automatically adds in &amp;, &amp;mut, or * so object matches the signature of the method. </p>
</li>
<li>
<p>the fact that rust makes borrowing implicit for method receivers is a big part of making ownership ergonomic in practice. </p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="associated-functions"><a class="header" href="#associated-functions">associated functions</a></h3>
<ul>
<li>ex) impl user { fn new() -&gt; something {} } </li>
<li>there no self parameter in associated function, it can be used for making a new instance.. etc </li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><img src="rust_book/./img/enum/enum_01.jpg" alter="enum images">
<h1 id="enums-and-pattern-matching-ch6"><a class="header" href="#enums-and-pattern-matching-ch6">ENUMS AND PATTERN MATCHING, Ch6</a></h1>
<h3 id="this-chapter-covers"><a class="header" href="#this-chapter-covers">this chapter covers...</a></h3>
<ul>
<li>
<p>how an enum can encode meaning along with data </p>
</li>
<li>
<p>explore particulary useful enum, called Option </p>
</li>
<li>
<p>how pattern matching in the match expression </p>
</li>
<li>
<p>if let construct</p>
</li>
</ul>
<h4 id="rusts-enums-are-most-similar-to-algebraic-data-types-in-functional-languages-such-as-f-ocaml-and-haskell"><a class="header" href="#rusts-enums-are-most-similar-to-algebraic-data-types-in-functional-languages-such-as-f-ocaml-and-haskell">Rust's enums are most similar to algebraic data types in functional languages, such as F#, OCaml, and Haskell.</a></h4>
<h3 id="defining-and-using-enum"><a class="header" href="#defining-and-using-enum">defining and using enum</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
	enum IpAddrKind {
		V4, // or V4(u8, u8, u8, u8) 
		V6, // or V6(String),
	}

	let four = IpAddrKind::V4; // or IpAddrKind::V4(127, 0, 0, 1);
	let six = IpAddrKind::V6; // or IpAddrKind::V6(String::from(&quot;::1&quot;));
}
</code></pre></pre>
<ul>
<li>
<p>example of enum </p>
<p>enum Msg {
Quit,
Move { x: i32, y: i32}, 
Write(String), 
ChangeColor(i32, i32, i32),
}</p>
<p>-&gt; Msg Enum whose variants each store different amounts and types of values.</p>
<ul>
<li>Quit has no data associated with it at all. </li>
<li>Move includes an anonymous struct inside it. </li>
<li>Write includes a single String. </li>
<li>ChangeColor includes a three i32 values </li>
</ul>
</li>
<li>
<p>why are we using enum?
-&gt; if we use different structs, which each have their own type, we couldn't as easily define a fucntion. </p>
</li>
</ul>
<h3 id="the-option-enum-and-its-advantages-over-null-values"><a class="header" href="#the-option-enum-and-its-advantages-over-null-values">The Option Enum and Its Advantages over Null Values.</a></h3>
<ul>
<li>
<p>Expressing this concept in terms of the type system means the compiler can check whether you've handled all the cases you should be handling. </p>
</li>
<li>
<p>Rust does not have null feature. 
-&gt; the problem with null values is that if you try to use null value as  not-null value, you'll get an error of some kind. </p>
<p>-&gt; the concept that null is trying to express is still a useful one: a null is value that is currently invalid or absent for some reason. </p>
</li>
<li>
<p>Rust does have an enum that can encode the concept of a value being present of absent. </p>
</li>
</ul>
<pre><code class="language-rs">enum Option&lt;T&gt; {
	Some(T),
	None, 
}
	
	let some_number = Some(5);
	let some_string = Some(&quot;a string&quot;);
	let absent_number : Option&lt;i32&gt; = None; 
</code></pre>
<ul>
<li>it included in the prelude. </li>
<li>you can you Some or None directly. </li>
<li>if we use None rather than Some, we need to tell Rust what type of Option<T> we have because compiler can not infer the type. </li>
<li>can not use value inside some directly, we need to take the value from Some<T> </li>
</ul>
<h3 id="the-match-control-flow-operator"><a class="header" href="#the-match-control-flow-operator">The match Control Flow Operator</a></h3>
<pre><code class="language-rs">	let some_val = Some(123);

	match some_val {
		Some(t) -&gt; println!(&quot;in some, there is value : {}&quot;, t),
		_ -&gt; println!(&quot;there is no value at all&quot;), // or we can use use (), 
		
	};

</code></pre>
<ul>
<li>in this case, uses '_' in match this means it can take all cases that aren't specified before it. </li>
<li>() is just the unit type, nothing will happen in the _ case. </li>
</ul>
<h3 id="if-let"><a class="header" href="#if-let">if let</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	let some_val = Some(123);

	if let val = some_val {
		println!(&quot;there is vale inside some_val : {}&quot;, val);
	}else{
		println!(&quot;none&quot;);
	}

<span class="boring">}</span></code></pre></pre>
<h3 id="sommary"><a class="header" href="#sommary">Sommary</a></h3>
<ul>
<li>how to create custom enum type. </li>
<li>Option<T> </li>
<li>match &amp; if let </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="managing-growing-projects-with-packages-creates-and-modules"><a class="header" href="#managing-growing-projects-with-packages-creates-and-modules">MANAGING GROWING PROJECTS WITH PACKAGES, CREATES, AND MODULES</a></h1>
<p>What we will covers .. </p>
<p>As a project grows, you can organize code by splitting it into multiple modules and then multiple files. 
a package can contain multiple binary crates and optionally one library crate. 
as package grows, you can extract parts into separate crates that become external dependencies. </p>
<ul>
<li>organizing project. </li>
<li>grouping functionality, encapsulating implementation details lets you reuse code at a higher level. </li>
<li>parts of code are public or private. </li>
</ul>
<h3 id="module-system"><a class="header" href="#module-system">Module system</a></h3>
<ul>
<li>Packages : a cargo feature that lets you build, test, share crates. </li>
<li>Crates : a tree of modules that produces a library or executable. </li>
<li>Modules and use : let you control the organization, scope, and privacy of paths. </li>
<li>Path : a way of naming an item, such as a struct, function, or module. </li>
</ul>
<h3 id="packages-and-crates"><a class="header" href="#packages-and-crates">Packages and crates</a></h3>
<ul>
<li>a crate is a binary of library. (root file is library:lib.rs, binary:main.rs) </li>
<li>rust compiler starts from and makes up the root module of your crate. </li>
<li>one or more crates that provide a set of functionality. </li>
<li>package must contain zero or one library crates and no more. </li>
<li>it can contain as many binary crates as you'd like, but it must contain at least one crate(either lib, bin)</li>
<li>a package can have multiple binary crates by placing files in the src/bin directory : each file will be separate binary crate. </li>
<li>crate's functionality is namespaced in its own scope. ex) rand::Rnd </li>
</ul>
<h3 id="defining-modules-to-control-scope-and-privacy"><a class="header" href="#defining-modules-to-control-scope-and-privacy">Defining Modules to Control Scope and Privacy</a></h3>
<ul>
<li>we will discuss :
<ul>
<li>use keyword.</li>
<li>pub keyword.</li>
<li>as keyword, external packages </li>
<li>the glob operator </li>
</ul>
</li>
</ul>
<p>in the src/lib.rs </p>
<p>we difined a module. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>	
<span class="boring">fn main() {
</span>	mod frond_of_house {
		mod hosting {
			fn add_to_waitlist() {}

			fn seat_at_table() {}
		}

		mod serving {
			fn take_order(){}

			fn serve_order(){}

			fn take_payment(){}
		}
	}


<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>we difined a module start with mod keyword.</p>
</li>
<li>
<p>inside modules, we can have other modules and also hold definitions for other items, such as structs, enums, constant, triat, and function. </p>
</li>
<li>
<p>modules can be useful when you navigate the code you do not need to follow all the code but just follow the groups in this case module. </p>
</li>
<li>
<p>the etire module tree is rooted under the implicit module named crate. </p>
</li>
<li>
<p>lib.rs/main.rs are called crate roots -&gt; it looks like tree structure, filesystem ex) crate root / frond_of_house / hosting / add_to_waitlist. it look like this. </p>
</li>
</ul>
<h4 id="paths-for-referring-to-an-item-in-the-module-tree"><a class="header" href="#paths-for-referring-to-an-item-in-the-module-tree">Paths for Referring to an Item in the Module Tree</a></h4>
<p>A path can take two forms : </p>
<ul>
<li>
<p>An absolute path : starts from a crate root by using a crate name or a literal crate.</p>
</li>
<li>
<p>An relative path : starts from the current module and uses self, super, or an identifier in the current module. </p>
</li>
</ul>
<p>these path forms are followed by one or more identifiers separated by double colons (::). </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>	
<span class="boring">fn main() {
</span>	mod frond_of_house {
		mod hosting {
			fn add_to_waitlist() {}
		}
	}



	pub fn eat_at_restaurant() {
	
	//absolute path 
	crate::front_of_house::hosting::add_to_waitlist();

	//relative path 
	front_of_house::hosting::add_to_waitlist(); 

	}

<span class="boring">}</span></code></pre></pre>
<p>when to use relative path and absolute path?</p>
<ul>
<li>
<p>The decision should depend on whether you're more likely to move item definition code separately from together with the code that uses the item. </p>
<ul>
<li>if we mode the front_of_house module and the eat_at_restaurant function into a module named customer_experience, we'd need to update the absolute path to add_to_waitlist, but the relative path would still be valid. </li>
</ul>
</li>
<li>
<p>modules do -</p>
<ul>
<li>
<p>organizing your code </p>
</li>
<li>
<p>define rust's privacy boundary </p>
<ul>
<li>
<p>private is default in rust. </p>
</li>
<li>
<p>Items in a parent module can not use the private items inside child modules. </p>
</li>
<li>
<p>Items in child module can use the items in their ancestor modules. </p>
<ul>
<li>the reason is that child modules wrap and hide their implementation details, but the child modules can see the context in which they're defined. </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="exposing-paths-with-the-pub-keyword"><a class="header" href="#exposing-paths-with-the-pub-keyword">Exposing Paths with the pub Keyword.</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>	
<span class="boring">fn main() {
</span>	mod frond_of_house {
		pub mod hosting {
			pub fn add_to_waitlist() {}
		}
	}



	pub fn eat_at_restaurant() {
	
	//absolute path 
	crate::front_of_house::hosting::add_to_waitlist();

	//relative path 
	front_of_house::hosting::add_to_waitlist(); 

	}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>adding the pub keyword to mod hosting and fn add_to_waitlist lets us call the function from eat_at_restaurant.</li>
</ul>
<h3 id="starting-relative-paths-with-super"><a class="header" href="#starting-relative-paths-with-super">Starting Relative Paths with super.</a></h3>
<p>src/lib.rs</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn serve_order(){}

mod back_of_house {
	fn fix_incorrect_order() {
		cook_order(); 
		super::serve_order(); // relative path with super. 
	} 

	fn cook_order() {}
}
<span class="boring">}</span></code></pre></pre>
<p>-&gt; we used super so we'll have fewer places to update code in the future if this code gets moved to a different module. </p>
<h3 id="making-structs-and-enums-publics"><a class="header" href="#making-structs-and-enums-publics">Making Structs and Enums Publics</a></h3>
<p>if we make struct public, but the struct's fields will still be private. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	// src/lib.rs 
	mod back_of_house {
		pub struct Breakfast {
			pub toast: String, 
			seasonal_fruit: String, 
		}
		
		impl Breakfast {
			pub fn summer(toast: &amp;str) -&gt; Breakfast {
				Breakfast {
					toast : String::from(toast), 
					seasonal_fruit : String::from(&quot;peaches&quot;),
				}
			}

		}
	}


	pub fn eat_at_restaurant() {
		let mut meal = back_of_house::Breakfast::summer(&quot;Rye&quot;);
		// Change our mind about what bread we'd like 
		meal.toast = String::from(&quot;wheat&quot;);
		// but seasonal_fruit can not be modified. 
	}

<span class="boring">}</span></code></pre></pre>
<p>In contrast, if we make an enum public, all of its variants are then public. </p>
<h3 id="bringing-paths-into-scope-with-the-use-keyword"><a class="header" href="#bringing-paths-into-scope-with-the-use-keyword">Bringing Paths into Scope with the use Keyword</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	//   src/lib.rs 
	
	mod front_of_house {
		pub mod hosting {
			pub fn add_to_waitlist() {}
		}
	}

	use crate::front_of_house::hosting;
	// we can also bring module with relative path. 
	// use front_of_house::hosting;

	pub fn eat_at_restaurant() {
		hosting::add_to_waitlist();
	}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>adding use and a path in a scope is smilar to creating a symbolic link in the filesystem. </li>
</ul>
<h3 id="creating-idiomatic-use-paths"><a class="header" href="#creating-idiomatic-use-paths">Creating Idiomatic use Paths.</a></h3>
<p>you might wonder why we use 'use create::front_of_house::hosting' instead of bring it all the way out to add_to_waitlist.</p>
<ul>
<li>
<p>bring it all the way out to fn is unidiomatic. </p>
</li>
<li>
<p>otherwise we can have benefit. </p>
<ul>
<li>
<p>when calling the function, we can catch the function isn't locally defined. </p>
</li>
<li>
<p>Bringing two types with the same name into the same scope requires using their parent module otherwise we can not ditingush which one is which. </p>
</li>
<li>
<p>on the other hand, when bringing in structs, enums, and other items with use, it's idiomatic to specify the full path. </p>
</li>
<li>
<p>there's no string reason behind this idiom: it's just the convention that has emerged, and folks have gotten used to reading and writing Rust code this way. </p>
</li>
</ul>
</li>
</ul>
<h3 id="providing-new-names-with-the-as-keyword"><a class="header" href="#providing-new-names-with-the-as-keyword">Providing New Names with the as Keyword.</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>	use std::io::Result as IoResult; 
<span class="boring">}</span></code></pre></pre>
<h3 id="re-exporting-names-with-pub-use"><a class="header" href="#re-exporting-names-with-pub-use">Re-exporting Names with pub use.</a></h3>
<p>To enable the code that calls our code to refer to that name as if it had been defined in that code's scope, we can conbine pub and use. </p>
<ul>
<li>
<p>this technique is called 're-exporting' </p>
<ul>
<li>making that item available for others to bring into their scope. </li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>	// src/lib.rs 

	mod front_of_house {
		pub mod hosting {
			pub fn add_to_waitlist(){}
		}
	}
	
	pub use crate::front_of_house::hosting;

<span class="boring">}</span></code></pre></pre>
<p>By using pub use, external code can now call the add_to_waitlist function using hosting::add_to_waitlist. 
if we had not specified pub use, it can be called in the scope but external code could not. </p>
<ul>
<li>Doing so makes our library well organized for programmers working on the library and programmers calling the library. </li>
</ul>
<h3 id="using-external-packages"><a class="header" href="#using-external-packages">Using External Packages.</a></h3>
<p>in the Cargo.toml </p>
<p>[dependencies]
rand = &quot;0.5.5&quot;</p>
<pre><pre class="playground"><code class="language-rust edition2021">use rand::Rng;

fn main() {
	let secret_number = rand::thread_rng().gen_range(1,101);
}
</code></pre></pre>
<p>Note that standard library (std) is also a crate that's external to our package. 
it shiped with rust, so we do not need to include it. </p>
<h3 id="using-nested-paths-to-clean-up-large-use-lists"><a class="header" href="#using-nested-paths-to-clean-up-large-use-lists">Using Nested Paths to Clean Up Large use Lists.</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>// use std::io;
//use std::cmp::Ordering; 

// it can also be used this way. 

use std::{io, cmp::Ordering}; 

// use std::io; 
// use std::io::Write; 

use std::io::{self, Write}; 

<span class="boring">}</span></code></pre></pre>
<h3 id="the-glob-operator"><a class="header" href="#the-glob-operator">The Glob Operator</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>	
<span class="boring">fn main() {
</span>use std::collections::*; 

<span class="boring">}</span></code></pre></pre>
<p>glob can make it harder to tell what names are in scope and where a name used in your program was defined. </p>
<p>The glob operators is often used when testing to bring everything under thest into the tests moduile. </p>
<h3 id="separating-modules-into-different-files"><a class="header" href="#separating-modules-into-different-files">Separating Modules into Different Files.</a></h3>
<p>move the front_of_house module to its own file src/front_of_house.rs </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/lib.rs 

mod front_of_house; 

pub use crate::front_of_house::hosting; 

<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/front_of_house.rs 

pub mod hosting {
	pub fn add_to_waitlist() {}
}

<span class="boring">}</span></code></pre></pre>
<p>Using a semicolon after mod front_of_hose rather than using a block tells Rust to load the contents of the module fron another file with the same name as the module. </p>
<p>same example as follws... </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/front_of_house.rs 
pub mod hosting; 
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// src/front_of_house/hosting.rs 
pub fn add_to_waitlist(){}
	
<span class="boring">}</span></code></pre></pre>
<p>this technique lets you move modules to new files as they grow in size. </p>
<h3 id="summary-2"><a class="header" href="#summary-2">Summary</a></h3>
<ul>
<li>
<p>organize your packages into crates </p>
</li>
<li>
<p>your crates into modules so you xan refer to items defined in one module from another module. </p>
</li>
<li>
<p>using a relative path or absolute path denpend on the situation. </p>
</li>
<li>
<p>bring it into the scope with a use statement. </p>
</li>
<li>
<p>module code is private by default, use pub keyword to public usecases.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="common-collections-ch-8"><a class="header" href="#common-collections-ch-8">COMMON COLLECTIONS, Ch 8</a></h1>
<p>unlike the built-in array and tuple types these collections point to is stored on the heap memory.</p>
<p>which is that the size is not determined at compile time. </p>
<p>it means these collections can shrink and grow as the program rus. </p>
<h4 id="well-cover"><a class="header" href="#well-cover">we'll cover..</a></h4>
<p>create and uipdate vectors, strings, and hashmaps as well as what makes each special. </p>
<ul>
<li>
<p>A vector - allows you to store a variable number of values next to each other. </p>
</li>
<li>
<p>A string - is a collection of characters. </p>
</li>
<li>
<p>A hashmap - allows you to associate a value with a particular key. it's a particular implementation of the more general data structure called a map. </p>
</li>
</ul>
<h3 id="about-vectors"><a class="header" href="#about-vectors">About Vectors.</a></h3>
<ul>
<li>
<p>vector can only store values of the same type. </p>
</li>
<li>
<p>create vector, we can use Vec::new() from std lib or vec![&quot;value&quot;] macro. </p>
<ul>
<li>when we create vector, we need to specify what the type of vector. 
<ul>
<li>but some cases compiler might infer the type if we add value after create. </li>
</ul>
</li>
</ul>
</li>
<li>
<p>get value from vector, two methods are represent..</p>
<ul>
<li>vec.get(index) - return type is Option type -&gt; no compile time error always return Option.</li>
<li>vec[index] - return type is value of that vector. -&gt; compile error occured if it does not have value. </li>
</ul>
</li>
<li>
<p>can not use mutable vector after referencing to other value.</p>
<ul>
<li>because adding a new elements onto the end of the vector might require allocating new memory and copying the old elements to the new space. so this might result in pointing to a deallocated memory. </li>
</ul>
</li>
</ul>
<h3 id="different-types-that-can-store-in-vector"><a class="header" href="#different-types-that-can-store-in-vector">Different types that can store in vector.</a></h3>
<h4 id="vector-can-only-take-value-of-same-type-so-we-can-not-use-struct-type-instead-enum-that-can-be-useful-but-this-type-can-not-be-added-at-runtime-what-should-we-do----trait-object-cover-in-chapter-17"><a class="header" href="#vector-can-only-take-value-of-same-type-so-we-can-not-use-struct-type-instead-enum-that-can-be-useful-but-this-type-can-not-be-added-at-runtime-what-should-we-do----trait-object-cover-in-chapter-17">vector can only take value of same type so we can not use struct type. Instead, enum that can be useful. But this type can not be added at runtime. what should we do?  -&gt; trait object, cover in chapter 17.</a></h4>
<h3 id="about-strings"><a class="header" href="#about-strings">About Strings.</a></h3>
<h4 id="strings-in-rust-are-implemented-as-a-collection-of-bytes-plus-some-methods-to-provide-useful-functionality-when-those-bytes-are-interpreted-as-text"><a class="header" href="#strings-in-rust-are-implemented-as-a-collection-of-bytes-plus-some-methods-to-provide-useful-functionality-when-those-bytes-are-interpreted-as-text">strings in rust are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text.</a></h4>
<p>we'll discuss.. </p>
<ul>
<li>
<p>indexing into a string and why it is difficult, what is differences between how people and computers interpret string data. </p>
</li>
<li>
<p>string slices, which are references to some UTF-8 encoded string data stored elsewhere. </p>
<ul>
<li>string literals, for example, are stored in the program's binary and are therefore string slices. </li>
</ul>
</li>
<li>
<p>String type, which is provided by std lib is a growable, mutable, owned, UTF-8 encoded string type. </p>
<ul>
<li>std lib also include OsString, OsStr, CString, and CStr. </li>
</ul>
</li>
<li>
<p>create String, String::new(); or &quot;value&quot;.to_string() method, this method need to be the type that implemented the Display trait, as string literals do. </p>
<ul>
<li>to_string method is same as String::from(&quot;value&quot;). </li>
</ul>
</li>
</ul>
<h3 id="updating-string"><a class="header" href="#updating-string">updating string.</a></h3>
<ul>
<li>
<p>s.push_str(&quot;value&quot;), took ownership of str value. </p>
</li>
<li>
<p>s.push('c'), adding char. </p>
</li>
<li>
<p>add(self, &amp;str) -&gt; s1 + &amp;s2.  coerce the &amp;string argument into a &amp;str. </p>
<ul>
<li>deref coercion which is &amp;string into &amp;string[..] </li>
</ul>
</li>
<li>
<p>using a format! macro. format!(&quot;{} - {}&quot;, s1, s2);</p>
</li>
</ul>
<h3 id="indexing-into-strings"><a class="header" href="#indexing-into-strings">Indexing into Strings.</a></h3>
<ul>
<li>
<p>A String is a wrapper over a Vec<u8></p>
</li>
<li>
<p>depends on Unicode scalar value in string, each char use different byte size. </p>
</li>
<li>
<p>char() or bytes() </p>
</li>
</ul>
<h3 id="hash-maps"><a class="header" href="#hash-maps">Hash Maps</a></h3>
<p>The type HashMap&lt;K, V&gt;</p>
<ul>
<li>
<p>store their data on the heap. </p>
</li>
<li>
<p>all the keys must have the same type, and all of the values must have the same type. </p>
</li>
<li>
<p>use zip to create hash map. ex) teams = vec![&quot;blue&quot;,&quot;red&quot;], scores = vec![10, 20] -&gt; teams.iter().zip(scores.iter()).collect(); </p>
</li>
<li>
<p>hashmap take ownership. </p>
</li>
<li>
<p>only inserting a value if the key has no value. ex) entry(&quot;blue&quot;).or_insert(50); </p>
</li>
<li>
<p>updating a value based on the old value. ex) entry(&quot;blue&quot;) returns value of key. and if value is not exist, insert value. </p>
</li>
</ul>
<h3 id="hasing-functions"><a class="header" href="#hasing-functions">Hasing Functions</a></h3>
<p>hashmap uses a cryptographically strong hasing function that can provide resistance to Denial of Service (Dos) attacks. This is not the fastest hashing algorithm available, but the trade-off for better security that comes with the drop in performance is worth it. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="error-handling-ch-9"><a class="header" href="#error-handling-ch-9">ERROR HANDLING, Ch 9</a></h1>
<p>we will cover..</p>
<ul>
<li>
<p>recoverable vs unrecoverable </p>
</li>
<li>
<p>panic! macro and return Result&lt;T, E&gt; values. </p>
</li>
<li>
<p>deciding whether to try to recover from an error or to stop execution. </p>
</li>
</ul>
<h3 id="unrecoverable-errors-with-panic"><a class="header" href="#unrecoverable-errors-with-panic">unrecoverable Errors with panic!</a></h3>
<p>when panic! macro executes, your program will print a failure message, unwind and clean up the stack, and the quit. but this process is a lot of work. the alternative is to immediately abort, which ends the program without cleaning up. </p>
<p>at <em>Cargo.toml</em> file. </p>
<div class="table-wrapper"><table><thead><tr><th>[profile.release]</th></tr></thead><tbody>
<tr><td>panic = 'abort'</td></tr>
</tbody></table>
</div>
<ul>
<li>when we try to get the value of the vector that is out of index, std lib vec, calls panic! macro. 
<ul>
<li>like C language, it can access the memory that is not included in vector array it cause a lot of problem.</li>
<li>use RUST_BACKTRACE=1 cargo run to see details of error where is it cause. </li>
</ul>
</li>
</ul>
<h3 id="recoverable-errors-with-result"><a class="header" href="#recoverable-errors-with-result">recoverable Errors with Result.</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
	
	Ok(T),
	Err(E),
	
}

<span class="boring">}</span></code></pre></pre>
<p>in this Result struct, </p>
<ul>
<li>
<p>T represents return type of a success case -&gt; Ok(T).</p>
</li>
<li>
<p>E represents return type of a fail case -&gt; Err(E). </p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>      
<span class="boring">fn main() {
</span>      File::open(&quot;Yeon.txt&quot;); 

      // returns Ok(file) or Err(e) it is implemented in std lib, fs::File, io::ErrorKind.

<span class="boring">}</span></code></pre></pre>
<h3 id="shortcuts-for-panic-on-error--unwrap-and-expect"><a class="header" href="#shortcuts-for-panic-on-error--unwrap-and-expect">shortcuts for Panic on Error : unwrap and expect</a></h3>
<ul>
<li>
<p>unwrap will return the value inside the Ok. if the value inside Result is Err(e) then it will call the panic! macro. </p>
</li>
<li>
<p>using .expect(&quot;messages&quot;) convey your intent and easy to track down the source of a panic. </p>
</li>
</ul>
<h3 id="propagating-the-error"><a class="header" href="#propagating-the-error">propagating the error</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>	
<span class="boring">fn main() {
</span>	fn read_file() -&gt; Result&lt;io::File, io::Error&gt; {
		File::open(&quot;yeon&quot;)
	}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>the function that call read_file() can receive the Result&lt;T, E&gt;. 
<ul>
<li>we can choose what we will do after receving the result type. </li>
</ul>
</li>
</ul>
<h3 id="a-shortcut-for-propagating-errors--the--operator"><a class="header" href="#a-shortcut-for-propagating-errors--the--operator">a shortcut for propagating errors : the ? operator.</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>fn read_username_from_file() -&gt; Result&lt;String, io::Error&gt; {
   
    let mut f = File::open(&quot;hello.txt&quot;)?;
    let mut s = String::new();
    f.read_to_string(&amp;mut s)?;
    Ok(s)

}

   // chaining also works 
   
   File::open(&quot;hello.txt&quot;)?.read_to_string(&amp;mut s)?;

<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>? convert automatically. </p>
</li>
<li>
<p>? operator can only be used in function that return result type. </p>
<ul>
<li>Result&lt;(), Box<dyn Error>&gt; is called a trait object we will talk about this later. </li>
</ul>
</li>
</ul>
<h3 id="to-panic-or-not-to-panic"><a class="header" href="#to-panic-or-not-to-panic">To panic! or Not to panic!</a></h3>
<ul>
<li>
<p>prototype code, and test panic is very useful. </p>
</li>
<li>
<p>cases in which you have more information than the compiler -&gt; you can choose <em>unwarp</em> because you know what the result type is. </p>
</li>
</ul>
<h3 id="guidelines-for-error-handling"><a class="header" href="#guidelines-for-error-handling">Guidelines for error handling</a></h3>
<ul>
<li>
<p>the bad state is not something that's expected to happen occationally. </p>
</li>
<li>
<p>your code after this point needs to rely on not being in this bad state. </p>
</li>
<li>
<p>there's not a good way to encode this information in the types you use. </p>
</li>
</ul>
<h3 id="summary-3"><a class="header" href="#summary-3">Summary</a></h3>
<ul>
<li>
<p>the panic! macro signals that your program is in a state it can not handle and lets you tell the process to stop instead of trying to proceed with invalid or incorrect value. </p>
</li>
<li>
<p>the result enum uses rust's type system to indicate that operations might fail in a way that your code could recover from. </p>
<ul>
<li>it needs to handle potential success or failur. </li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generic-type-traits-and-lifetimes-ch-10"><a class="header" href="#generic-type-traits-and-lifetimes-ch-10">GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10</a></h1>
<p>Generics are abstract stand-:ine your own types, functions, and methods with generics. </p>
<ul>
<li>
<p>how to use generic type in struct and enum definitions. </p>
</li>
<li>
<p>how to use traits to define behavior in a generic way. </p>
<ul>
<li>combine traits with generic types to constrain a generic type to only those types that have a particular behavior. </li>
</ul>
</li>
<li>
<p>lifetimes, a variety of generics that give the compiler imformation about how reference relate to each other. lifetimes allow us to borrow values in many situations while still enabling the compiler to check that the references are valid. </p>
</li>
</ul>
<h3 id="in-function-definitions"><a class="header" href="#in-function-definitions">In Function Definitions</a></h3>
<p>we place the generics in the signature of the function. where we would usually specify the data types of the parameters and return value. </p>
<pre><code class="language-rs">
	// this function is generic over some type T 
	fn function&lt;T&gt;(param : T) -&gt; T {
		//...
	};

	
</code></pre>
<ul>
<li>you can use any type identifier as a type parameter name. But 'T' by convention, parameter names in Rust are short, often just a letter, and Rust's type-naming convention is CamelCase. &quot;type&quot;, T is the default choice of most Rust programmers. </li>
</ul>
<h3 id="in-struct-definitions"><a class="header" href="#in-struct-definitions">In Struct Definitions</a></h3>
<pre><code class="language-rs">struct Point&lt;T&gt; {
	x : T,
	y : T,
}

struct Differ_field&lt;T, U&gt; {
	x : T, 
	y : U,
}
</code></pre>
<h3 id="in-enum-definitions"><a class="header" href="#in-enum-definitions">In Enum Definitions</a></h3>
<pre><code class="language-rs">
enum Option&lt;T&gt; {
	Some(T), 
	None, 
}

enum Result&lt;T, E&gt; {
	Ok(T), 
	Err(E), 
}


</code></pre>
<h3 id="in-method-definitions"><a class="header" href="#in-method-definitions">In Method Definitions</a></h3>
<pre><code class="language-rs">struct Point&lt;T&gt; {
	x : T,
	y : T,
}

impl&lt;T&gt; Point&lt;T&gt; {
	fn x(&amp;self) -&gt; &amp;T {
		&amp;self.x
	}
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

</code></pre>
<ul>
<li>
<p>By declaring T as a generic type after impl, Rust can identify that the type in the angle brakets in point struct is a generic type. </p>
</li>
<li>
<p>we could implement concrete type method for Point struct. </p>
</li>
</ul>
<h3 id="performance-of-code-using-generics"><a class="header" href="#performance-of-code-using-generics">Performance of Code Using Generics</a></h3>
<p>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. </p>
<ul>
<li>we pay no run time cost for using generics. </li>
</ul>
<h3 id="traits-defining-shared-behavior"><a class="header" href="#traits-defining-shared-behavior">Traits: Defining Shared Behavior.</a></h3>
<ul>
<li>
<p>tells the rust compiler about functionality a particular type has and can share with other type. </p>
</li>
<li>
<p>trait bounds is to specify a generic can be any time that has certain behavior. </p>
</li>
<li>
<p>group method signatures. </p>
</li>
<li>
<p>accomplish some purpose. </p>
</li>
</ul>
<pre><code class="language-rs">
trait Summary {
	fn summary(&amp;self) -&gt; String; 
}

</code></pre>
<ul>
<li>
<p>implementing a trait, compiler enforce you to implement all methods trait has. </p>
</li>
<li>
<p>we do not need to curly brakets for implement function, we use semiconlon instead. </p>
</li>
<li>
<p>we use alse curly brakets to implement function. ex) default fucntion.. </p>
</li>
</ul>
<h3 id="implementing-a-trait-on-a-type"><a class="header" href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type.</a></h3>
<pre><code class="language-rs">
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}

</code></pre>
<ul>
<li>
<p>we can implement a trait on a type only if either the trait or the type is local to our crate. </p>
</li>
<li>
<p>this restriction is called, coherence, orphan rule. ( parent type is not present ) </p>
</li>
<li>
<p>two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
</li>
</ul>
<h3 id="default-implementaion"><a class="header" href="#default-implementaion">Default Implementaion.</a></h3>
<pre><code class="language-rs">
pub trait Summary {

   fn summarize_author(&amp;self) -&gt; String; 

   fn summarize(&amp;self) -&gt; String {
     String::from(&quot;(Read more...)&quot;)
	     }
     }

</code></pre>
<ul>
<li>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</li>
</ul>
<pre><code class="language-rs">
impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
      format!(&quot;@{}&quot;, self.username)
    }
}

</code></pre>
<ul>
<li>Note that it isn’t possible to call the default implementation from an overriding implementation of that same method.</li>
</ul>
<h3 id="traits-as-parameters"><a class="header" href="#traits-as-parameters">Traits as Parameters.</a></h3>
<pre><code class="language-rs">
pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}


// trait bound syntax 

pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}

// where clauses 

fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
     where T: Display + Clone,
           U: Clone + Debug
{
   //...
}

</code></pre>
<h3 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that implement Traits.</a></h3>
<pre><code class="language-rs">
fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(&quot;The Pittsburgh Penguins once again are the best
            hockey team in the NHL.&quot;),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(&quot;of course, as you probably already know, people&quot;),
            reply: false,
            retweet: false,
       }
 }
}

</code></pre>
<ul>
<li>
<p>this code would not work. </p>
</li>
<li>
<p>due to restrictions around how the impl Trait syntax is implemented in the compiler. We’ll cover how to write a function with this behavior in “Using Trait Objects That Allow for Values of Different Types”</p>
<ul>
<li>**The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13.</li>
</ul>
</li>
</ul>
<h3 id="using-trait-bounds-to-conditionally-implement-methods"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods.</a></h3>
<pre><code class="language-rs">
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}
 impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
   }
}
 impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
          println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}

</code></pre>
<ul>
<li>blanket implementations. </li>
</ul>
<h4 id="example-of-std"><a class="header" href="#example-of-std">example of std.</a></h4>
<pre><code class="language-rs">
// the ToString trait on any type that implements the Display trait. 

impl&lt;T: Display&gt; ToString for T {
    // --snip--
}

</code></pre>
<ul>
<li>
<p>we can call to_string method defined by the ToString Trait on any type that implements the Display trait. </p>
</li>
<li>
<p>Blanket implementations appear in the documentation for the trait in the “Implementors” section.</p>
</li>
<li>
<p>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication</p>
</li>
<li>
<p>specify to the compiler that we want the generic type to have particular behavior.</p>
</li>
<li>
<p>In dynamically typed languages, we would get an error at runtime if we called a method on a type that the type didn’t implement. But Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run.</p>
</li>
</ul>
<h3 id="validating-references-with-lifetimes"><a class="header" href="#validating-references-with-lifetimes">Validating References with Lifetimes.</a></h3>
<p>Although we won't cover lifetimes in their entirety in this chapter. </p>
<p>we'll discus common ways you might encounter lifetime syntax. </p>
<h3 id="preventing-dangling-references-with-lifetimes"><a class="header" href="#preventing-dangling-references-with-lifetimes">Preventing Dangling References with Lifetimes.</a></h3>
<p>it can prevent memory loss while referencing other data. </p>
<pre><pre class="playground"><code class="language-rust  runable  editable edition2021">{
	let r; 

	//println!(&quot;r : {}&quot;, r); 
	// rust does not allow null values. 
	
	{
		let x= 5; 
		r = &amp;x;
	}
	
	println!(&quot;r : {}&quot;, r);
	// x variable is dropped after the '}' culry braket. 
	// can not compile.
}</code></pre></pre>
<ul>
<li>'{}' scope can borrow check, compiler let you know where it need to be fixed. </li>
</ul>
<h3 id="generic-lifetimes-in-functions"><a class="header" href="#generic-lifetimes-in-functions">Generic Lifetimes in Functions.</a></h3>
<pre><code class="language-rs">	fn function(a : &amp;str, b : &amp;str) -&gt; &amp;str {
		if a.len() &gt; b.len() {
			return a
		}
		b	
	}
</code></pre>
<ul>
<li>
<p>borrow checker can't determine. </p>
</li>
<li>
<p>does not know how the lifetimes of x and y relate to the lifetime of the return value. </p>
</li>
<li>
<p>we'll add generic lifetime parameters that define the relationship between the references. </p>
</li>
</ul>
<pre><code class="language-rs">	fn function&lt;'a&gt;(a : &amp;'a str, b : &amp;'a str) -&gt; &amp;'a str {
		if a.len() &gt; b.len() {
			return a
		}
		b	
	}
</code></pre>
<ul>
<li>
<p>lifetime annotations describe the relationships of the lifetims of multiple references to each other without affecting the lifetimes.  // ?? </p>
</li>
<li>
<p>string slice returned from the function will live at least as long as lifetime 'a.</p>
</li>
<li>
<p>we're not changing the lifetimes of any values passed in or returned. </p>
</li>
<li>
<p>we're specifying that the borrow checker shoud reject any values that don't adhere to these contraints</p>
</li>
<li>
<p>this function doesn't need to know exactly how long x and y will live, only that some scope can be substited for 'a that will satisfy this signature. </p>
</li>
<li>
<p>the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</p>
</li>
<li>
<p>generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. </p>
</li>
</ul>
<pre><code class="language-rs">	fn test&lt;'a&gt;(a : &amp;'a str, b : &amp;'a str) -&gt; &amp;'a str {
		if a.len() &gt; b.len() {
			return a
		}
		b	
	}

	{
		let string1 = String::from(&quot;xyz&quot;);
		let string2;
		{ 
			let string2_test = String::from(&quot;abc&quot;);
		}
		
		test(&amp;string1, &amp;string2);

		// can not compile because value that is referencing to string2 is already dropped.   

	}


</code></pre>
<ul>
<li>
<p>lifetime syntax is connecting the lifetimes of various parameters and return values of functions. </p>
</li>
<li>
<p>Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety. </p>
</li>
</ul>
<h3 id="lifetime-annotaions-in-struct-definitions"><a class="header" href="#lifetime-annotaions-in-struct-definitions">Lifetime Annotaions in Struct Definitions.</a></h3>
<pre><code class="language-rs">
struct ImportantExcerpt&lt;'a&gt; {
	
	part: &amp;'a str, 

}

</code></pre>
<ul>
<li>this annotation means can't outlive the reference it holds in its part field. </li>
</ul>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision.</a></h3>
<ul>
<li>first rule 
<ul>
<li>reference gets its own lifetime parameter.</li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
fn test1(a : &amp;'a str){}

fn test2(a: &amp;'a str, b: &amp;'a str){} 

</code></pre>
<ul>
<li>second rule 
<ul>
<li>if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters. </li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
	fn test1(a : &amp;'a str) -&gt; &amp;'a str {}

</code></pre>
<ul>
<li>third rule 
<ul>
<li>one of them is &amp;self or &amp;mut self, the lifetime of self is assigned to all output lifetime parameters. </li>
</ul>
</li>
</ul>
<h3 id="lifetime-annotaions-in-method-definitions"><a class="header" href="#lifetime-annotaions-in-method-definitions">Lifetime Annotaions in Method Definitions</a></h3>
<ul>
<li>
<p>third rule applies. </p>
</li>
<li>
<p>Lifetime names for struct fields always need to be declared after the impl keyword and then used after the struct's name. its lifetimes are part of the struct's type. </p>
</li>
</ul>
<pre><code class="language-rs">
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
   fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
      println!(&quot;Attention please: {}&quot;, announcement);
      self.part
   }
}

</code></pre>
<ul>
<li>Rust applies the first lifetime elision rule and gives both &amp;self and announcement their own lifetimes. one of the parameters is &amp;self, the return type gets the lifetime of &amp;self. </li>
</ul>
<h3 id="the-static-lifetime"><a class="header" href="#the-static-lifetime">The Static Lifetime</a></h3>
<pre><code class="language-rs">
let s : &amp;'static str = &quot;I have a static lifetime.&quot;; 

</code></pre>
<ul>
<li>the text of this string is strored directly in the binary of your program. </li>
</ul>
<h3 id="generic-type-parameters-trait-bounds-and-lifetimes-together"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together">Generic Type Parameters, Trait Bounds, And LifeTimes Together.</a></h3>
<pre><code class="language-rs">
use std::fmt::Display;
fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a
str
   where T: Display
{
   println!(&quot;Announcement! {}&quot;, ann);
   if x.len() &gt; y.len() {
       x
   } else {
       y
   }
}

</code></pre>
<h3 id="summary-4"><a class="header" href="#summary-4">Summary</a></h3>
<ul>
<li>
<p>Trait and trait bounds ensure that even though the types are generic, they will have the behavior the code needs. </p>
</li>
<li>
<p>lifetime annotations to ensure that this flexible code won't have any dangling references at compile time. </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-language-featrues--iterators-and-closures-ch-13"><a class="header" href="#functional-language-featrues--iterators-and-closures-ch-13">FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13</a></h1>
<p>functional programming : functions as values by passing them in arguments, returning them from other functions, assigning them to variables for later execution, and so forth. </p>
<p>we' ll cover:</p>
<ul>
<li>
<p>Closures, a function like construct you can store in a variable. </p>
</li>
<li>
<p>Iterators, a way of processing a series of elements</p>
</li>
</ul>
<p>pattern matching and enums are influenced by the functional style. Mastering closures and iterators is a key to learn Rust. </p>
<h3 id="closures--anonymouse-functions-that-can-chapture-their-environment"><a class="header" href="#closures--anonymouse-functions-that-can-chapture-their-environment">Closures : Anonymouse functions that can chapture their environment</a></h3>
<ul>
<li>
<p>rust's closures are value that can contain function. </p>
</li>
<li>
<p>it can be passed as arguments to other functions. </p>
</li>
</ul>
<h3 id="closure-type-inference-and-annotation"><a class="header" href="#closure-type-inference-and-annotation">Closure type inference and annotation</a></h3>
<ul>
<li>
<p>function's type annotations are required on functions because they're part of an explicit interface exposed to your users.</p>
</li>
<li>
<p>closure definitions will have one concrete type inferred for each of their parameters and for their return value. </p>
<ul>
<li>types are locked into the closure. </li>
</ul>
</li>
</ul>
<h3 id="storing-closures-using-generic-parameters-and-the-fn-traits"><a class="header" href="#storing-closures-using-generic-parameters-and-the-fn-traits">Storing closures using generic parameters and the fn traits.</a></h3>
<ul>
<li>memoization or lazy evaluation. 
<ul>
<li>
<p>create struct that will hold the closure and the resulting value of calling the closure. the struct will execute the closure only if we need the resulting value, and it will cache the resulting value so the rest of our code doesn't have to be responsible for saving and reusing the result. </p>
</li>
<li>
<p>Memoization refers to the technique of caching the results of a function call so that subsequent calls with the same arguments can be returned quickly from the cache instead of recomputing the result. This can be useful in cases where a function is computationally expensive or has side effects that can be avoided with caching. Memoization can be implemented using a HashMap or a similar data structure in Rust.</p>
</li>
</ul>
</li>
</ul>
<p>Lazy evaluation, on the other hand, refers to the evaluation of an expression only when its value is actually needed, rather than eagerly evaluating it before it is needed. This can be useful for optimizing performance and reducing memory usage in cases where not all values need to be computed or stored at once. In Rust, lazy evaluation can be implemented using closures, iterators, and the lazy_static crate.</p>
<p>Both memoization and lazy evaluation can be powerful techniques for optimizing Rust code, but they are best used judiciously and in cases where they provide a clear benefit.</p>
<pre><code class="language-rs">
struct Cacher&lt;T&gt; 
   where T: Fn(u32) -&gt; u32 {
   	calculation : T, 
   	value : Option&lt;u32&gt;, 
   }


</code></pre>
<ul>
<li>
<p>Note </p>
<p><em>functions can implement all three of the Fn traits, too. If what we want to do doesn not require capturing a value from the environment, we can use a function rather than a clousre where we need something that implements an Fn trait</em></p>
</li>
</ul>
<pre><code class="language-rs">impl&lt;T&gt; Cacher&lt;T&gt;
  ➊ where T: Fn(u32) -&gt; u32
{
  ➋ fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
      ➌ Cacher {
             calculation,
             value: None,
         }
     }
 ➍ fn value(&amp;mut self, arg: u32) -&gt; u32 {
         match self.value {
         ➎ Some(v) =&gt; v,
         ➏ None =&gt; {
                let v = (self.calculation)(arg);
                self.value = Some(v);
                v
           },
         }
  }
}


</code></pre>
<pre><code class="language-rs">

fn generate_workout(intensity: u32, random_number: u32) {
  ➊ let mut expensive_result = Cacher::new(|num| {
         println!(&quot;calculating slowly...&quot;);
         thread::sleep(Duration::from_secs(2));
         num
     });


    if intensity &lt; 25 {
         println!(
             &quot;Today, do {} pushups!&quot;,
          ➋ expensive_result.value(intensity)
         );
         println!(
             &quot;Next, do {} situps!&quot;,
          ➌ expensive_result.value(intensity)
         );
     } else {
         if random_number == 3 {
             println!(&quot;Take a break today! Remember to stay hydrated!&quot;);
         } else {
             println!(
                 &quot;Today, run for {} minutes!&quot;,
              ➍ expensive_result.value(intensity)
             );
	 }
    }
}


</code></pre>
<h3 id="limitations-of-the-cacher-implementation"><a class="header" href="#limitations-of-the-cacher-implementation">Limitations of the cacher implementation</a></h3>
<ul>
<li>
<p>problem is that the first time we called c.value with 1, the Cacher instance saved Some(1) in self.value. Thereafter, no matter what we pass in to the value method, it will always return 1.</p>
</li>
<li>
<p>to fix this problem using a hash map -&gt; the key will the are <strong>arg</strong> values that are passed in, and the value of key will be the result of caluation. </p>
</li>
</ul>
<h3 id="capturing-the-environment-with-closures"><a class="header" href="#capturing-the-environment-with-closures">Capturing the environment with closures</a></h3>
<pre><code class="language-rs">
fn main() {

	let x = 4; 

	let equal_to_x = |z| z == x; 

	let y = 4; 

	assert!(equal_to_x(y));

}


</code></pre>
<ul>
<li>
<p>when a closure captures a value from its environment, it uses memory to store the values for use in the closure body</p>
</li>
<li>
<p>but this case is overhead so we do not want to pay in more common cases where we want to execute code such as funtions. </p>
</li>
</ul>
<h4 id="three-ways-of-capturing"><a class="header" href="#three-ways-of-capturing">three ways of capturing</a></h4>
<ul>
<li>
<p>taking ownership, borrowing mutably, and borrowing immutably. </p>
<ul>
<li>
<p><strong>FnOnce</strong> : taking ownership of a variable, it can be called only once. </p>
</li>
<li>
<p><strong>FnMut</strong> : mutably borrows values, can change the environment. </p>
</li>
<li>
<p><strong>Fn</strong> : borrows values from the environment immutably. </p>
</li>
</ul>
</li>
<li>
<p>rust infers which trait to use based on how the closure uses the values from the environment. </p>
</li>
<li>
<p>take ownership of the values, move keyword force to take the value of ownership. </p>
<ul>
<li>this technique is mostyly useful when passing a closure to a new thread to move the data so it's owned by the new thread </li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
fn main() {
 
	 let x = vec![1, 2, 3];
	 
	 let equal_to_x = move |z| z == x;
	 
	 // this print macro does not work because x has been moved. 
	 println!(&quot;can't use x here: {:?}&quot;, x);

	 let y = vec![1, 2, 3];
	 
	 assert!(equal_to_x(y));
}

</code></pre>
<h3 id="processing-a-series-of-items-with-iterators"><a class="header" href="#processing-a-series-of-items-with-iterators">Processing a Series of Items with Iterators</a></h3>
<p>An iterators is responsible for the logic of iterating over each item an determining when the sequence has finished. </p>
<p>In Rust, iterators are <strong>lazy</strong>, they have no effect until you call methods that consume the iterator to use it up. </p>
<pre><code class="language-rs">
let v1 = vec![1,2,3];

// creating iterator using iter() method that implemented on Vec&lt;T&gt;
let v1_iter = v1.iter();

</code></pre>
<h3 id="the-iterator-trait-and-the-next-method"><a class="header" href="#the-iterator-trait-and-the-next-method">The Iterator Trait and the next Method</a></h3>
<pre><code class="language-rs">
pub trait Iterator {
	type Item;
	
	fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
		//elided
	}

}

</code></pre>
<ul>
<li>
<p>type Item and Self::Item, defining an associated type with this trait. </p>
</li>
<li>
<p>talk about associated types in depth in chapter 19.</p>
</li>
<li>
<p>Implementing the Iterator trait requires that you also define an Item type, and this Item type is used in the return type of the next mehtod. </p>
</li>
<li>
<p>the <strong>Iterator</strong> trait only requires implementors to define one method: the <strong>next</strong> method, which returns one item of the iterator. </p>
</li>
<li>
<p>calling the <strong>next</strong> method on an iterator chages internal state so it needs to be mutable. </p>
</li>
<li>
<p>iterators uses to keep track of where it is in the sequence. </p>
</li>
<li>
<p>this called consumes or uses up the iterator. </p>
</li>
<li>
<p>each call to <strong>next</strong> eats up an item from the iterator. </p>
</li>
<li>
<p>iter_mut() - take mutable reference, into_iter() - take ownership, iter() - reference.</p>
</li>
</ul>
<h3 id="methods-that-consume-the-iterator"><a class="header" href="#methods-that-consume-the-iterator">Methods That Consume the Iterator.</a></h3>
<ul>
<li>
<p>Methods that call <strong>next</strong> are refered to as <strong>consuming adaptors</strong>.</p>
</li>
<li>
<p>also <strong>sum method</strong>. </p>
</li>
</ul>
<h3 id="methods-that-produce-otehr-iterators"><a class="header" href="#methods-that-produce-otehr-iterators">Methods That Produce Otehr Iterators.</a></h3>
<ul>
<li>
<p>change iteraotrs into different kinds of iterators, <strong>iterator adaptors</strong> </p>
</li>
<li>
<p>iterators are lazy, you need to call one of the consuming adaptor methods to get iterator adaptors.</p>
</li>
</ul>
<pre><code class="language-rs">
let v1 = vec![1,2,3];

v1.iter().map(|x| x + 1);

</code></pre>
<ul>
<li>
<p>warning - unused <code>std::iter::Map</code> which must be used: iterator adaptors are lazy and do nothing unless consumed.</p>
</li>
<li>
<p>to fix this issue, we need to call <strong>collect()</strong> method. </p>
<ul>
<li>consume the new iterator and create a vector. </li>
</ul>
</li>
</ul>
<h3 id="using-closures-that-capture-their-environment"><a class="header" href="#using-closures-that-capture-their-environment">Using Closures That Capture Their Environment.</a></h3>
<pre><code class="language-rs">#[derive(PartialEq, Debug)]
   struct Shoe {
       size: u32,
       style: String,
   }
 ➊ fn shoes_in_my_size(shoes: Vec&lt;Shoe&gt;, shoe_size: u32) -&gt; Vec&lt;Shoe&gt; {
    ➋ shoes.into_iter()
        ➌ .filter(|s| s.size == shoe_size
        ➍ .collect()
   }
    #[test]
   fn filters_by_size() {
       let shoes = vec![
           Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
           Shoe { size: 13, style: String::from(&quot;sandal&quot;) },
           Shoe { size: 10, style: String::from(&quot;boot&quot;) },
       ];
    let in_my_size = shoes_in_my_size(shoes, 10);
       assert_eq!(
           in_my_size,
           vec![
               Shoe { size: 10, style: String::from(&quot;sneaker&quot;) },
               Shoe { size: 10, style: String::from(&quot;boot&quot;) },
           ]
      );
   }


</code></pre>
<ul>
<li><strong>filter()</strong> method example.</li>
</ul>
<h3 id="creating-our-own-iterators-with-the-iterator-trait"><a class="header" href="#creating-our-own-iterators-with-the-iterator-trait">Creating Our Own Iterators with the Iterator Trait.</a></h3>
<pre><code class="language-rs">
struct Counter {
    count: u32,
}


impl Counter {
    fn new() -&gt; Counter {
        Counter { count: 0 }
    }
}


impl Iterator for Counter {
    	
	type Item = u32;

	fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
	        if self.count &lt; 5 {
	            self.count += 1;
	            Some(self.count)
	        } else {
	            None
	        }
	    }
}


</code></pre>
<h3 id="using-otehr-iterator-triat-methods"><a class="header" href="#using-otehr-iterator-triat-methods">Using Otehr Iterator Triat Methods</a></h3>
<pre><code class="language-rs">
	fn using_other_iterator_trait_methods() {

		let sum: u32 = Counter::new().zip(Counter::new().skip(1))
                                 .map(|(a, b)| a * b)
                                 .filter(|x| x % 3 == 0)
                                 .sum();
    
    		assert_eq!(18, sum);
	}

</code></pre>
<h3 id="comparing-performance--looks-vs-iterators"><a class="header" href="#comparing-performance--looks-vs-iterators">Comparing Performance : Looks vs. Iterators</a></h3>
<p>Iterators are one of Rust's zero-cose abstractions, no additional runtime overhead. </p>
<h3 id="summary-5"><a class="header" href="#summary-5">Summary</a></h3>
<ul>
<li>Closures and iterators contribute to Rust's capability to clearly express high-level ideas at low-level perfromance. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="more-about-cargo-and-createsio-ch-14"><a class="header" href="#more-about-cargo-and-createsio-ch-14">MORE ABOUT CARGO AND CREATES.IO, ch 14</a></h1>
<p>we will discuss ..</p>
<ul>
<li>
<p>customize your build through release profiles.</p>
</li>
<li>
<p>publish libraries on <a href="https://crates/io/"><em>https://crates.io/</em></a>.</p>
</li>
<li>
<p>Organize large projects with workspaces. </p>
</li>
<li>
<p>Install binaries from <a href="https://crates/io/"><em>https://crates.io/</em></a>.</p>
</li>
<li>
<p>Extend Cargo using custom commands. </p>
</li>
<li>
<p>full explanation of all its features. <a href="https://doc.rust-lang.org/cargo/"><em>https://doc.rust-lang.org/cargo/</em></a>.</p>
</li>
</ul>
<h3 id="customizing-builds-with-release-profiles"><a class="header" href="#customizing-builds-with-release-profiles">Customizing Builds with Release Profiles.</a></h3>
<pre><code class="language-sh">
Cargo.toml

[profile.dev]
opt-level = 0

[profile.release]
opt-level = 3

</code></pre>
<ul>
<li>
<p><strong>cargo build</strong> command is useally for development.</p>
</li>
<li>
<p><strong>cargo build --release</strong> is for the release. </p>
</li>
<li>
<p>we can controll <em>opt-level</em> setting. ( 0 to 3 ).</p>
<ul>
<li>default <em>opt-level is zero</em>, faster compiling than upper number. </li>
</ul>
</li>
</ul>
<h3 id="publishing-a-crate-to-cratesio"><a class="header" href="#publishing-a-crate-to-cratesio">Publishing a Crate to Crates.io</a></h3>
<ol>
<li>
<p>Making Useful Documentation Comments. </p>
<ul>
<li><em>documentaion comment</em> - generate <strong>HTML</strong> documentation. </li>
<li>example of documenting the source code. </li>
<li>documenting use three slashes. </li>
<li>description of what the <strong>add_one</strong> function does. </li>
<li>start a section with the heading <strong>Examples</strong></li>
<li>demonstrates how to use the <strong>add_one</strong> function. </li>
<li>we can generate by running <strong>cargo doc</strong> &gt; <em>target/doc</em> directory</li>
<li>more convenience, running <strong>cargo doc --open</strong> </li>
</ul>
</li>
</ol>
<pre><code class="language-rs">
/// Adds one to the number given.
///
/// # Examples
///
/// ```
/// let arg = 5;
/// let answer = my_crate::add_one(arg);
///
/// assert_eq!(6, answer);
/// ```

pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

</code></pre>
<img src="rust_book/./img/13ch_document.png" alt="doc" width="600">
<h3 id="commonly-used-sections"><a class="header" href="#commonly-used-sections">Commonly Used Sections</a></h3>
<p><strong>Panics</strong> , <strong>Errors</strong>, <strong>Safety</strong> </p>
<h3 id="documentation-comments-as-tests"><a class="header" href="#documentation-comments-as-tests">Documentation Comments as Tests</a></h3>
<ul>
<li>adding example code blocks to your documentation comments can help demonstrate how to use your library, and doing so has an additional bonus: running <strong>cargo test</strong> will run the code examples in your documentation as tests. </li>
</ul>
<h3 id="commenting-contained-items"><a class="header" href="#commenting-contained-items">Commenting Contained Items</a></h3>
<ul>
<li>Another style of doc comment, //!, adds documentation to the item that contains the comments rather than adding documentation to the items following the comments. We typically use these doc comments inside the crate root file (src/lib.rs by convention) or inside a module to document the crate or the module as a whole.</li>
</ul>
<pre><code class="language-rs">//! # My Crate
//!
//! `my_crate` is a collection of utilities to make performing certain
//! calculations more convenient.
 /// Adds one to the number given.
// --snip--

</code></pre>
<img src='./img/commenting_doc.png' width='700'>
<h3 id="exporting-a-convenient-public-api-with-pub-use"><a class="header" href="#exporting-a-convenient-public-api-with-pub-use">Exporting a Convenient Public API with pub use</a></h3>
<ul>
<li>
<p>you might want to organize your structs in a hierarchy containing multiple levels. </p>
<ul>
<li>people could have trouble finding out. </li>
</ul>
</li>
<li>
<p>the structure of your public <strong>API</strong> is a major consideration when publishing a crate. </p>
</li>
<li>
<p>structure <em>isn't</em> convenient for others to use from another library, you don't have to rearrange your internal organization: instead, you can re-export items to make a public structure that's different from your private structure by using <strong>pub</strong> use.</p>
</li>
</ul>
<pre><code class="language-rs">
//! # Art
//!
//! A library for modeling artistic concepts.
 pub mod kinds {
    
    /// The primary colors according to the RYB color model.
    pub enum PrimaryColor {
        Red,
        Yellow,
        Blue,
    }

    /// The secondary colors according to the RYB color model.
    pub enum SecondaryColor {
        Orange,
        Green,
        Purple,
    }
}


pub mod utils {
    use crate::kinds::*;
    /// Combines two primary colors in equal amounts to create
    /// a secondary color.
    pub fn mix(c1: PrimaryColor, c2: PrimaryColor) -&gt; SecondaryColor {
        // --snip--
    }
}



</code></pre>
<img src='./img/art_module.png' width='700'>
<ul>
<li>
<p>Note that the <strong>PrimaryColor</strong> and <strong>SecondaryColor</strong> types aren't listed on the front page, nor is the <strong>mix</strong> function. </p>
</li>
<li>
<p>we have to click <em>kinds</em> and <em>utils</em> to see them. </p>
</li>
</ul>
<pre><code class="language-rs">
use art::kinds::PrimaryColor;
use art::utils::mix;
 fn main() {
    let red = PrimaryColor::Red;
    let yellow = PrimaryColor::Yellow;
    mix(red, yellow);
}


</code></pre>
<ul>
<li>
<p>we need to <em>use</em> statements that bring the items from <strong>art</strong> into scope. </p>
</li>
<li>
<p>this structure is more relevant to developers working on the <strong>art</strong> crate than to developers using the <strong>art</strong> crate. </p>
</li>
<li>
<p>developers have to figure out where to look, and the structure is inconvenient because developers must specify the module names in the <strong>use</strong> statements. </p>
</li>
<li>
<p>To remove the internal organization from the public <strong>API</strong>, we can modify the <strong>art</strong> crate code to add <strong>pub use</strong> statements to re-export the items at the top level. </p>
</li>
</ul>
<pre><code class="language-rs">
//! # Art
//!
//! A library for modeling artistic concepts.

pub use self::kinds::PrimaryColor;
pub use self::kinds::SecondaryColor;
pub use self::utils::mix;

pub mod kinds {
    // --snip--
}

pub mod utils {
    // --snip--
}


</code></pre>
<img src='./img/re-exporting.png' width=700>
<ul>
<li>now the <strong>art</strong> crate users can still see and use the internal structrue. </li>
</ul>
<h3 id="setting-up-a-cratesio-account"><a class="header" href="#setting-up-a-cratesio-account">Setting Up a Crates.io Account</a></h3>
<ul>
<li>before you publish any crates, you need to crate an account on <a href="https://crates.io"><em>https://crates.io</em></a> and get an <strong>API</strong> token. </li>
</ul>
<pre><code class="language-sh">
cargo login abcdefgadsf123 // api key from crates.io 

</code></pre>
<ul>
<li>this command will inform Cargo of your API token and stroe it locally in ~/.cargo/credentials. </li>
</ul>
<h3 id="adding-metadata-to-a-new-crate"><a class="header" href="#adding-metadata-to-a-new-crate">Adding Metadata to a New Crate</a></h3>
<ul>
<li>
<p>adding it to the [package] section of the crate's <em>Cargo.toml</em> file. </p>
</li>
<li>
<p>your crate will need a unique name. (you need to search it before publish)</p>
<ul>
<li>once a crate name is taken, no one else can pblish a crate with that name. </li>
</ul>
</li>
<li>
<p>license <a href="http://spdx.org/licenses"><em>http://spdx.org/licenses/</em></a>, you need to check and adding it. </p>
<ul>
<li>also you can adding a license file. </li>
</ul>
</li>
</ul>
<pre><code class="language-sh">
Cargo.toml

[package]

name = &quot;guessing_game&quot;

version = &quot;0.1.0&quot;

authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]

description = &quot;A fun game where you guess what number the computer has
chosen.&quot;

license = &quot;MIT OR Apache-2.0&quot;

edition = &quot;2018&quot;
 
[dependencies]

</code></pre>
<h3 id="publishing-to-cratesio"><a class="header" href="#publishing-to-cratesio">Publishing to Crates.io</a></h3>
<ul>
<li>
<p>publish is permanent. </p>
</li>
<li>
<p>cargo publish command will upload your crates. </p>
</li>
</ul>
<h3 id="publishing-a-new-version-of-an-existing-crate"><a class="header" href="#publishing-a-new-version-of-an-existing-crate">Publishing a New Version of an Existing Crate</a></h3>
<ul>
<li>
<p>when you have been made changes to your crate and are ready to release a new version, you change the <strong>version</strong> value specified in your <em>Cargo.toml</em> file and republish. </p>
</li>
<li>
<p>Use the Semantic Versioning rules at <a href="http://semver.org/"><em>http://semver.org/</em></a>.</p>
</li>
</ul>
<h3 id="removing-versions-from-cratesio-with-cargo-yank"><a class="header" href="#removing-versions-from-cratesio-with-cargo-yank">Removing Versions from Crates.io with cargo yank</a></h3>
<ul>
<li>
<p>you can not remove previous versions of a crate, you can prevent any future projects from adding them s a new dependency. </p>
</li>
<li>
<p>In such situations, Cargo supports <em>yanking</em> a crate version. </p>
</li>
</ul>
<pre><code class="language-sh">
cargo yank --vers 1.0.1 

cargo yank --vers 1.0.1 --undo 

</code></pre>
<h3 id="cargo-workspaces"><a class="header" href="#cargo-workspaces">Cargo Workspaces</a></h3>
<ul>
<li>Cargo offers a feature called <em>workspaces</em> that can help manage multiple related packages that are developed in tandem. </li>
</ul>
<h3 id="creating-a-workspace"><a class="header" href="#creating-a-workspace">Creating a Workspace</a></h3>
<ul>
<li>we will have a workspace containing a binary and two libraries </li>
</ul>
<pre><code class="language-sh">
mkdir add 

cd add

vi Cargo.toml 

//in Cargo.toml

[workspace]

members = [

	&quot;adder&quot;,
]

</code></pre>
<pre><code class="language-sh">
$ cargo new adder

// then cargo build, inside or outside of adder. 

</code></pre>
<img src='./img/cargo_workspace.png' width=700>
<ul>
<li>
<p>the workspace has one <em>target</em> directory at the top level for the compiled artifacts. </p>
</li>
<li>
<p><strong>adder</strong> crate does not have its own <em>target</em> directory, Even if we were to run <strong>cargo build</strong> from insdie the <em>adder</em> directory. it would endup <em>add/target</em>.</p>
<ul>
<li>
<p>the crates in a workspace are meant to depend on each other. </p>
</li>
<li>
<p>if each crate had its own <em>target</em> directory, each crate would have to recompile each of the other crates in the workspace to have the artifacts in its own <em>target</em> directory. </p>
</li>
<li>
<p>by sharing one <em>target</em> directory the crates can avoid unnecessary rebuilding. </p>
</li>
</ul>
</li>
</ul>
<h3 id="creating-the-second-crate-in-the-workspace"><a class="header" href="#creating-the-second-crate-in-the-workspace">Creating the Second Crate in the Workspace</a></h3>
<ul>
<li>add top-level Cargo.toml on the <strong>members</strong> list - &quot;add-one&quot;</li>
</ul>
<pre><code class="language-rs">members = [

	&quot;adder&quot;,
	&quot;add-one&quot;,
]

</code></pre>
<pre><code class="language-sh">
$ cargo new add-one --lib 

</code></pre>
<img src='./img/add-one-lib.png' width=700> 
<ul>
<li>
<p>in the add-one/src/lib.rs </p>
</li>
<li>
<p>add add_one function that gets one parameter then add 1. </p>
</li>
</ul>
<pre><code class="language-sh">
// in the adder/Cargo.toml 

[dependencies]

add-one = { path = &quot;../add-one&quot;}

</code></pre>
<pre><code class="language-rs">
//adder/src/main.rs

use add_one;

fn main() {

	let num = 10;

	println!(&quot;Hello, world! {} plus one is {}!&quot;, num, add_one::add_one(num));

}


</code></pre>
<ul>
<li><strong>cargo build</strong> in the top-level <em>add</em> directory </li>
</ul>
<pre><code class="language-sh">
// -p ( package adder )
$ cargo run -p adder 

</code></pre>
<h3 id="depending-on-an-external-crate-in-a-workspace"><a class="header" href="#depending-on-an-external-crate-in-a-workspace">Depending on an External Crate in a Workspace</a></h3>
<ul>
<li>
<p>Notice that the workspace has only one <em>Cargo.lock</em> file at the top level of the workspace rather than having a <em>Cargo.lock</em> in each crate's directory. </p>
<ul>
<li>this ensures that all crates are using the same version of all dependencies. </li>
</ul>
</li>
<li>
<p>if we add <strong>rand</strong> crate to the <em>adder/Cargo.toml</em> and <em>add-one/Cargo.toml</em> files, Cargo will resolve both of those to one version of <strong>rand</strong> and record that in the one <em>Cargo.lock</em>.</p>
</li>
<li>
<p>we can not use it in other crates in the workspace unless we add <strong>rand</strong> to their <em>Cargo.toml</em> files.</p>
<ul>
<li>we do not need download it again. </li>
</ul>
</li>
</ul>
<h3 id="adding-a-test-to-a-workspace"><a class="header" href="#adding-a-test-to-a-workspace">Adding a Test to a Workspace</a></h3>
<pre><code class="language-rs">
//add-one/src/lib.rs
pub fn add_one(x: i32) -&gt; i32 {
    x + 1
}

#[cfg(test)]
mod tests {
    use super::*;
 
 #[test]
    fn it_works() {
        assert_eq!(3, add_one(2));

	}
}

</code></pre>
<ul>
<li>
<p><strong>cargo test</strong> in the top-level <em>add</em> directory.</p>
</li>
<li>
<p>we can test by using the <strong>-p</strong> flag for the crate that we want to test. </p>
</li>
</ul>
<h3 id="publish-tip"><a class="header" href="#publish-tip">publish tip</a></h3>
<ul>
<li>
<p>you can not publish **cargo publish --all.</p>
</li>
<li>
<p>you should publish on each directory of Cargo. </p>
</li>
</ul>
<h3 id="installing-binaries-from-cratesio-with-cargo-install"><a class="header" href="#installing-binaries-from-cratesio-with-cargo-install">Installing Binaries from Crates.io with cargo install</a></h3>
<ul>
<li>
<p>the ** cargo install ** command allows you to install and you binary crates locally. </p>
</li>
<li>
<p>note that you can only install packages that have binary targets. </p>
</li>
<li>
<p>A <em>binary target</em> is the runnable program otherwise library is not. </p>
</li>
<li>
<p><em>README</em> file has infomation about a crate. </p>
</li>
<li>
<p>installed binaries stored in the installation root's <em>bin</em> folder. </p>
</li>
<li>
<p>if you installed Rust using <strong>rustup</strong> and do not have any custom configurations, this directory will be <em>$HOME/.cargo/bin</em>. </p>
<ul>
<li>ensure that directory is in your <strong>$PATH</strong> to be able to run programs you have installed with <strong>cargo install</strong>.</li>
</ul>
</li>
</ul>
<p>example) </p>
<pre><code class="language-sh">
$ cargo install ripgrep 

Updating registry `https://github.com/rust-lang/crates.io-index`
 Downloading ripgrep v0.3.2
 --snip--
   Compiling ripgrep v0.3.2
    Finished release [optimized + debuginfo] target(s) in 97.91 secs
Installing ~/.cargo/bin/rg

</code></pre>
<p>you can use <strong>rg --help</strong></p>
<h3 id="summary-6"><a class="header" href="#summary-6">Summary</a></h3>
<ul>
<li>
<p>customizing builds with profile. </p>
</li>
<li>
<p>publishing a crate to crates.io. </p>
<ul>
<li>documentation comment - /// </li>
<li>generate by running <strong>cargo doc</strong> </li>
<li>more convenience, running <strong>cargo doc --open</strong> </li>
<li>commenting contained items //! </li>
</ul>
</li>
<li>
<p>exporting a public API with pub use. </p>
</li>
<li>
<p>setting up a crates.io account. </p>
</li>
<li>
<p>adding metadata in cargo.toml. </p>
</li>
<li>
<p>publishing a new version of an existing crate. </p>
</li>
<li>
<p>removing versions from crates.io with cargo yank. </p>
</li>
<li>
<p>creating a workspace. </p>
<ul>
<li>creating the second crate in the workspace. 
<ul>
<li>members = [&quot;a&quot;, &quot;b&quot;, ..] in carglo.toml </li>
</ul>
</li>
</ul>
</li>
<li>
<p>adding a test to a workspace. ex) using -p flag</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers-ch-15"><a class="header" href="#smart-pointers-ch-15">SMART POINTERS, ch 15</a></h1>
<p>a pointer is a general concept for a variable that contains an address in memory. 
this pointer is point at some other data. </p>
<p><em>Smart Pointers</em> are data structrue not only act like pointer but also have additional metadata and capabilities. </p>
<p><em>reference counting</em> smart pointer type. 
* having a multiple owners of data by keeping track of the number of owners and, when no owners remain, cleaning up the data. </p>
<h4 id="difference"><a class="header" href="#difference">difference</a></h4>
<ul>
<li>references are pointers that only borrow data, in contrast smart pointers own the data they point to. </li>
</ul>
<p>ex) String, Vec<T> 
* String ensuring its data will always be valid UTF-8 </p>
<ul>
<li>Smart pointers are usually implemented using structs. 
<ul>
<li>
<p>smart pointers implement the Deref and Drop traits. </p>
<ul>
<li>dref trait is let smart pointer act like a reference. </li>
<li>drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>We'll cover the most common smart pointets in the standard library: </p>
<ul>
<li>
<p>Box<T> for allocating values on the heap </p>
</li>
<li>
<p>Rc<T>, a reference counting type that enables multiple ownership</p>
</li>
<li>
<p>Ref<T>, and RefMut<T>, accessed through RefCell<T>, a type that enforces the borrowing rules at runtime instead of compile time. </p>
</li>
<li>
<p>In addition, we'll cover the interior mutaiblity pattern where an immutable type exposes an API for mutating an interior value. </p>
</li>
<li>
<p>reference cycles : how they can leak memory and how to prevent them. </p>
</li>
</ul>
<h3 id="using-box-to-point-to-data-on-the-heap"><a class="header" href="#using-box-to-point-to-data-on-the-heap">Using Box<T> to Point to Data on the Heap</a></h3>
<ul>
<li>
<p>storing data on the heap rather than the stack. </p>
</li>
<li>
<p>Boxes don't have performance overhead</p>
</li>
<li>
<p>use case of Box<T></p>
<ul>
<li>
<p>when you have a type whose size can't be known at compile time and you want to use a value of that type in a context that requires an exact size</p>
<ul>
<li>Enabling Recursive Types with Boxes </li>
</ul>
</li>
<li>
<p>when you have a large amount of data and you want to transfer ownership but ensure the data won't be copied when you do so </p>
<ul>
<li>transferring ownership of large amount of data can take a long time because the data is copied around on the stack. To improve performance in this situation, we can store large amount of data on the heap in a box. then, only the small amount of pointer data is copied around on the stack, while the data it references stays in one place on the heap. </li>
</ul>
</li>
<li>
<p>when you want to own a value and you care only that it's a type that implements a particular trait rather than being of a specific type</p>
<ul>
<li>chapter 17. </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="using-a-box-to-store-data-on-the-heap"><a class="header" href="#using-a-box-to-store-data-on-the-heap">Using a Box<T> to Store Data on the Heap</a></h3>
<p>Before  we discuss this use case for Box<T>, cover syntax and how to interact with values stored within a Box<T>. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let v = Box::new(value);

<span class="boring">}</span></code></pre></pre>
<h3 id="enabling-recursive-types-with-boxes"><a class="header" href="#enabling-recursive-types-with-boxes">Enabling Recursive Types with Boxes</a></h3>
<p>Rust does not know how much space a value of a recursive type needs -&gt; boxes have a known size. </p>
<p>you can have recursive type in boxes. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>enum List {
	Cons(i32, List),
	nil,
}

// this can not compile because in the list of Cons's size is not known at compile time. 


enum List {
	Cons(i32, Box&lt;List&gt;),
	nil,
}

<span class="boring">}</span></code></pre></pre>
<p><img src="rust_book/./img/infinite_cons.png" alt="infinite" width = 300 /> </p>
ex) image of List 
<h3 id="computing-the-size-of-a-nonrecursive-type"><a class="header" href="#computing-the-size-of-a-nonrecursive-type">Computing the Size of a NonRecursive Type</a></h3>
<pre><code class="language-Rust">
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

</code></pre>
<p>to determine how much space to allocate for a Message value, Rust goes through each of the variants to see which variant needs the most space. </p>
<p>contrast, Cons list need size of i32 and size of List. the important thing is the size of list is not known at compile time when you declear the enum.</p>
<h3 id="using-box-to-get-a-recursive-type-with-a-known-size"><a class="header" href="#using-box-to-get-a-recursive-type-with-a-known-size">Using Box<T> to get a Recursive type with a known size</a></h3>
<p>store the value indirectly by storing pointer to the value. </p>
<p>Box<T> is a pointer, Rust compiler does know how much size it needs. </p>
<p>so inside of List of Cons, we can put Box<T> that pointer to the value of List and so on. </p>
<pre><code class="language-rs">enum List {
    Cons(i32, Box&lt;List&gt;),
     Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}

</code></pre>
<p>so it looks like this. </p>
<p><img src="rust_book/./img/box<t>_type.png" alt="box_type" width = 300 /> </p>
<p>usize is the pointer that point to the value in the heap memory. </p>
<h3 id="treating-smart-pointer-like-a-regular-reference-with-the-deref-trait"><a class="header" href="#treating-smart-pointer-like-a-regular-reference-with-the-deref-trait">Treating smart pointer like a regular reference with the deref trait.</a></h3>
<p>by implementing deref trait you can use it like a regular reference and also used as smart pointer.</p>
<h3 id="following-the-pointer-to-the-value-with-the-dereference-operator"><a class="header" href="#following-the-pointer-to-the-value-with-the-dereference-operator">Following the pointer to the value with the dereference operator.</a></h3>
<pre><code class="language-rs">
fn main() {

	let x = 5;
	let y = &amp;x;

	assert_eq!(x, y);
}

</code></pre>
<ul>
<li>this code will fail because x and y have different type. 
<ul>
<li>x is i32, y is reference i32. </li>
</ul>
</li>
</ul>
<h3 id="using-box-like-a-reference"><a class="header" href="#using-box-like-a-reference">Using Box<T> like a reference</a></h3>
<pre><code class="language-rs">
fn main() {

	let x = 5;
	let y = Box::new(x);  // y is the pointer to the value on the heap

	assert_eq!(x, *y);
}

</code></pre>
<h3 id="implementing-the-deref"><a class="header" href="#implementing-the-deref">Implementing the deref</a></h3>
<pre><code class="language-rs">
use std::ops::Deref;

struct MyBox&lt;T&gt;(T);

impl&lt;T&gt; MyBox&lt;T&gt; {
	fn new(val : T) -&gt; MyBox(T) {
		MyBox(val)
	}
}


impl&lt;T&gt; Deref for MyBox&lt;T&gt; {
	type Target = T; 

	fn deref(&amp;self) -&gt; &amp;Target {
		&amp;self.0
	}

}

fn main() {

	let a = 5;
	let b = MyBox(a);

	assert_eq!(a, *b);

}


</code></pre>
<p>dref impl makes * operator returns reference to the value instead of return value without reference. 
because it cause deref fn takes ownership of parameter.</p>
<p>it actually looks like this *(a.deref()).</p>
<h3 id="implicit-deref-coersion-with-functions-and-methods"><a class="header" href="#implicit-deref-coersion-with-functions-and-methods">Implicit deref coersion with functions and methods</a></h3>
<p>deref coersion is reference changes into original type that functions and methods expected. </p>
<pre><code class="language-Rust  editable">
fn main() {

	fn hello(val : &amp;str) {
		println!(&quot; hey, {}&quot;, val);
	}


	let a = String::new(&quot;whats up&quot;);

	hello(&amp;a);
	
	// &amp;(*a)[..] -&gt; if we don't use deref coercion we should write down as it is. 
}


</code></pre>
<p>std lib also implement deref coersion on String struct thats why string to reference can be str to reference.</p>
<h3 id="how-deref-coercion-interact-with-mutability"><a class="header" href="#how-deref-coercion-interact-with-mutability">How deref coercion interact with mutability</a></h3>
<ul>
<li>
<p>From &amp;T to &amp;U when T: Dref&lt;Target=U&gt; </p>
</li>
<li>
<p>From &amp;mut T to &amp;mut U when T: DrefMut&lt;Target=U&gt;</p>
</li>
<li>
<p>From &amp;mut T to U when T: Dref&lt;Target=U&gt;</p>
<ul>
<li>note that mutable references can be changed into immutable but reverse is not possible. </li>
<li>think about ownership and borrowing rules. </li>
</ul>
</li>
</ul>
<h3 id="running-code-on-cleanup-with-the-drop-trait"><a class="header" href="#running-code-on-cleanup-with-the-drop-trait">Running code on cleanup with the drop trait</a></h3>
<ul>
<li>
<p>drop trait can be useful when we release resources like files or network connections. </p>
</li>
<li>
<p>drop trait is almost used to implement on smart pointer this is why we are introducing the trait in this chapter. </p>
<ul>
<li>Box<T> needs to drop to deallocate on heap memory. </li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
struct CustomSmartPointer {
      data: String,
  }

impl Drop for CustomSmartPointer {
      fn drop(&amp;mut self) {
        println!(&quot;Dropping CustomSmartPointer with data `{}`!&quot;, self.data);
      }
  }


</code></pre>
<h3 id="dropping-a-value-early-with-stdmendrop"><a class="header" href="#dropping-a-value-early-with-stdmendrop">Dropping a value early with std::men::drop</a></h3>
<p>Disabling drop isn't usually necessary; the whole point of the Drop triat is that is's taken care of automatically. 
however, you might want to clean up a value early. </p>
<p>one example is when using smart pointers that manage locks: you might want to force the drop method that release the lock to run so other code in the same scope can acquire the lock. </p>
<p>but rust does not let you call the Drop trait's drop method manually; instead you have to call the std::mem::drop function if you want to drop value before the end of the its scope. </p>
<p>and also using value.drop() method early is not allowed.</p>
<pre><code class="language-sh">
error[E0040]: explicit use of destructor method
  --&gt; src/main.rs:14:7
   |
14 |     c.drop();
   |       ^^^^ explicit destructor calls not allowed


</code></pre>
<ul>
<li>destructor is the general programming term for a function that cleans up an instance. </li>
<li>it causes double free error. rust would still automatically call drop on the value at the end of main or scope.</li>
</ul>
<pre><code class="language-rs">
	 drop(value) // from std::mem::drop , it works. for early droping value 
</code></pre>
<h3 id="rc-the-reference-counted-smart-pointer"><a class="header" href="#rc-the-reference-counted-smart-pointer">Rc<T>, the reference counted smart pointer</a></h3>
<p>use Rc<T> type when we want to allocate some data on the heap for multiple parts of program to read and we can't determine at compile time which part will finish using the data last so this is why we use Rc<T> type. </p>
<ul>
<li>
<p>Rc<T> allows a single value to have multiple owners, and the count ensures that the value remains valid as long as any of the owners still exist. </p>
</li>
<li>
<p>note that Rc<T> is only used in single thread scenario. </p>
</li>
<li>
<p>what is difference just &amp; and Rc<T> - Rc has multiple ownership </p>
</li>
</ul>
<h3 id="using-rc-to-share-data"><a class="header" href="#using-rc-to-share-data">Using Rc<T> to share data</a></h3>
<p>we'll create two lists that share ownership of a third list. </p>
<p><img src="rust_book/./img/reference_count_img" alt="rc_img" width = 300 /> </p>
<p><em>Example</em> - Two lists, b and c, sharing ownership of a third list, a</p>
<pre><pre class="playground"><code class="language-rust edition2021">
enum List {
    Cons(i32, Box&lt;List&gt;),
    Nil,
}
 use crate::List::{Cons, Nil};

 fn main() {
  let a = Cons(5,
        Box::new(Cons(10,
            Box::new(Nil))));
  let b = Cons(3, Box::new(a));
  let c = Cons(4, Box::new(a));
}
</code></pre></pre>
<p><em>example</em> - demonstrating we're not allowed to have two lists using Box<T> that try to share ownership of a third list</p>
<pre><code class="language-sh">
error[E0382]: use of moved value: `a`
  --&gt; src/main.rs:13:30
   |
12 |     let b = Cons(3, Box::new(a));
   |                              - value moved here
13 |     let c = Cons(4, Box::new(a));
   |                              ^ value used here after move
   |
   = note: move occurs because `a` has type `List`, which does not implement
   the `Copy` trait


</code></pre>
<ul>
<li>
<p>a is moved into b and b owns a. when we try to use a again when creating c, we're not allowed to because a has been moved. </p>
</li>
<li>
<p>we could change the definition of Cons to hold references instead, but then we would have to specify lifetime parameters. By specifying lifetime parameters, we would be specifying that every element in the list will live at least as long as the entire list. </p>
<ul>
<li>the borrow checker wouldn't let us compile let a = Cons(10, &amp;Nil); for example, because the temporary Nil value would be dropped before a could take a reference to it. </li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
enum List {
       Cons(i32, Rc&lt;List&gt;),
       Nil,
   }
 use crate::List::{Cons, Nil};
➊ use std::rc::Rc; // rc is not in the prelude. 
 fn main() {
    ➋ let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
    ➌ let b = Cons(3, Rc::clone(&amp;a));
    ➍ let c = Cons(4, Rc::clone(&amp;a));
   }

</code></pre></pre>
<p><em>example</em> - a definition of list that uses Rc<T> </p>
<ul>
<li>
<p>each Cons variant will now hold a value and an Rc<T> pointing to a list. when we create b, instead of taking ownership of a, we'll clone the Rc<List> that a is holding, thereby increasing the number of references from one to two and letting a and b share ownership of the data in that Rc<List>. </p>
</li>
<li>
<p>we'll also clone a when creating c, increasing the number of references from two to three. </p>
</li>
<li>
<p>every time we call Rc::clone, the reference count to the data within the Rc<List> will increase, and the data won't be cleaned up unless there are zero references to it. </p>
</li>
<li>
<p>Rc::clone only increments the reference count and doesn't make a deep copy. </p>
</li>
</ul>
<h3 id="cloning-an-rc-increases-the-reference-count"><a class="header" href="#cloning-an-rc-increases-the-reference-count">Cloning an Rc<T> increases the reference count</a></h3>
<pre><code class="language-rs">let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));

Rc::strong_count(&amp;a);

</code></pre>
<ul>
<li>
<p>we can get reference count to call this function - Rc::string_count(&amp;value).</p>
</li>
<li>
<p>also has weak_count we will take care of this in later.</p>
</li>
<li>
<p>Rc<List> in a has an initial reference count of 1.</p>
</li>
</ul>
<h3 id="refcell-and-the-interior-mutability-pattern"><a class="header" href="#refcell-and-the-interior-mutability-pattern">RefCell<T> and the Interior Mutability Pattern</a></h3>
<p><em>Interior mutability</em> is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses unsafe code inside a data structure to bend Rust’s usual rules that govern mutation and borrowing. We haven’t yet covered unsafe code; we will in Chapter 19. We can use types that use the interior mutability pattern when we can ensure that the borrowing rules will be followed at runtime, even though the compiler can’t guarantee that. The unsafe code involved is then wrapped in a safe API, and the outer type is still immutable.</p>
<h3 id="enforcing-borrowing-rules-at-runtime-with-refcell"><a class="header" href="#enforcing-borrowing-rules-at-runtime-with-refcell">Enforcing Borrowing Rules at Runtime with RefCell<T></a></h3>
<ul>
<li>
<p>borrowing rules enforcing at compile time -&gt; references and Box<T>.</p>
</li>
<li>
<p>checking the borrowing rules at compile time is the best choice in the majority of cases, which is why this is Rust's default. </p>
</li>
<li>
<p>The advantage of checking the borrowing rules at runtime instead is that certain memory-safe scenarios are then allowed, whereas they are disallowed by the compile-time checks.</p>
</li>
<li>
<p>same as Rc<T>, RefCell<T> is used in the single thread. </p>
</li>
</ul>
<h3 id="halting-problem"><a class="header" href="#halting-problem">Halting problem..</a></h3>
<ul>
<li>The RefCell<T> type is useful when you’re sure your code follows the borrowing rules but the compiler is unable to understand and guarantee that.</li>
</ul>
<h3 id="a-recap-of-the-reasons-to-choose-box-rc-or-refcell"><a class="header" href="#a-recap-of-the-reasons-to-choose-box-rc-or-refcell">a recap of the reasons to choose Box<T>, Rc<T>, or RefCell<T>:</a></h3>
<ul>
<li>Rc<T> enables multiple owners of the same data; Box<T> and RefCell<T> have single owners.</li>
<li>Box<T> allows immutable or mutable borrows checked at compile time; Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable or mutable borrows checked at runtime. </li>
<li>Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.</li>
</ul>
<h3 id="interior-mutablilty--a-mutable-borrow-to-an-immutable-value"><a class="header" href="#interior-mutablilty--a-mutable-borrow-to-an-immutable-value">Interior Mutablilty : A Mutable Borrow to an Immutable Value</a></h3>
<ul>
<li>Using RefCell<T> is one way to get the ability to have interior mutability. But RefCell<T> doesn’t get around the borrowing rules completely: the borrow checker in the compiler allows this interior mutability, and the borrowing rules are checked at runtime instead. If you violate the rules, you’ll get a panic! instead of a compiler error. Let’s work through a practical example where we can use RefCell<T> to mutate an immutable value and see why that is useful. </li>
</ul>
<h3 id="a-use-case-for-interior-mutability-mock-objects"><a class="header" href="#a-use-case-for-interior-mutability-mock-objects">A Use Case for Interior Mutability: Mock Objects</a></h3>
<ul>
<li>A test double is the general programming concept for a type used in place of another type during testing. Mock objects are specific types of test doubles that record what happens during a test so you can assert that the correct actions took place. Rust doesn’t have objects in the same sense as other languages have objects, and Rust doesn’t have mock object functionality built into the standard library as some other languages do. However, you can definitely create a struct that will serve the same purposes as a mock object.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub trait Messenger {
  fn send(&amp;self, msg: &amp;str);
}
 pub struct LimitTracker&lt;'a, T: 'a + Messenger&gt; {
    messenger: &amp;'a T,
    value: usize,
    max: usize,
}
 impl&lt;'a, T&gt; LimitTracker&lt;'a, T&gt;
    where T: Messenger {
    pub fn new(messenger: &amp;T, max: usize) -&gt; LimitTracker&lt;T&gt; {
        LimitTracker {
            messenger,
            value: 0,
            max,
        }
}
  pub fn set_value(&amp;mut self, value: usize) {
       self.value = value;
 let percentage_of_max = self.value as f64 / self.max as f64;
 if percentage_of_max &gt;= 1.0 {
           self.messenger.send(&quot;Error: You are over your quota!&quot;);
       } else if percentage_of_max &gt;= 0.9 {
            self.messenger.send(&quot;Urgent warning: You've used up over 90% of
your quota!&quot;);
        } else if percentage_of_max &gt;= 0.75 {
            self.messenger.send(&quot;Warning: You've used up over 75% of your
quota!&quot;);
        }
    }
}


<span class="boring">}</span></code></pre></pre>
<ul>
<li>we are trying to make an example of RefCell<T> type. so we are using mock struct. </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[cfg(test)]
mod tests {
    use super::*;
  struct MockMessenger {
      sent_messages: Vec&lt;String&gt;,
   }
 impl MockMessenger {
      fn new() -&gt; MockMessenger {
            MockMessenger { sent_messages: vec![] }
        }
    }
 impl Messenger for MockMessenger {
        fn send(&amp;self, message: &amp;str) {
          self.sent_messages.push(String::from(message));
        }
    }
 #[test]
  fn it_sends_an_over_75_percent_warning_message() {
       let mock_messenger = MockMessenger::new();
       let mut limit_tracker = LimitTracker::new(&amp;mock_messenger, 100);
 limit_tracker.set_value(80);
 assert_eq!(mock_messenger.sent_messages.len(), 1);
    }
}


<span class="boring">}</span></code></pre></pre>
<ul>
<li>but this code does not compile because MockMessenger struct's send method is immutable ( trait messenger is using immutable self in send method )</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>error[E0596]: cannot borrow immutable field 'self.sent_messages' as mutable
  --&gt; src/lib.rs:52:13
   |
51 |          fn send(&amp;self, message: &amp;str) {
   |                  ----- use '&amp;mut self' here to make mutable
52 |              self.sent_messages.push(String::from(message));
   |              ^^^^^^^^^^^^^^^^^^ cannot mutably borrow immutable field


<span class="boring">}</span></code></pre></pre>
<ul>
<li>We also can’t take the suggestion from the error text to use &amp;mut self instead, because then the signature of send wouldn’t match the signature in the Messenger trait definition (feel free to try it out and see what error message you get).</li>
</ul>
<p><img src="rust_book/./img/share_reference_cannot_understand" alt="do_not_understand" width = 800 /> </p>
<ul>
<li>I tried to changed to mut but it does not work and i can even understand why.. </li>
</ul>
<p>solved.</p>
<ul>
<li>
<p>the Messensger and LimitTracker and methods are the source code can not change and test code the MockMessenger is implements that for test. </p>
</li>
<li>
<p>in this case we use RefCell for change immutable value to mutable. </p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>mod tests {
    use super::*;
    use std::cell::RefCell;

struct MockMessenger {
      sent_messages: RefCell&lt;Vec&lt;String&gt;&gt;,

}

... 

 self.sent_messages.borrow_mut().push(String::from(message));



<span class="boring">}</span></code></pre></pre>
<ul>
<li>we can change it like this and compile with mock struct.</li>
</ul>
<h3 id="keeping-track-of-borrows-at-runtime-with-refcell"><a class="header" href="#keeping-track-of-borrows-at-runtime-with-refcell">Keeping Track of Borrows at Runtime with RefCell<T></a></h3>
<ul>
<li>
<p>When creating immutable and mutable references, we use the &amp; and &amp;mut syntax, respectively. With RefCell<T>, we use the borrow and borrow_mut methods, which are part of the safe API that belongs to RefCell<T>.</p>
</li>
<li>
<p>The borrow method returns the smart pointer type Ref<T>, and borrow_mut returns the smart pointer type RefMut<T>. Both types implement Deref, so we can treat them like regular references.</p>
</li>
<li>
<p>When a Ref<T> value goes out of scope, the count of immutable borrows goes down by one. Just like the compile-time borrowing rules, RefCell<T> lets us have many immutable borrows or one mutable borrow at any point in time.</p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl Messenger for MockMessenger {
    fn send(&amp;self, message: &amp;str) {
        let mut one_borrow = self.sent_messages.borrow_mut();
        let mut two_borrow = self.sent_messages.borrow_mut();
		one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}

<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Creating two mutable references in the same scope to see that RefCell<T> will panic. </p>
</li>
<li>
<p>Notice that the code panic with the message already borrowed: BorrowMutError. This is how RefCell<T> handles violations of the borrowing rules at runtime.</p>
</li>
<li>
<p>Catching borrowing errors at runtime may cause mistakes to be found later in the development process and incur a small runtime performance penalty. However, using RefCell<T> allows for the creation of mock objects that can modify themselves and provide more functionality than regular references. Despite its trade-offs, RefCell<T> can be used to achieve this.</p>
</li>
</ul>
<h3 id="having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell"><a class="header" href="#having-multiple-owners-of-mutable-data-by-combining-rc-and-refcell">Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T></a></h3>
<p>Rc<T> is a type that allows multiple ownership of an immutable value, while RefCell<T> is a type that provides interior mutability, allowing for mutable access to a value even when it's immutably borrowed. Combining these types allows for multiple owners of a mutable value.</p>
<p>However, there are some rules to follow when using this combination, such as not creating reference cycles and ensuring that all changes to the value are done through a RefCell<T> borrow. The chapter also covers how to use Rc<T> and RefCell<T> with a tree-like structure and how to avoid deadlocks when using multiple threads.</p>
<p>Overall, this chapter provides a practical guide for combining Rc<T> and RefCell<T> to achieve multiple ownership of mutable data in Rust.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}
use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
   let value = Rc::new(RefCell::new(5));

   // clone value so both a and value have ownership of the value
   // we wrap the list a in an Rc&lt;T&gt; so when we create lists b and c, they can both refer to a. multiple ownership 
   let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil))); 

   let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
   let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));
   *value.borrow_mut() += 10;
   println!(&quot;a after = {:?}&quot;, a);
   println!(&quot;b after = {:?}&quot;, b);
   println!(&quot;c after = {:?}&quot;, c);
}

</code></pre></pre>
<ul>
<li>
<p>uses the automatic dereferencing feature we discussed in Chapter 5 (see “Where’s the -&gt; Operator?” on page 94) to dereference the Rc<T> to the inner RefCell<T> value. The borrow_mut method returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.</p>
<ul>
<li>Chapter 5 of &quot;The Rust Programming Language&quot; book introduces the ownership system in Rust and explains the automatic dereferencing feature. This feature allows us to use the . operator instead of -&gt; to access fields and methods of a struct or an object when working with pointers. Rust automatically inserts a dereference operation when it encounters a . operator on a pointer type, but we can still use the * operator to explicitly access the pointer's inner value. Overall, this feature simplifies working with pointers in Rust.</li>
</ul>
</li>
<li>
<p>The runtime checks of the borrowing rules protect us from data races, and it’s sometimes worth trading a bit of speed for this flexibility in our data structures.</p>
<ul>
<li>In Rust, a data race occurs when two or more pointers access the same memory location concurrently without proper synchronization. Data races can lead to undefined behavior and difficult-to-debug issues. Rust's ownership and borrowing system is designed to prevent data races at compile time by enforcing strict rules on how pointers are used and accessed. Rust's borrow checker ensures that a mutable reference is the only reference to a value at any given time, preventing concurrent writes, and Rust provides synchronization primitives to safely share data across threads and prevent data races. By preventing data races at compile time, Rust provides a high level of safety and reliability for concurrent programming while still allowing for high performance.</li>
</ul>
</li>
<li>
<p>The standard library has other types that provide interior mutability, such as Cell<T>, which is similar except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>. There’s also Mutex<T>, which offers interior mutability that’s safe to use across threads; we’ll discuss its use in Chapter 16. Check out the standard library docs for more details on the differences between these types.</p>
</li>
</ul>
<h3 id="reference-cycles-can-leak-memory"><a class="header" href="#reference-cycles-can-leak-memory">Reference Cycles Can Leak Memory</a></h3>
<p>the problem of reference cycles, where two or more values refer to each other, either directly or indirectly, and can cause memory leaks. In Rust, this problem can be addressed using the Rc<T> type for shared ownership and the RefCell<T> type for interior mutability.</p>
<p>However, combining Rc<T> and RefCell<T> can lead to reference cycles, which can cause memory leaks if not handled properly. The chapter provides guidance on how to avoid reference cycles when using these types, such as using weak references (Weak<T>) to break the cycle and using Rc::downgrade to create a weak reference from a shared reference.</p>
<p>The chapter also emphasizes the importance of understanding reference cycles and how they can cause memory leaks, and provides practical examples to help readers identify and address reference cycles in their own Rust code. By understanding and addressing reference cycles, developers can ensure the reliability and safety of their Rust programs.</p>
<ul>
<li>
<p>Rc<T>, RefCell<T> are possible to create references that can cause memory leaks. </p>
</li>
<li>
<p>each item in the cycle will never reach 0, and the value will never be dropped. </p>
</li>
</ul>
<h3 id="creating-a-reference-cycle"><a class="header" href="#creating-a-reference-cycle">Creating a Reference Cycle.</a></h3>
<p>lets look at how a reference cycle might happen and how to prevent it, starting with the definition of the List enum and a tail method. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};

#[derive(Debug)]
enum List {
  Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
  fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}


<span class="boring">}</span></code></pre></pre>
<p>instead of changing value of i32, (example below)</p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[derive(Debug)]
enum List {
    Cons(Rc&lt;RefCell&lt;i32&gt;&gt;, Rc&lt;List&gt;),
    Nil,
}
use crate::List::{Cons, Nil};
use std::rc::Rc;
use std::cell::RefCell;

fn main() {
 ➊ let value = Rc::new(RefCell::new(5));

 ➋ let a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));
 
 let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&amp;a));
 
 let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&amp;a));
 
 ➌ *value.borrow_mut() += 10;
    println!(&quot;a after = {:?}&quot;, a);
    println!(&quot;b after = {:?}&quot;, b);
    println!(&quot;c after = {:?}&quot;, c);
}

</code></pre></pre>
<p>➌. We do this by calling borrow_mut on value, which uses the automatic dereferencing feature we discussed in Chapter 5 (see “Where’s the -&gt; Operator?” on page 94) to dereference the Rc<T> to the inner RefCell<T> value. The borrow_mut method returns a RefMut<T> smart pointer, and we use the dereference operator on it and change the inner value.</p>
<p>we're also adding a tail method to make it convenient for us to access the second item if we have a Cons variant. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">

use std::rc::Rc;
use std::cell::RefCell;
use crate::List::{Cons, Nil};


#[derive(Debug)]
enum List {
    Cons(i32, RefCell&lt;Rc&lt;List&gt;&gt;),
    Nil,
}

impl List {
  fn tail(&amp;self) -&gt; Option&lt;&amp;RefCell&lt;Rc&lt;List&gt;&gt;&gt; {
        match self {
            Cons(_, item) =&gt; Some(item),
            Nil =&gt; None,
        }
    }
}
fn main() {


	// 1
	let a = Rc::new(Cons(5, RefCell::new(Rc::new(Nil))));
	
	println!(&quot;a initial rc count = {}&quot;, Rc::strong_count(&amp;a));
	
	println!(&quot;a next item = {:?}&quot;, a.tail());
	// 2 
	let b = Rc::new(Cons(10, RefCell::new(Rc::clone(&amp;a))));
	
	println!(&quot;a rc count after b creation = {}&quot;, Rc::strong_count(&amp;a));
	
	println!(&quot;b initial rc count = {}&quot;, Rc::strong_count(&amp;b));
	
	println!(&quot;b next item = {:?}&quot;, b.tail());
	// 3 
	if let Some(link) = a.tail() {
	// 4 
	*link.borrow_mut() = Rc::clone(&amp;b);

}

	println!(&quot;b rc count after changing a = {}&quot;, Rc::strong_count(&amp;b));
	
	println!(&quot;a rc count after changing a = {}&quot;, Rc::strong_count(&amp;a));
	// Uncomment the next line to see that we have a cycle;
	// it will overflow the stack.
	// println!(&quot;a next item = {:?}&quot;, a.tail());
}

</code></pre></pre>
<pre><code class="language-sh">
a initial rc count = 1

a next item = Some(RefCell { value: Nil })

a rc count after b creation = 2

b initial rc count = 1

b next item = Some(RefCell { value: Cons(5, RefCell { value: Nil }) })

b rc count after changing a = 2

a rc count after changing a = 2


</code></pre>
<ul>
<li>
<p>a is still referencing the Rc<List> that was in b, that Rc<List> has a count of 1 rather than 0, so the memory the Rc<List> has on the heap won't be dropped. </p>
</li>
<li>
<p>the memory will just sit there with a count of 1, forever. to visualize this below.</p>
</li>
</ul>
<p><img src="rust_book/./img/reference_cycle" alt="referenc_cycle" width = 300 /> </p>
<ul>
<li>
<p>Creating reference cycles is not easily done, but it’s not impossible either. If you have RefCell<T> values that contain Rc<T> values or similar nested combinations of types with interior mutability and reference counting, you must ensure that you don’t create cycles; you can’t rely on Rust to catch them. Creating a reference cycle would be a logic bug in your program that you should use automated tests, code reviews, and other software development practices to minimize.</p>
</li>
<li>
<p>another solution for avoiding reference cycles is reorganizing your data structures so that some references express ownership and some reference don't. as a result, you can have cycles made up of some ownership relationships and some noe-ownership relationships, and only the ownership relationships affect whether or not a value can be dropped. Cons&lt;i32, RefCell&lt;Rc<List>&gt;) always want to own their list, so reorganizing the data structrue isn't possible. </p>
</li>
<li>
<p>lets look at an example using graphs made up of parent nodes and child nodes to see when non-ownership relationships are an appropriate way to prevent reference cycles. </p>
</li>
</ul>
<h3 id="preventing-reference-cycles--turning-an-rc-into-a-weak"><a class="header" href="#preventing-reference-cycles--turning-an-rc-into-a-weak">Preventing Reference Cycles : Turning an Rc<T> into a Weak<T></a></h3>
<ul>
<li>
<p>strong_count - only cleaned up if its strong_count is 0.</p>
<ul>
<li>you can share ownership of an Rc<T> instance. </li>
</ul>
</li>
<li>
<p>weak reference - Rc::downgrade -&gt; smart pointer of type Weak<T> </p>
<ul>
<li>
<p>instead of increasing the strong_count in the Rc<T> instance by 1 increases the weak_count by 1. </p>
</li>
<li>
<p>the difference with strong_count is the weak_count doesn't need to be 0 for the Rc<T> instance to be cleaned up.</p>
</li>
<li>
<p>do not express an ownership relationship. </p>
<ul>
<li>this means that they will not cause a reference cycle because any cycle involving some weak references will be broken once the strong reference count of values involved is 0. </li>
</ul>
</li>
<li>
<p>the value that Weak<T> references might have been dropped, to do anything with the value that a Weak<T> is pointing to, you must make sure the value still exists. </p>
<ul>
<li>calling the upgrade method on a Weak<T> will return the result of Some or None. </li>
</ul>
</li>
</ul>
</li>
</ul>
<p>As an example, rather than using a list whose items know only about the next item, we will create a tree whose items know about their children items and their parent items. </p>
<h3 id="creating-a-tree-data-structure-a-node-with-child-nodes"><a class="header" href="#creating-a-tree-data-structure-a-node-with-child-nodes">Creating a Tree Data Structure: A Node with Child Nodes.</a></h3>
<p>we will build a tree with nodes that know about their child nodes. we will create a struct named <strong>Node</strong> that holds its own i32 value as well as references to its children <strong>Node</strong> values: </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>

<span class="boring">fn main() {
</span>use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]

struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}


<span class="boring">}</span></code></pre></pre>
<ul>
<li>
<p>Node to own its children, and want to share that ownership with variables so we can access each <strong>Node</strong> in the tree directly. </p>
</li>
<li>
<p>To do this we define the Vec<T> items to be values of type Rc<Node>. </p>
</li>
<li>
<p>also want to modify which nodes are children of another node, so we have a RefCell<T> in children around the Vec&lt;Rc<Node>&gt;. </p>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]

struct Node {
    value: i32,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}


fn main() {

	let leaf = Rc::new(Node {
        		value: 3,
		        children: RefCell::new(vec![]),
		    });


	let branch = Rc::new(Node {
       			 value: 5,
	   	         children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
			 });
}

</code></pre></pre>
<ul>
<li>can get from branch to leaf through branch.children otherwise can not.(can not get the parent information) </li>
</ul>
<h3 id="adding-a-reference-from-a-child-to-its-parent"><a class="header" href="#adding-a-reference-from-a-child-to-its-parent">Adding a Reference from a Child to Its Parent</a></h3>
<ul>
<li>
<p>can not contain an Rc<T> because that would create a reference cycle with leaf.parent pointing to branch and branch.children pointing to leaf, which would cause their strong_count values to never be 0.</p>
</li>
<li>
<p>a parent node should own its children: if a parent node is dropped, its child nodes should be dropped as well. </p>
</li>
<li>
<p>a child should not own its parent: if we drop a child node, the parent should still exist. </p>
</li>
<li>
<p>we will use Weak<T>.</p>
</li>
</ul>
<pre><code class="language-rs">
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

</code></pre>
<ul>
<li>A node will be able to refer to its parent node but does not own its parent(Weak<T> type).</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}


fn main() {
	// 1 
	   let leaf = Rc::new(Node {
	        value: 3,
	      parent: RefCell::new(Weak::new()),
	        children: RefCell::new(vec![]),
	    });
	    // 2 
	    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
	
	    let branch = Rc::new(Node {
	        value: 5,
	     parent: RefCell::new(Weak::new()),
	        children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
	    });
	    // 4 
	   *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
	 
	    // 5
	    println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
}

</code></pre></pre>
<ul>
<li>
<ol>
<li>leaf starts out without a prarent, that's why its empty Weak<Node> reference instance. </li>
</ol>
</li>
<li>
<ol start="2">
<li>try to get a reference to the parent of leaf by using the upgrade method, we get a None value. </li>
</ol>
</li>
<li>
<ol start="4">
<li>Weak reference is from Rc::downgrade(&amp;T). </li>
</ol>
</li>
<li>
<ol start="5">
<li>when we call parent node (Weak<T> type), using leaf.parent.borrow().upgrade() method. </li>
</ol>
</li>
<li>
<p>we can avoid reference cycle. weak reference can be dropped and never drop any relation reference becuase its weak!</p>
</li>
</ul>
<h3 id="visualizing-changes-to-string_count-and-weak_count"><a class="header" href="#visualizing-changes-to-string_count-and-weak_count">Visualizing Changes to string_count and weak_count</a></h3>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::rc::{Rc, Weak};
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,
    children: RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;,
}

fn main() {
    let leaf = Rc::new(Node {
        value: 3,
        parent: RefCell::new(Weak::new()),
        children: RefCell::new(vec![]),
    });
 // 1
 println!(
       &quot;leaf strong = {}, weak = {}&quot;,
       Rc::strong_count(&amp;leaf),
       Rc::weak_count(&amp;leaf),
   );

// 2
{
       let branch = Rc::new(Node {
           value: 5,
           parent: RefCell::new(Weak::new()),
           children: RefCell::new(vec![Rc::clone(&amp;leaf)]),
       });
	
	*leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);
 	// 3
	 println!(
           &quot;branch strong = {}, weak = {}&quot;,
           Rc::strong_count(&amp;branch),
           Rc::weak_count(&amp;branch),
      );
        // 4 	
	println!(
          &quot;leaf strong = {}, weak = {}&quot;,
          Rc::strong_count(&amp;leaf),
          Rc::weak_count(&amp;leaf),
      );
 }
// 5  
	// 6 
 	println!(&quot;leaf parent = {:?}&quot;, leaf.parent.borrow().upgrade());
	
	// 7 
	println!(
       
       		&quot;leaf strong = {}, weak = {}&quot;,
       		Rc::strong_count(&amp;leaf),
       		Rc::weak_count(&amp;leaf),
	);

}
</code></pre></pre>
<ul>
<li>
<ol>
<li>after <strong>leaf</strong> is created, its Rc<Node> has a strong count of 1 and a weak count of 0. </li>
</ol>
</li>
<li>
<ol start="2">
<li>inner scope, 3. branch strong count is 1 for init(Rc::new) and weak count also is 1 (leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch))</li>
</ol>
</li>
<li>
<ol start="4">
<li>leaf has 2 strong count ( default for leaf, and children for branch ) otherwise weak count is still 0( there is no weak reference for leaf )</li>
</ol>
</li>
<li>
<p>5 after branch goes out of scope, leaf.parent.borrow().upgrade() is None. </p>
</li>
<li>
<p>6 leaf.parent.borrow().upgrade() is accessing the parent weak<T> ( converting a pointer from a type with weaker shared ownership to a type with stronger shared owndership)</p>
</li>
<li>
<p>7 strong_count for leaf is 1, originally it was 2 ( branch is droped, it had children for leaf)</p>
</li>
<li>
<p>weak_count is still 0.</p>
</li>
</ul>
<h3 id="what-is-upgrading-and-downgrading-"><a class="header" href="#what-is-upgrading-and-downgrading-">What is upgrading and downgrading ?</a></h3>
<ul>
<li>
<p>upgrade refers to converting a pointer from a type with weaker shared ownership to a type with stronger shared ownership. </p>
<ul>
<li>ex) converting a <code>&amp;mut T</code> reference to an <code>Rc&lt;T&gt;</code> smart pointer would be an upgrade because the <code>Rc&lt;T&gt;</code> pointer provides shared ownership whereas the <code>&amp;mut T</code> reference does not. </li>
</ul>
</li>
</ul>
<pre><code class="language-sh">
In Rust, smart pointers provide different levels of shared ownership. Some smart pointers allow multiple references to the same data while others only allow one mutable reference.

When you convert from one type of smart pointer to another, you may be changing the level of shared ownership.

For example, let's say you have a mutable reference to some data:

let mut data = &quot;hello&quot;.to_string();
let mut_ref = &amp;mut data;

If you convert this mutable reference to an Rc pointer, you are upgrading the level of shared ownership. This is because the Rc pointer allows multiple immutable references to the same data, whereas the mutable reference only allows one mutable reference at a time. Here's an example:

use std::rc::Rc;

let rc_ref = Rc::new(*mut_ref);

In this code, *mut_ref dereferences the mutable reference to get the underlying data, and then the Rc::new function creates an Rc pointer to that data.

Conversely, if you convert an Rc pointer to a mutable reference, you are downgrading the level of shared ownership. This is because the mutable reference allows only one mutable reference at a time, whereas the Rc pointer allows multiple immutable references. Here's an example:

let mut_ref_again = Rc::get_mut(&amp;mut rc_ref).unwrap();

In this code, the Rc::get_mut method returns a mutable reference to the data inside the Rc pointer. If the Rc pointer has only one reference to the data (i.e., there are no other immutable references), this method will succeed and return a mutable reference. If there are other immutable references, this method will fail and return None.


So, upgrading and downgrading refer to the change in level of shared ownership when you convert from one type of smart pointer to another.



</code></pre>
<h3 id="what-is-weak-referece-"><a class="header" href="#what-is-weak-referece-">what is weak referece ?</a></h3>
<ul>
<li>
<p>it refers to an object without increasing its reference count. </p>
</li>
<li>
<p>it is useful where you want to refer to an object, but you do not want to prevent it from being dropped when it is no longer need. </p>
</li>
<li>
<p>can create a weak reference from a strong reference by calling the 'downgrade' method on the strong reference. </p>
</li>
<li>
<p>using weak reference, you can call the 'upgrade' method on it. it returns Option&lt;&amp;T&gt;. </p>
</li>
<li>
<p>downgrade makes it weak<T> and upgrade makes it just Rc<T>.</p>
</li>
</ul>
<h3 id="downgrade-reference-weak-"><a class="header" href="#downgrade-reference-weak-">downgrade reference weak<T> ?</a></h3>
<p>In Rust, the term &quot;downgrade&quot; is typically used when converting a strong reference (Rc<T>) to a weak reference (Weak<T>), not when converting a type.</p>
<p>When a Rc<T> is converted to a Weak<T> using the Rc::downgrade() method, the resulting Weak<T> reference does not keep the reference count of the original Rc<T> pointer. Instead, it provides a non-owning, weak reference to the same object.</p>
<p>The resulting Weak<T> reference is weaker than the original Rc<T> reference, in the sense that it does not prevent the object from being dropped or deallocated. However, it is still a reference to the same object, and can be upgraded back to a strong reference using the upgrade() method.</p>
<p>So, to answer your question directly, converting a strong reference to a weak reference using Rc::downgrade() does not change the type of the reference. It creates a new Weak<T> reference that points to the same object as the original Rc<T> reference, but with weaker ownership semantics.</p>
<h3 id="summary-7"><a class="header" href="#summary-7">Summary</a></h3>
<ul>
<li>
<p>the Box<T> type has a known size and points to data allocated on the heap. </p>
</li>
<li>
<p>Rc<T> type keeps track of the number of references to data on the heap so that data can have multiple owners. </p>
</li>
<li>
<p>RefCell<T> type with its interior mutablility gives us a type that we can use when we need an immutable type but need to change an inner value of that type; it also enforces the borrowing rules at runtime instead of at compile time. </p>
</li>
<li>
<p>Dref and Drop traits, which enable a lot of the functionality of smart pointers. </p>
</li>
<li>
<p>reference cycles and that can cause memory leaks and how to prevent them using Weak<T>.</p>
</li>
</ul>
<p>more interest <a href="https://doc.rust-lang.org/stable/nomicon/">more about smart pointer</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fearless-concurrency-ch-16"><a class="header" href="#fearless-concurrency-ch-16">Fearless Concurrency, Ch 16</a></h1>
<ul>
<li>
<p>How to create threads to run multiple pieces of code at the same time. </p>
</li>
<li>
<p><em>Message-Passing</em> concurrency, where channels send messages between threads. </p>
</li>
<li>
<p><em>Shared-state</em> concurrency, where multiple threads have a access to some piece of data. </p>
</li>
<li>
<p>The <strong>Sync</strong> and <strong>Send</strong> traits, which extends Rust's concurrency guarntess to user-defined types as well as types provied by the standard library</p>
</li>
</ul>
<h3 id="thread"><a class="header" href="#thread">thread</a></h3>
<p>Spliting the computation in your program into multiple threads can improve performance but it also cause</p>
<ul>
<li>
<p>Race conditions : accesing data or resource in an inconsistent order. </p>
</li>
<li>
<p>Deadlocks : two threads are waiting for each other to finish using a resource the order thread has. </p>
</li>
<li>
<p>Bugs : happen only in certain situations and hard to fix. </p>
</li>
</ul>
<p>Rust in std only provide 1:1 threading. (check M:N threading and what is green thrad).</p>
<p>example)</p>
<ul>
<li>the return type of <em>thread::spawn</em> is <strong>Join Handle</strong> (it owns value). </li>
<li><em>join</em> method on it, will wait for its thread to finish. </li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">use std::thread;
use std::time::Duration;

fn main() {

	let handle = thread::spawn(|| {
        for i in 1..10 {
            println!(&quot;hi number {} from the spawned thread!&quot;, i);
            thread::sleep(Duration::from_millis(1));
 		}
    	});
	
	for i in 1..5 {
        	println!(&quot;hi number {} from the main thread!&quot;, i);
        	thread::sleep(Duration::from_millis(1));
    	}
     	handle.join().unwrap(); // -&gt; block the current thread. 
}
</code></pre></pre>
<ul>
<li>
<p>join on the handle blocks the thread currently running until thread represented by the handle terminates. </p>
</li>
<li>
<p><em>Blocking</em> a thread means that thread is prevented from performing work or exiting.</p>
</li>
</ul>
<h3 id="using-move-closures-with-threads"><a class="header" href="#using-move-closures-with-threads">Using move Closures with Threads.</a></h3>
<p>transfer data from one thread to another thread. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {
	let v = vec![1, 2, 3];
	
	let handle = thread::spawn(|| {
		println!(&quot;Here's a vector: {:?}&quot;, v);
		});

	// here 
	handle.join().unwrap();
}
</code></pre></pre>
<ul>
<li>
<p>can not compile because the thread is borrowing value v but compiler does not know how long spawned thread will run.</p>
</li>
<li>
<p>example, if we put drop code above <em>drop(v)</em> at <strong>here</strong> then thread using v value has a problem.</p>
</li>
<li>
<p>use <em>move</em> keyword can fix these problem.</p>
</li>
</ul>
<h3 id="using-message-passing-to-transfer-data-between-threads"><a class="header" href="#using-message-passing-to-transfer-data-between-threads">Using message passing to transfer data between threads.</a></h3>
<ul>
<li>
<p><em>channel</em> has two halves : <em>transmitter</em> and <em>receiver</em> . </p>
</li>
<li>
<p>a chanel is said to be <em>closed</em> if either transmitter or receiver half is dropped.</p>
</li>
</ul>
<p>usecase : chat system, or a system where many threads perform parts of a calulation and send the  parts to one thread that aggregates the results. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::sync::mpsc;
use std::thread;

fn main(){

	let (tx, rx) = mpsc::channel(); 

	thread::spawn(move || {
		let tranfer_value = String::from(&quot;value&quot;);
		let o = tx.send(tranfer_value).unwrap();
		println!(&quot;{:?}&quot;, o);
	});

	//let recv = rx.recv().unwrap();
	let recv = rx.recv();
	println!(&quot;{:?}&quot;, recv);

}

</code></pre></pre>
<ul>
<li>
<p>mpsc stands for <em>multiple producer, single consumer</em>. </p>
<ul>
<li>multiple streams flowing together into one big river.</li>
</ul>
</li>
<li>
<p><em>send()</em> method returns Result&lt;T, E&gt; type, if receiver is dropped results will be Result<E> otherwise it returns nothing. </p>
</li>
<li>
<p><em>recv()</em> method block the current threads and returns Result&lt;T, E&gt; type, if sending end of the channel closes, recv will return error otherwise it returns value.</p>
</li>
<li>
<p>the receiving end of a channel has two useful methods : recv(), try_recv().</p>
</li>
<li>
<p>try_recv() methods does not block, but it will instead return Results immediately: an Ok or Error if there are any messages this time. </p>
<ul>
<li>using it is useful when thread has other work to do while waiting for messages. </li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::thread;
use std::sync::mpsc;
use std::time::Duration;
fn main() {
	let (tx, rx) = mpsc::channel();

	let tx1 = mpsc::Sender::clone(&amp;tx);
	thread::spawn(move || {
  		let vals = vec![
	        	String::from(&quot;hi&quot;),
	        	String::from(&quot;from&quot;),
	        	String::from(&quot;the&quot;),
	        	String::from(&quot;thread&quot;),
  			];
		
		for val in vals {
       			tx1.send(val).unwrap();
       			thread::sleep(Duration::from_secs(1));
			}
		});


	thread::spawn(move || {
		let vals = vec![
		   String::from(&quot;hi&quot;),
		   String::from(&quot;from&quot;),
		   String::from(&quot;the&quot;),
		   String::from(&quot;thread&quot;),
		];
		for val in vals {
		   tx.send(val).unwrap();
		   thread::sleep(Duration::from_secs(1));
		}
		});

	for received in rx {
		println!(&quot;Got: {}&quot;, received);
	}
}

</code></pre></pre>
<ul>
<li><em>multiple producer single consumer</em> </li>
</ul>
<h3 id="shared-state-concurrency"><a class="header" href="#shared-state-concurrency">Shared-State Concurrency</a></h3>
<p>mulitiple threads can access the same memory location at the same time. </p>
<ul>
<li>
<p>mutexes, one of the more common concurrency primitives for shared memory. </p>
<ul>
<li><em>Mutex</em> , <em>mutual exclusion</em> .</li>
</ul>
</li>
<li>
<p>to access the data in a mutex, a thread must signal that it wants access by asking to acquire the mutax' <em>lock</em>. </p>
</li>
<li>
<p>the mutex is descrived as <em>garding</em> the data it holds via locking system. </p>
</li>
</ul>
<p><strong>mutex rules</strong></p>
<ul>
<li>
<p>you must attempt to acquire the <em>lock</em> before using the data. </p>
</li>
<li>
<p>when you're done with the data that the mutex guards, you must unlock the data so other thread can acquire the lock. </p>
<ul>
<li>example of pannel disscusion at conference with only one microphone. </li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::sync::Mutex;

fn main() {

	let m = Mutex::new(5);
	
	{
		println!(&quot;lock = {:?}&quot;, m.lock());
		
		let mut num = m.lock().unwrap();
	
		println!(&quot;num = {:?}&quot;, num);
		
		*num = 100;
	}

	println!(&quot;m = {:?}&quot;, m);

}

</code></pre></pre>
<ul>
<li>
<p><em>lock</em> will block the current thread until the thread had held lock releses the lock. </p>
</li>
<li>
<p>the call to <em>lock</em> would fail if another thread holding the <em>lock</em> panicked. in this case, we call unwrap() have this thread panic. </p>
</li>
<li>
<p><em>Mutex<T></em> is a smart pointer called <em>MutexGuard</em> (<em>lock</em> returns it).</p>
<ul>
<li>impl <em>deref</em>, and <em>drop</em> (releases the lock automatically).</li>
</ul>
</li>
</ul>
<h3 id="sharing-a-mutex-between-multiple-threads"><a class="header" href="#sharing-a-mutex-between-multiple-threads">Sharing a Mutex<T> Between multiple threads.</a></h3>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::sync::Mutex;
use std::thread; 


fn main() {

	let count = Mutex::new(10);

	let mut handles = vec![];

	for _ in 0..10 {
		
		let handle = thread::spawn(move || {
			
			let mut num = count.lock().unwrap();
			*num += 10;
		
		});

		handles.push(handle);

	};

	for h in handles {

		h.join().unwrap();

	};

	println!(&quot;count : {:?}&quot;, count);
}
</code></pre></pre>
<ul>
<li>this code does not compile. using mutex<T> in multiple thread is not allowed and also Rc<T> type can not use in this case as well because Rc<T> is not safe across threads. </li>
</ul>
<h3 id="atomic-reference-counting-with-arc"><a class="header" href="#atomic-reference-counting-with-arc">Atomic reference counting with Arc<T></a></h3>
<ul>
<li>
<p>atomics work like primitive types but are safe to share across threads. </p>
<ul>
<li>it can cause performance panalty.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::sync::{Mutex, Arc};
use std::thread; 


fn main() {

	let count = Arc::new(Mutex::new(10));

	let mut handles = vec![];

	for _ in 0..10 {
		
		let count = Arc::clone(&amp;count);
		
		let handle = thread::spawn(move || {

			let mut num = count.lock().unwrap();
			
			*num += 10;
		
		});

		handles.push(handle);

	};

	for h in handles {

		h.join().unwrap();

	};

	println!(&quot;count : {:?}&quot;, count);
}
</code></pre></pre>
<h3 id="similarities-between-refcell-rc-and-mutex-arc"><a class="header" href="#similarities-between-refcell-rc-and-mutex-arc">Similarities between Refcell<T>, Rc<T> and Mutex<T>, Arc<T></a></h3>
<ul>
<li>
<p><em>mutex</em> also provide interior mutablility. </p>
</li>
<li>
<p>using Rc<T> come with the risk of creating reference cycles and also Mutex<T> come with the risk of creating <em>deadlocks</em>.</p>
</li>
</ul>
<h3 id="extensible-concurrency-with-the-sync-and-send-traits"><a class="header" href="#extensible-concurrency-with-the-sync-and-send-traits">extensible concurrency with the Sync and Send Traits.</a></h3>
<ul>
<li>
<p>the <em>Send</em> marker trait indicates that ownership of the type implementing <em>Send</em> can be transfered between threads. </p>
<ul>
<li>
<p>almost every Rust type is <em>Send</em>, but there are some exceptions, including Rc<T>: 
if you tried to tranfer it across thread, both threads need to be updated count.</p>
</li>
<li>
<p>almost all primitive types are <em>Send</em>, aside from raw pointers. </p>
</li>
</ul>
</li>
</ul>
<h3 id="allowing-acess-from-multiple-threads-with-sync"><a class="header" href="#allowing-acess-from-multiple-threads-with-sync">allowing acess from Multiple threads with Sync.</a></h3>
<ul>
<li>
<p>the <em>Sync</em> makers trait indicates that it is safe for the type implementing <em>Sync</em> to be referenced from multiple threads. In other words, any type T is <em>Sync</em> if &amp;T(a reference to T) is <em>Send</em>, meaning the reference can be send safely to another thread. </p>
</li>
<li>
<p>the smart pointer Rc<T> is also not Sync for the same reasons that it's not Send. </p>
<ul>
<li>
<p>RefCell and Cell types are not <strong>Sync</strong>. </p>
<ul>
<li>Cell is used for scalar type that implements Copy trait, otherwise Refcell is used more comflex type. </li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="implementing-send-and-sync-manually-is-unsafe"><a class="header" href="#implementing-send-and-sync-manually-is-unsafe">Implementing Send and Sync Manually is Unsafe.</a></h3>
<ul>
<li>
<p>thoes are <em>Maker traits</em>, they do not have methods to implement. </p>
</li>
<li>
<p>we will talk about unsafe code in chapter 19 and building new concurrent type without those need to be careful thought. </p>
</li>
</ul>
<h3 id="summary-8"><a class="header" href="#summary-8">summary</a></h3>
<ul>
<li>
<p>handler, join : block thread until it finished.</p>
</li>
<li>
<p>channel (mpsc) : recv(), try_recv() </p>
</li>
<li>
<p>mutex, arc </p>
</li>
<li>
<p>send and sync as maker type. </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="object-oriented-programming-ch-17"><a class="header" href="#object-oriented-programming-ch-17">Object Oriented programming, Ch 17</a></h1>
<p>a trait object points to both an instance of a type implementing our specified trait as well as a table used to look up trait methods on that type at runtime. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// we can move this code to lib.rs like a modules. 

pub trait Draw {
	
	fn draw(&amp;self);

}


pub struct Screen {

	pub components : Vec&lt;Box&lt;dyn Draw&gt;&gt;,
	// pub components : Vec&lt;T&gt;, -&gt; it can not take multiple types at a time.  
}


impl Screen {

	fn run(&amp;self) {

		for component in self.components.iter() {
			
			component.draw(); 

		}
	}

}


struct SelectBox {

	// elided .. 
}

impl Draw for SelectBox {
	
	fn draw(&amp;self) {
	 // elided ..
	 println!(&quot; draw for select box&quot;);
	}
}


struct Button {

	// elided .. 
}

impl Draw for Button {
	
	fn draw(&amp;self) {
	 // elided .. 
	 println!(&quot; draw for button&quot;);
	}
}

fn main() {

	let screen = Screen {
		components : vec![
			Box::new(SelectBox{
				// ..
			}),
			Box::new(Button{
				// .. 
			}), 
		],
	};

	screen.run(); 

}

</code></pre></pre>
<ul>
<li>A generic type parameter can only be substituted with one concrete type at a time, whereas trait objects allow for multiple concrete types to fill in for the trait object at runtime.</li>
</ul>
<h3 id="trait-objects-perform-dynamic-dispatch"><a class="header" href="#trait-objects-perform-dynamic-dispatch">Trait Objects Perform Dynamic Dispatch</a></h3>
<ul>
<li>
<p>recall in performance of code using generic, monomorphization performed by the compiler.  -&gt; static dispatch </p>
</li>
<li>
<p>dynamic dispatch cases, the compiler emits codes that at runtime will figure out which method to call. </p>
</li>
<li>
<p>trait object have two pointer, one is the pointer of the instance of struct or enum that implements the trait andthe other pointer points to the funtions that implemeted on the instance. (compiler checks that the type of object and if its safe, then create pointer address and put it in the vtable).</p>
</li>
<li>
<p>dynamic dispatch also prevents compiler from inline a method's code, which in turn prevents some optimizations. </p>
</li>
</ul>
<h3 id="object-safety-is-required-for-trait-objects"><a class="header" href="#object-safety-is-required-for-trait-objects">Object Safety is required for trait objects</a></h3>
<ul>
<li>
<p>the return type is not self. (Clone trait) </p>
</li>
<li>
<p>there are no generic type parameters. </p>
</li>
</ul>
<h3 id="example-2"><a class="header" href="#example-2">example</a></h3>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

trait State {

	// we use *Box&lt;Self&gt;*, invalidating the old state so the state value of **Post** can transform into a new state.   
    fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    
    fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
    
    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; Option&lt;&amp;'a str&gt; {
      Some(&quot;&quot;) 
    }

    fn reject(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;

}

#[derive(Debug)]
struct Draft {}

impl State for Draft {
   
   fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
	self
   }
   
   fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
   	Box::new(PendingReview {})
   }
   
   fn reject(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
	self
   }

    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; Option&lt;&amp;'a str&gt; {
        None 
    }
}
 

#[derive(Debug)]
struct PendingReview {}

impl State for PendingReview {
  
	fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
		Box::new(Published {})
   	}
    
	fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
		self
	}
	
	fn reject(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
		Box::new(Draft {})
   	}

    fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; Option&lt;&amp;'a str&gt; {
        Some(&quot;&quot;) 
    }
}


#[derive(Debug)]
struct Published {}

impl State for Published {
	fn request_review(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
		self
	}
 
 	fn approve(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
		self
 	}

 	fn content&lt;'a&gt;(&amp;self, post: &amp;'a Post) -&gt; Option&lt;&amp;'a str&gt; {
        println!(&quot;Published contents&quot;);
		Some(&amp;post.content)
	}
	
	fn reject(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; {
		self
   	}
}

// #[derive(Debug)]
pub struct Post {
    state: Option&lt;Box&lt;dyn State&gt;&gt;,
    content: String,
}

// impl Debug for Post {}

impl Post {
    pub fn new() -&gt; Post {
        Post {
          state: Some(Box::new(Draft {})),
          content: String::new(),
        }
   }

    pub fn add_text(&amp;mut self, text: &amp;str) {
        match self.state.as_ref().unwrap().content(&amp;self) {
            Some(s) =&gt; println!(&quot;add text : {:?}&quot;, s),  
            None =&gt; {
                self.content.push_str(text);
            },
        }
    }


    // take method to take ownership of it. 
    pub fn request_review(&amp;mut self) {
	if let Some(s) = self.state.take() {
        	self.state = Some(s.request_review())
        }
    }

    pub fn approve(&amp;mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }

    pub fn content(&amp;self) -&gt; &amp;str {
        match &amp;self.state.as_ref().unwrap().content(self) {
            Some(s) =&gt; s,
            None =&gt; &quot;&quot;,  
        }
    	// self.state.as_re().unwrap().content(&amp;self).unwrap()
    }

    pub fn reject(&amp;mut self) {
		if let Some(s) = self.state.take() {
			self.state = Some(s.reject())
	}
    }

  }

    let mut post = Post::new(); 
    println!(&quot;{:?}&quot;, post.content());
    post.add_text(&quot;test&quot;);
    println!(&quot;{:?}&quot;, post.content());
    post.request_review();
    post.add_text(&quot;hello&quot;);
    println!(&quot;{:?}&quot;, post.content());
    post.approve();
    post.add_text(&quot;world&quot;);

    println!(&quot;####### {:?}&quot;, post.content());

}
</code></pre></pre>
<h3 id="trade-offs-of-the-state-pattern"><a class="header" href="#trade-offs-of-the-state-pattern">Trade-offs of the State Pattern</a></h3>
<p>we've shown that Rust is capable of implementing the object-oriented state pattern to encapsulate the different kinds of behavior a post shold have in each state. </p>
<p>the state pattern can result in some coupling between states, as each state object is responsible for transitioning to the next state. Additionally, there may be some duplication of logic, and attempts to eliminate this may violate object safety. Finally, implementing the state pattern in Rust as it is defined for object-oriented languages may not take full advantage of Rust's strengths, such as compile-time checks for invalid states and transitions.</p>
<p>Therefore, the state pattern in Rust is a trade-off between the benefits of encapsulating state-based behavior and the potential downsides of coupling between states and duplication of logic. By using Rust's unique features such as macros and compile-time checks, it is possible to mitigate some of these downsides and create more efficient and maintainable code.</p>
<h3 id="encoding-states-and-behavior-as-types"><a class="header" href="#encoding-states-and-behavior-as-types">Encoding states and behavior as types</a></h3>
<p>the code below shows that it will be impossible for us to accidentally display draft post content in production, because that code won't even compile. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
pub struct Post {
    content: String,
}

 pub struct DraftPost {
    content: String,
}

 impl Post {
 
 pub fn new() -&gt; DraftPost {
         DraftPost {
             content: String::new(),
         }
 }

   pub fn content(&amp;self) -&gt; &amp;str {
          &amp;self.content
     }
}
 
 impl DraftPost {
   pub fn add_text(&amp;mut self, text: &amp;str) {
         self.content.push_str(text);
    }
}

</code></pre></pre>
<ul>
<li>draftpost does not have a content method, so it can display the content.</li>
</ul>
<h3 id="implementing-transition-as-transformations-into-different-types"><a class="header" href="#implementing-transition-as-transformations-into-different-types">implementing transition as transformations into different types.</a></h3>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main(){

pub struct Post {
    content: String,
}

 pub struct DraftPost {
    content: String,
}

 impl Post {
 
 pub fn new() -&gt; DraftPost {
         DraftPost {
             content: String::new(),
         }
 }

   pub fn content(&amp;self) -&gt; &amp;str {
          &amp;self.content
     }
}
 
 impl DraftPost {
   pub fn add_text(&amp;mut self, text: &amp;str) {
         self.content.push_str(text);

	}
   pub fn request_review(self) -&gt; PendingReviewPost {
        PendingReviewPost {
            content: self.content,
        }
    }
}
 
pub struct PendingReviewPost {
    content: String,
}
 
impl PendingReviewPost {
    pub fn approve(self) -&gt; Post {
        Post {
            content: self.content,
        }
   }
}
    

let mut post = Post::new();
 post.add_text(&quot;I ate a salad for lunch today&quot;);
 let post = post.request_review();
 let post = post.approve();
 assert_eq!(&quot;I ate a salad for lunch today&quot;, post.content());

}



</code></pre></pre>
<p>Rust is capable of implementing objects-oriented patterns, other patterns, such as encoding state into the type system, are available in Rust. </p>
<h3 id="summary-9"><a class="header" href="#summary-9">summary</a></h3>
<p>Rust can use trait objects to implement some object-oriented features and patterns, which can improve code maintainability at the expense of runtime performance. 
Rust has other unique features such as ownership that traditional object-oriented languages lack, and these features should be considered when choosing the best design pattern. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-features-ch-19"><a class="header" href="#advanced-features-ch-19">Advanced Features, Ch 19</a></h1>
<p>we will cover.. </p>
<ol>
<li>
<p><strong>Unsafe Rust</strong> How to opt out of some of Rust's guarantess and take responsibility for manually upholding those guarantees </p>
</li>
<li>
<p><strong>Advanced traits</strong> Associated types, default type parameters, fully qualified syntax, supertraits, and newtype pattern in relation to traits </p>
</li>
<li>
<p><strong>Advanced types</strong> More about the newtype pattern, type aliases, the never type, and dynamically sized types </p>
</li>
<li>
<p><strong>Advanced functions and closures</strong> Function pointers and returning closures </p>
</li>
<li>
<p><strong>Macros</strong> Ways to define code that defines more code at compile time </p>
</li>
</ol>
<p>thoes are panoply of Rust features that you should know. </p>
<h3 id="unsafe-rust"><a class="header" href="#unsafe-rust">Unsafe Rust</a></h3>
<p>so far, we've discussed Rust's memory safety guarantees enforced at compile time. 
other features that does not enforced at compile time. 
Unsafe Rust exists because of that static analysis is conservative.(in this context, static analysis means process of being analyzing code at compile time)
but if you use unsafe incollectly, problems due to memory unsafety, such as null pointer dereferencing, can occur. </p>
<p>&quot;Another reason Rust has an unsafe alter ego is that the underlying computer hardware is inherently unsafe&quot;</p>
<p>&quot;Rust can directly interact with the operating system or even writing your own operating system&quot;</p>
<p>&quot;working with low-level systems programming is one of the goals of the language&quot;</p>
<h4 id="unsafe-superpowers"><a class="header" href="#unsafe-superpowers">unsafe superpowers</a></h4>
<ul>
<li>
<p>dereference a raw pointer </p>
</li>
<li>
<p>call an unsafe function or method </p>
</li>
<li>
<p>access or modify a mutable static variable </p>
</li>
<li>
<p>implement an unsafe trait </p>
</li>
</ul>
<h4 id="what-you-need-to-know"><a class="header" href="#what-you-need-to-know">what you need to know</a></h4>
<ul>
<li><strong>unsafe</strong> does not turn off the borrow checker or disable any other of Rust's safety checks.</li>
<li>if you use a reference in unsafe code, it will still be checked. </li>
<li><strong>unsafe</strong> keyword only give you access to these four features that are then not checked by the compiler for memory safety. </li>
<li>you will still get some degree of safety inside of an unsafe block. </li>
</ul>
<h4 id="then-why-we-annotate-unsafe"><a class="header" href="#then-why-we-annotate-unsafe">then why we annotate unsafe?</a></h4>
<ul>
<li>you will know that any errors related to memory safety must be within an <strong>unsafe</strong> block, easy to find when you investigate memory bugs. </li>
</ul>
<p>it's best to enclose unsafe code within a safe abstraction and provide a safe API. (unsafe function, methods)</p>
<h4 id="dereferencing-a-raw-pointer"><a class="header" href="#dereferencing-a-raw-pointer">dereferencing a raw pointer</a></h4>
<p>ealier, the compiler ensures references are always valid. </p>
<p>Usafe Rust has two new types </p>
<ul>
<li>
<p><em>raw pointers</em> : immutable - *const T, mutable - *mut T.  the asterisk isn't the dereference operator, it's part of the type name. 	ex) let raw_ptr = x as *const i32; *raw_ptr = other value; , can not be assigned. </p>
<ul>
<li>are allowed to ignore the borrowing rules by having both immutable and mutable pointers or multiple mutable pointers to the same location</li>
<li>are not guaranteed to point to valid memory </li>
<li>are allowed to be null </li>
<li>do not implement any automatic cleanup 
<ul>
<li>you can use these abilities for performance or interface with another language or hardware. </li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

	let mut num = 5; 
	// raw pointer can create mutable and immutable reference at the same time 	
	let raw_ptr = &amp;num as *const i32;
	
	let raw_ptr2 = &amp;mut num as *mut i32;

	unsafe {

		println!(&quot;raw_ptr : {}&quot;, raw_ptr);
		println!(&quot;raw_ptr2 : {}&quot;, raw_ptr2);
	}
}
</code></pre></pre>
<ul>
<li>can not derefernce raw pointers outside an unsafe block. </li>
<li>we can make assumption that raw pointer is valid because we created them directrly from references guaranteed, but we can not make that assumption about just any raw pointer. </li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {
	
	let addr = 0x012345usize;
	let r = addr as *const i32; 
	// we just created raw pointer from an arbitrary memory that is undefined. 
	// we can use raw pointer within unsafe block. 
}
</code></pre></pre>
<ul>
<li>With raw pointers, we can create a mutable pointer and an immutable pointer to the same location. </li>
<li>it can potentially creating a data race so we need to be careful. </li>
</ul>
<p>use case. </p>
<ul>
<li>interfacing with C code. </li>
<li>when building up safe abstractions that the borow checker does not understand. </li>
</ul>
<h3 id="calling-an-unsafe-function-or-method"><a class="header" href="#calling-an-unsafe-function-or-method">Calling an Unsafe Function or Method</a></h3>
<p>the keyword &quot;unsafe&quot; means we has requirements we need to uphold when we call this function that Rust can not guarntee. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

	unsafe fn danger_fn(){}

	unsafe {

		danger_fn();

	}

}
</code></pre></pre>
<h3 id="creating-a-safe-abstraction-over-unsafe-code"><a class="header" href="#creating-a-safe-abstraction-over-unsafe-code">Creating a Safe Abstraction over Unsafe Code</a></h3>
<p>wrapping unsafe code in a safe function is a common abstraction. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">

fn split_at_mut(slice : &amp;mut [i32], mid : usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
	let len = slice.len();
	
	assert!(mid &lt;= len);

	//(&amp;mut slice[0..mid],
		&amp;mut[mid..])

	// this code can not compile because we know slice of a and b are not overlaping but Rust does not know this. 

	let prt = slice.at_mut_ptr(); 
	
	unsafe {
		(slice::from_raw_parts_mut(ptr, mid),
			slice::from_raw_parts_mut(prt.add(mid), len - mid)) 
	}
	// second value of tuple's pointer location start at pointer plus mid and lenth of ramainer. 
}

fn main() {


	let mut v = vec![1,2,3,4,5,6];

	let r = &amp;mut v[..];

	let (a, b) = r.split_at_mut(3);

	assert_eq!(a, &amp;mut[1,2,3]);
	assert_eq!(a, &amp;mut[4,5,6]);

	// this code now compile. 

}


</code></pre></pre>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

	let addr = 0x012345usize;
	let r = addr as *mut i32; 

	let slice: &amp;[i32] = unsafe {
	
		slice::from_raw_parts_mut(r, 10000)

	};

}
</code></pre></pre>
<ul>
<li>Creating a slice from an arbitrary memory location. </li>
<li>in this case, 
<ul>
<li>we do not own the memory at this arbitrary location, </li>
<li>and there is no guarantee that the slice this code creates contains valid i32 values. </li>
<li>attemping to use slice as though it's a valid slice results in undefined behavior. </li>
</ul>
</li>
</ul>
<h3 id="using-extern-functions-to-call-external-code"><a class="header" href="#using-extern-functions-to-call-external-code">Using extern functions to call external code.</a></h3>
<ul>
<li>extern keyword( within extern blocks are always unsafe to call from Rust code).
<ul>
<li>other languages do not enforce Rust's rules and guarantees and Rust can not check them. </li>
</ul>
</li>
<li><em>use of a Foreign Function Interface (FFI)</em></li>
</ul>
<img src='./img/19chapter_hand_image/Rust-2.jpg' width='700'>
<img src='./img/19chapter_hand_image/Rust-3.jpg' width='700'>
<img src='./img/19chapter_hand_image/Rust-4.jpg' width='700'>
<img src='./img/19chapter_hand_image/Rust-5.jpg' width='700'>
<img src='./img/19chapter_hand_image/Rust-6.jpg' width='700'>
<img src='./img/19chapter_hand_image/Rust-7.jpg' width='700'>
<img src='./img/19chapter_hand_image/Rust-8.jpg' width='700'>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-by-example"><a class="header" href="#rust-by-example">Rust by example</a></h1>
<p>제가 정리할 러스트 예제는 <a href="https://doc.rust-lang.org/stable/rust-by-example/">RustByExample</a>을 
정독하며 번역과 요약을 통해 올릴 예정입니다. </p>
<p>부족함이 많고 영어가 출중하신 분들은 위에 링크된 페이지를 통해 공부하시는 것도 좋은 방법입니다.</p>
<p>공홈에 있는 책을 먼저 읽고 보는 것이 좋다고 생각되나 프로그래밍에 대한 지식이 조금 있으시면 바로 예제를 보시는 것도 나쁘지 않다고 생각하며 예제도 상당히 좋다고 생각합니다.</p>
<p>참고하여 제 생각대로 번역하고 정리한 것임으로 부족함이 많습니다. 고려하여 참고 부탁드립니다.</p>
<p>감사합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello world</a></h1>
<p>간단하게 출력 그리고 포맷팅 출력에 대해 알아보자.</p>
<p>먼저 main.rs 파일을 만들어 직접 컴파일해서 출력하는 방법을 알아보자.</p>
<pre><code class="language-bash">
$vi main.rs 

</code></pre>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {
	
	println!(&quot;Hello World!&quot;);

}
</code></pre></pre>
<p><code>rustc</code> 로 컴파일하기.</p>
<pre><code class="language-bash">
$rustc hello.rs 
./hello

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-주석"><a class="header" href="#comments-주석">Comments, 주석</a></h1>
<ul>
<li>
<p>주석은 컴파일러에 의해 무시된다. 즉 사용자가 코드에 대한 설명 등을 작성할 때 주로 사용된다. </p>
</li>
<li>
<p>종류</p>
<ul>
<li>// 라인 주석</li>
<li>/* 블록 주석</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

	/*
	 * 설명이 긴 주석이 필요로 할 때에는 블록 주석을 
	 * 통해 추가할 수 있습니다.
	 */


	 // 변수 a 와 b 를 통해 원하는 String 을 나타낼 수 있다.
         let a = String::from(&quot;러스트를 배워보자&quot;); 
         let b = String::from(&quot;예제를 통해&quot;); 
         println!(&quot;{} {} &quot;, b, a)	

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatted-print-형식에-맞춰-출력하기"><a class="header" href="#formatted-print-형식에-맞춰-출력하기">Formatted print, 형식에 맞춰 출력하기.</a></h1>
<p>러스트에서 print 는 macros 로 짜여져있다. 후반에 macro 에 대해 자세히 다룰 예정이다. 
또한 macro 는 standard lib 인 std::fmt 에 포함되어 있다.</p>
<ul>
<li>포맷 종류
<ul>
<li><code>format!</code>: 어떠한 text 를 String 으로 포맷팅한다. </li>
<li><code>print!</code>: 포맷과 비슷하지만 입력된 text 는 콘솔에 표현된다 (io::stdout).</li>
<li><code>println!</code>: print 와 동일하지만 ln 을 보면 알겠지만 한 줄 추가된다(엔터 친 효과).</li>
<li><code>eprint!</code>: 포맷과 같지만 text가 standard error 로 프린트된다(io::stderr).</li>
<li><code>eprintln!</code>: eprint!와 같지만 한 줄 추가된다.</li>
</ul>
</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {

        let a = &quot;ln이 없을 경우와 있을 경우.&quot;.to_string(); 
        let b = &quot;ln이 있을 경우와 없을 경우.&quot;.to_string();
        print!(&quot;{a} :&quot;);
        print!(&quot;한 줄 추가 없이 그대로 나열됨.\n&quot;); 
        println!(&quot;-----------------------------&quot;);
        println!(&quot;{b} :&quot;);
        print!(&quot;한 줄 추가된 채로 나열됨. \n &quot;);
     

        println!(&quot;{1} 보다 {0} 을 먼저 갖춰라.&quot;, &quot;인&quot;, &quot;예&quot;);
 
        //변수 이름 지정
        println!(&quot;{first}은 바람을 거역해서  {second} 를 낼 수 없지만, {third}이 풍기는 향기는 바람을 거역해서 사방으로 퍼진다.&quot;,   
              first=&quot;꽃&quot;,    
              second=&quot;향기&quot;,  
              third=&quot;선하고 어진 사람&quot;);    
   
   	
		// : 를 이용해서 포맷하기.
        println!(&quot;10 진수 {}&quot;,   69420);
        println!(&quot; 2 진수 {:b}&quot;, 69420);
        println!(&quot; 8 진수 {:o}&quot;, 69420);
        println!(&quot;16 진수 {:x}&quot;, 69420);
   
   
        // 공백 나타내기.
        println!(&quot;{number:&gt;5}&quot;, number=1);
   
        // 공백 값 지정하기.
        println!(&quot;{number:0&gt;5}&quot;, number=1);
   
        //공백 값을 변수에 지정하기.
        println!(&quot;{number:0&gt;width$}&quot;, number=1, width=5);

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug--display"><a class="header" href="#debug--display">Debug &amp; Display</a></h1>
<p>러스트 내에 <code>std</code> library 에 포함된 타입들은 자동으로 프린트 매서드가 구현되어있다. 
이외의 다른 타입들은 <em>무조건</em> 구현해야만 프린트 할 수 있다. </p>
<p>구현할 수 있는 방법은 기본적으로는 두가지가 존재한다.</p>
<p>바로 Debug 와 Display 이다.</p>
<h3 id="debug"><a class="header" href="#debug">Debug</a></h3>
<p>그 중 Debug에 대해 먼저 알아보자.</p>
<p><code>fmt::Debug trait</code>은 굉장히 사용자 편의성이 좋은 편이다. <code>derive</code> 를 선언하면 자동으로 <code>fmt::Debug</code> 를 구현한다. 
ex) 자바의 애너테이션 개념과 비슷하다고 표현해도 무방할듯..</p>
<p>예제와 같이 알아보자.</p>
<p>참고 - Debug 사용 시, 프린트 매크로에는 항상 {:?} 또는 {:#?} 을 사용하셔야 합니다. </p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {


// 기본 타입들은 프린트가 가능.
let t = &quot;hello_world&quot;;
let tt = 3; 

println!(&quot;프린트 == {t}, {tt}  == 가능&quot;);

//사용자 지정타입, 즉 std library 에서 제공되지 않음 -&gt; 프린트 불가.
struct CanNotPrint(i32);

//아래 코드는 주석을 풀면 에러가 납니다.
//println!(&quot;{:?}&quot;, CanNotPrint(3));


//Debug 선언
#[derive(Debug)]
struct CanPrintWithDebug(i32);

println!(&quot;{:?}&quot;, CanPrintWithDebug(3));


#[derive(Debug)]
struct Person&lt;'a&gt; {
	name: &amp;'a str,
	age:u8
}

let tony = Person { name : &quot;과노&quot;, age : 34 };

//{:?}, {:#?} 비교 
println!(&quot;{:?}&quot;, tony);
println!(&quot;{:#?}&quot;, tony);


}
</code></pre></pre>
<h3 id="display"><a class="header" href="#display">Display</a></h3>
<p>Display 에 대해 알아보자.</p>
<p><code>Debug</code> 가 <code>derive</code> 를 통해 자동으로 프린트를 구현하였다면 <code>Display</code> 는 조금 더 손이 많이 간다. 즉 사용자가 직접 구현해야한다는 말이다. 다시 말하면 프린트하는 포맷을 내 입맛에 맛에 손 볼 수 있다. </p>
<p>예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">  use std::fmt::Display;

  struct PrintWithDisplay(i32);

  impl Display for PrintWithDisplay {
      // Display 를 구현함에 따라 Display 에 존재하는 default 함수를 가져와서 이를 구현한다.

      /*
       *다소 이해가 가지 부분들이 있으리라 생각됩니다만, 앞으로 나올 내용이니 너무 고민마시&gt;  고
       * 추후 배울 내용을 미리 눈으로 익힌다는 느낌으로 보시는 게 좋을 듯 합니다.
       */

      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
          write!(f, &quot;내가 원하는 입맛대로 출력하기. {}&quot;, self.0)
      }
  }

  fn main() {
      let t = PrintWithDisplay(3);     
      // 단순히 {} 만 사용하여도 출력가능 -&gt; Display 구현했기 때문.
      println!(&quot;{}&quot;, t);
  }</code></pre></pre>
<h3 id="비교"><a class="header" href="#비교">비교</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">  use std::fmt::Display;


  #[derive(Debug)]
  struct DebugAndDisplay {
      x: String,
      y: String,
  }


  impl Display for DebugAndDisplay {
      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
          write!(f, &quot;내 기준에서 y가 먼저지! {} 그리고 {}&quot;, self.y, self.x)
      }
  }



  fn main() {
      let t = DebugAndDisplay{ x: &quot;다른 프로그래밍 언어...&quot;.to_string(), y: &quot;러스트&quot;.to_string() }; 

      println!(&quot;Debug  : {:?}&quot;, t);
      println!(&quot;Display : {}&quot;, t);
  }
</code></pre></pre>
<h3 id="참고"><a class="header" href="#참고">참고</a></h3>
<p><code>Vec&lt;T&gt;</code> 타입과 같은 경우는 <code>Display</code> 를 구현할 수가 없는데, <code>제네릭</code>의 경우는 어떠한 포맷으로 구현할지 타입마다 다르기 때문에 애매하다. 따라서 <code>Vec&lt;T&gt;</code> 는 <code>Display</code> 로 구현되지 않는다는 점을 알아두자. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testcase-listiter-개념과-option-개념이-필요함"><a class="header" href="#testcase-listiter-개념과-option-개념이-필요함">TestCase: List(iter 개념과 Option 개념이 필요함)</a></h1>
<p>그렇다면 배열이 있는 <code>struct</code> 일 경우, <code>fmt::Display</code> 로는 어떤 식으로 구현할까?</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">  use std::fmt::Display;


  #[derive(Debug)]
  struct ListVec(Vec&lt;i32&gt;);

  impl ListVec {
      fn new() -&gt; Self {
          ListVec(vec![1,2,3,4,5,6,7])
      }
  }

  impl Display for ListVec {

      // iter() 는 for 문의 형태로 쓰인다는 점에 알아두자.
      // 리턴 타입이 Result 인데, 이는 ? 를 사용할 수 있다는 의미이다. 
      // 간단히 눈으로 익히고 뒤에 자세히 알아보자.

      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
	  
          write!(f, &quot;list start &quot;);     
          for (count, n) in self.0.iter().enumerate() { 
              if count != (self.0.len() - 1) {
	      	write!(f, &quot;{} -&gt; &quot;, n)?;
	      }else{
	      	write!(f, &quot;{}&quot;, n);
	      }
          }

          write!(f, &quot; finished.&quot;)
      }
  }

  fn main(){
      println!(&quot;{}&quot;, ListVec::new());

      println!(&quot;{:?}&quot;, ListVec::new());

  }
</code></pre></pre>
<p>다른 예제를 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
  use std::fmt::Display;

  struct City {
       
       // &amp;'static 에 대해서 후반에 다룰 예정이니 String 포인터 개념이지만 스택에 올라간
       // 데이터라고 생각하고 넘어가자.

      name : &amp;'static str,
      lat : f32,
      lon : f32
  }

  impl Display for City {

      // 여기서 `f` 는 버퍼인데 간단하게 부하를 줄이기 위해 잠시 데이터를 저장하는 공간
      // String 포맷으로 구현하되 이를 버퍼에 저장한다고 생각하자.
      fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {

          let location_of_latitude = if self.lat &gt; 0.0 { 'N' } else { 'S' }; 

          let location_of_longitude = if self.lon &gt; 0.0 { 'E' } else { 'W' };

          write!(f, &quot;location of {} : {:.3}, {}, {:.3}, {}&quot;,
                 self.name, self.lat, location_of_latitude,
                 self.lon, location_of_longitude
                 )
      }
  }



  fn main() {

      let t = City{ name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 };
      println!(&quot;{t}&quot;);

  }


</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitives-원시타입"><a class="header" href="#primitives-원시타입">Primitives, 원시타입</a></h1>
<p>러스트 언어는 타입 지정이 우선시 되어야 한다. 항상 이를 염두하자.</p>
<h3 id="scalar-types"><a class="header" href="#scalar-types">Scalar Types</a></h3>
<ul>
<li>
<p>signed integers: <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code> and <code>isize</code> (pointer size)</p>
</li>
<li>
<p>unsigned integers: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code> and <code>uisze</code>(pointer size)</p>
</li>
<li>
<p>floating point: <code>f32</code>, <code>f64</code></p>
</li>
<li>
<p><code>char</code> Unicode 인 <code>'a'</code>, <code>'α'</code> and <code>'∞'</code> (4 bytes each) </p>
</li>
<li>
<p><code>bool</code> either <code>true</code> or <code>false</code></p>
</li>
<li>
<p>and unit type <code>()</code>, empty typle 이라고 하는데 아래에서 알아보자.</p>
</li>
</ul>
<p>튜플 타입 임에도 불구하고 컴파운드 타입으로 고려되지 않는 것은 하나의 타입으로 지정되어 있기 때문이다.</p>
<h3 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h3>
<ul>
<li>
<p>arrays like <code>[1,2,3]</code></p>
</li>
<li>
<p>tuples like <code>(1, true)</code></p>
</li>
</ul>
<p>타입 지정할 때 숫자는 suffix 로 지정할 수 있다.
숫자는 default 타입이 존재하는데 Int 는 i32, float는 f64 가 있다.
또한 러스트는 타입 infer 시스템을 가지고 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

      let _logical: bool = true;

      let _a_float: f64 = 1.0; // Regular annotation

      let _suffix_integer = 3i32; // Suffix annotation i32

      let _default_float = 3.0; // default f64

      let _default_integer = 7; // default i32                                                               
      //주석을 풀면 에러남.
      //println!(&quot;{default_integer}&quot;);

      // 러스트는 기본적으로 변수가 immutable 이기 때문에 mut 를 변수 앞에 선언할 수 있다.

      let mut can_change = &quot;나는 예전엔 어리석었다.&quot;.to_string(); 

      println!(&quot;{can_change}&quot;);

      can_change = &quot;현재는 무지에서 벗어났다&quot;.to_string();

      println!(&quot;{can_change}&quot;);


      //아래 코드는 주석을 풀면 에러가 난다. 같은 타입에서만 변화만 가능하다.
      //사람이 제 아무리 노력해서 변화한다 한들 다람쥐나 고래가 될 수 없듯이
      //can_change = 3;

      }
</code></pre></pre>
<h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>튜플 타입은 () 으로 지정한다. 
(type1, type2, type3...) 과 같은 방식으로 선언할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
  fn reverse_tuple( pair : (i32, bool) ) -&gt; (bool, i32) {
      let (reverse_bool, reverse_i32) = pair; i32, bool
      (reverse_i32, reverse_bool)
  }


  fn main() {

     let t = (33, true); (i32, bool)
     let result_t = reverse_tuple(t); (bool, i32)

     println!(&quot;{:?}&quot;, result_t);

  }
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-slices"><a class="header" href="#arrays-and-slices">Arrays and Slices</a></h1>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<ul>
<li><code>Array</code> 는 스택 메모리에 인접하게 저장되어 있는 객체들을 말한다. </li>
<li>[] 을 사용하여 선언한다.</li>
<li>[] 의 길이는 컴파일 타임에 알 수 있다(미리 선언되기 때문이며 Array 는 길이 변화가 불가능하기 때문)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
	//배열 선언
	let arrays : [i32; 5] = [1,2,3,4,5];
	let ys : [i32; 500] = [0; 500];

	//배열 안에 데이터 접근
	println!(&quot;{}&quot;, arrays[0]);

}</code></pre></pre>
<h3 id="slices"><a class="header" href="#slices">Slices</a></h3>
<ul>
<li><code>Slices</code> 는 <code>arrays</code> 와 비슷하지만 길이를 컴파일 타임에 알 수 없다. </li>
<li><code>Slice</code> 는 두 단어로된 객체인데, 첫번째 단어는 저장된 데이터를 가르키는 포인터, 두번째 단어는 해당 포인터의 길이(usize)로 표현된다.</li>
</ul>
<p>러스트의 참조 개념과 스트링 슬라이스에 대한 이해는 사실 초보자들에겐 쉽지만은 않다.
스스로도 무지한 상태에서 이를 이해하는데 꽤나 오랜 시간이 걸린 것 같다. 
눈으로 익혀 두고 기회가 되면 러스트 책 또는 다른 곳에서 이해할 수 있길 바란다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>let s = &quot;hello world&quot;.to_string(); 

let world = &amp;hello_world[6..11]; 

<span class="boring">}</span></code></pre></pre>
<img src="example/primitives/string_slice.svg" alt="drawing" width="300">
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<p>커스텀 타입에는 <code>struct</code> 와 <code>enum</code> 그리고 Constants가 있다.</p>
<h3 id="structrues"><a class="header" href="#structrues">Structrues</a></h3>
<p><code>struct</code> 키워드로 생성할 수 있다. </p>
<ul>
<li>Tuple structs, 안에 튜플을 가진 객체이다.</li>
<li>The classic C structs. C언어 스타일의 객체</li>
<li>Unit structs 필드는 존재하지 않는다. Generic 제니릭 부분에서 유용하게 쓰인다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>//튜플 struct
struct Pair(i32, f32);

struct Point {
	x: i32,
	y: f32,
}

struct Unit;


<span class="boring">}</span></code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p><code>enum</code> 키워드로 생성할 수 있다.</p>
<p>*선언된 enum 안에 필드는 struct과 동일하게 여러 타입들이 선언될 수 있다.
*선언된 enum 안에 필드는 C 언어 처럼 0, 1, 2 인덱싱이 가능하다.</p>
<p>type aliases</p>
<p><code>enum</code> 명이 길다면 aliases 선언 가능.</p>
<p>ex)</p>
<pre><pre class="playground"><code class="language-rust edition2021">enum verylongverboseEnum {
	A,
	B
}

type short = verylongverboseEnum;

fn main(){
	let x = short::A;
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testcase-linked-list"><a class="header" href="#testcase-linked-list">TestCase: linked-list</a></h1>
<p>흔히들 사용하는 간단한 링크드 리스트 배열을 구현해보자. 
내용이 어렵기 때문에 설명은 간략하게 할 것이며 눈으로 익히는 정도만 해도 충분하다. </p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[derive(Debug)]
enum List {
    //Box 를 사용하는 것은 메모리를 정확히 알 수 없을 경우 사용한다. 힙에 저장됨.
    // List 가 몇개나 들어갈지 알 수 없기 때문에 Box 사용하며 자세한 내용은 뒤에서 설명하겠다.
    Cons(u32, Box&lt;List&gt;),
    Nil,
}

impl List {
	
    // 배열 첫번째에 숫자를 넣는 경우, 객체 그 자체가 새로 만들어지기 때문에 &amp; 없이 self 변수가 들어간다.
    fn insert_to_fth(self, fth_num: u32) -&gt; Self {
        List::Cons(fth_num, Box::new(self))
    }
	
    // associated function 이라고 하는데 객체의 구현 시, 파라미터가 없이 사용할 수 있는 함수이다. static method 와 비슷한 개념이다.
    fn new() -&gt; Self {
        List::Nil
    }
    
    // 해당 리스트의 길이를 알려주는 함수인데 tail.len() 재귀함수 방식으로 구현한다. 
    // match 와 래퍼런스 개념이 필요한데 눈으로 익히고 추후에 자세하게 설명하겠다.
    // 간단하게 설명하면 객체 자체를 파라미터로 넣으면 해당 객체는 더이상 사용할 수 없게 됨으로 참조하여 사용하며
    // match 사용 시, 러스트 컴파일러는 참조된 것으로 파악해서 match &amp;self 로 쓰지 않아도 &amp;self 된 것 처럼 사용할 수 있다.
    fn len(&amp;self) -&gt; u32 {
        match self {
            List::Cons(_, tail) =&gt; 1 + tail.len(),
            List::Nil =&gt; 0,
        }
    }

    
    fn stringify(&amp;self) -&gt; String {
        match self {
            List::Cons(head, tail) =&gt; {
                    format!(&quot;{}  {} &quot;, head, tail.stringify())
            },
            List::Nil =&gt; {
                format!(&quot;&quot;)
            }
        }
    }
}

fn main() {
    let t_list = List::new();
    println!(&quot;{:?}&quot;, t_list);

    let mut new_list = t_list.insert_to_fth(3);
    println!(&quot;{:?}&quot;, new_list);
    for n in 1..10 {
        new_list = new_list.insert_to_fth(n);
        match &amp;new_list {
            List::Cons(_, ref tail) =&gt; {
                println!(&quot;List : {:?} : len : {:?}&quot;, new_list, tail.len());
            }
            List::Nil =&gt; todo!(),
        }
    }
    let print = new_list.stringify();
    println!(&quot;{}&quot;, print);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">constants</a></h1>
<p>러스트에는 두 종류의 불 변수가 존재한다. </p>
<ul>
<li><code>const</code> : 불변하는 value(주로 사용)</li>
<li><code>static</code> : static 이라는 라이프 타임을 지정하며 <code>mut</code>able 하게 변수 지정할 수 있다. mutable static 변수에 접근하거나 변경하는 것은
<code>unsafe</code> 를 사용한다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">


// constants 타입은 어디든 선언이 가능하다.
static LANGUAGE : &amp;str = &quot;러스트&quot;; // 변수명은 항상 대문자
const THRESHOLD : i32 = 10;

fn main() {
    
    println!(&quot;{LANGUAGE}&quot;);

    println!(&quot;{THRESHOLD}&quot;);
   
    // 불변수에는 재선언 불가능
    // THRESHOULD = 5; 
    // LANGUAGE = &quot;rust&quot;; 

}

</code></pre></pre>
<p><code>static</code> 개념에 대해서는 추후에 자세하게 다룰 예정이다. 눈으로 이런 문법이 있다 정도면
익히고 넘어가면 된다. </p>
<p>개인적인 생각으로는 러스트는 다른 언어에 비해 러닝커브가 까다롭다. 여러번 훑어본다는 느낌으로 전체를 이해하고 이해한 후에 코드를 짜다보면 조금씩 나아진다. Rust! </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variable-bindings변수-바인딩"><a class="header" href="#variable-bindings변수-바인딩">Variable Bindings,변수 바인딩</a></h1>
<p>러스트는 static typing 을 통한 type safety 제공한다. 타입은 변수 선언시 지정할 수 있지만
대부분 컴파일러에 의해 타입이 선언될 수 있다. </p>
<h3 id="mutability"><a class="header" href="#mutability">Mutability</a></h3>
<p>러스트는 기본으로 불변수인데 mut 를 사용하면 수정이 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	

	let last_name = &quot;lee&quot;;
	// 불가능
	// last_name = &quot;kim&quot;;
	
	//mut
	let mut name = &quot;hello&quot;;
	name = &quot;world&quot;;
	println!(&quot;{name}&quot;);
}</code></pre></pre>
<h3 id="scope-and-shadowing"><a class="header" href="#scope-and-shadowing">Scope and Shadowing</a></h3>
<p>러스트에서 Scope 영역은 해당 변수의 드랍 여부를 나타내는 중요한 지표이다. 
(드랍이라는 것은 더 이상 참조가 불가능하며 바로는 아니지만 메모리에 제거 된다는 말이다.)</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
	
	// Scope

	let scope = 1;
	{
	 let inner_scope = 2;

	 println!(&quot;{inner_scope}&quot;);

	}
	// 이 블록 영역이 지나면 호출 불가능, 드랍된다.
	//println!(&quot;{inner_scope}&quot;);
	
	println!(&quot;{scope}&quot;);
	

	//Shadowing

	let shadow = 1;
	
	{
		let shadow = &quot;shadow&quot;;
		println!(&quot;{shadow}&quot;);
	}
	// 같은 이름으로 선언하였지만 드랍되어 쓰일 수 없다.
	println!(&quot;{shadow}&quot;);
}</code></pre></pre>
<h3 id="declare-first-변수-선언과-초기화"><a class="header" href="#declare-first-변수-선언과-초기화">Declare first, 변수 선언과 초기화</a></h3>
<p>러스트는 변수를 선언하고 그 후에 초기화 하는 것이 가능하다. 그러나 초기화하지 않고 사용하는 것은 컴파일 에러를 나타낸다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	//선언
	let declare;
	{
		let a = 2;
		declare = a * a;

	}	
	//위에 초기화값은 블록 안에서도 가능한다. 왜냐하면 변수는 상위에 선언되고 블록 안에서는 상위에 선언된 변수가 value 값만 들어가기 때문이다. (Move 개념_ 추후 설명) 
	println!(&quot;{declare}&quot;);
	
	//선언 후 초기화 작업 없이는 사용 불가능
	//let a_declare;
	//println!(&quot;{a_declare}&quot;);
}
</code></pre></pre>
<h3 id="freezing"><a class="header" href="#freezing">Freezing</a></h3>
<p>데이터가 mut 하게 선언되었다가 다시 immut 로 선언되면 이것을 freez 라고 한다. 
더 이상 mutable 하게 사용이 불가능하기 때문이다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

fn main() {
	let mut number = 3;

	{
	// 해당 변수에 value 값만 들어간다. 쉐도잉으로 새롭게 선언된 변수는 immut 하다.
	let number = number;
	
	//그렇기에 아래와 같은 구문은 불가능하다.
	//number = 1; 

	}
	// 위의 문장들은 블록 영역이 끝이 나면서 드랍되기 때문에 더 이상 쓸모 없게 되며

	// 맨 위 mut number 변수에 영향을 받는다.
	number = 6;

	println!(&quot;{number}&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>러스트 타입 매커니즘</p>
<ul>
<li>기본 타입에 대한 형변환과 정의</li>
</ul>
<ol>
<li>기본형에 대한 형변환</li>
<li>literals</li>
<li>type inference</li>
<li>aliasing </li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="casting_and_literals"><a class="header" href="#casting_and_literals">casting_and_literals</a></h1>
<h3 id="casting"><a class="header" href="#casting">Casting</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let decimal = 65.4321_f32;

    //let integer : u8 = decimal; u8 이라는 타입을 지정하여도 value 값에 지정한 게 아니기 때문에
    //명확하게 표현된 것이라 보기 어렵다.

    let integer = decimal as u8; // value 값에 변환 타입을 명확히 지정
    let character = integer as char;

    // decimal 에서 바로 char 로 변환하는 것은 가능한가
    //let char = decimal as char;  //소수에서는 utf8 로 매칭되는 게 없기 때문에 불가능하다.

    println!(&quot;Casting : {decimal} -&gt; {integer} -&gt; {character}&quot;); // 가능


    // 8비트에서 16이나 32비트로 형변환 하는 것은 문제가 없다. 그렇다면 16비트에서 8비트, 더 적은
    // 비트 수로 변환하는 것은 어떻게 될까
   
    let bit_16 = 300.0_f32;

    let answer = bit_16 as u8;
   
    // unsigned 8, u8은 255 까지 밖에 표현되지 못하기 때문에 300이 나오지 못한다.
    println!(&quot;{answer}&quot;);
  
    // overflow. unsafe 는 자주 사용되진 않지만 시스템 쪽을 구현해야하 할때 종종 사용하는 듯 하다.
    // runtime cost가 존재하기 때문에 완벽히 이해한 후 사용해야한다.
    unsafe {
        // 300.0 is 44
        println!(&quot;300.0 is {}&quot;, bit_16.to_int_unchecked::&lt;u8&gt;());
    }

}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {

    // value 값과 타입을 한번에 지정한 literals
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;
    
    // 타입을 지정하진 않고 사용됨에 따라 타입이 지정됨.
    let i = 1;
    let f = 1.0;

    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inference_and_aliasing"><a class="header" href="#inference_and_aliasing">inference_and_aliasing</a></h1>
<h3 id="inference-타입-추론"><a class="header" href="#inference-타입-추론">Inference 타입 추론</a></h3>
<p>러스트에 존재하는 타입 추론 엔진은 특별한 타입이나 상황을 제외하고는 직접 타입을 지정하지 않아도 된다.</p>
<ul>
<li>변수에 값을 선언하였을 시 추론 가능</li>
<li>변수 선언 후 추후에 값을 지정해도 추론 가능</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let elem = 5; //변수에 값 지정, 타입 추론 가능
	

	let mut vec = Vec::new(); // Array 계열인 빈 벡터 선언, 컴파일러는 아직 타입을 알지 못함. Vec&lt;_&gt; 타입인 상태

	vec.push(elem);
	
	// vec의 타입은 Vec&lt;i32&gt; 가 된다. 러스트는 자연수 default 는 i32 이기 때문이다.
	println!(&quot;{:?}&quot;, vec);
	

	//여기서 알아둬야 할 부분은 선언 후 초기화를 하지 않으면 컴파일 에러가 난다. 컴파일 타임에 메모리의 양을 알 수 없거니와
	//타입 지정 추론이 아예 불가능하기 떄문이다. 
	//만약 변수 선언만 하고 초기화는 하지 않고 싶다 또는 추후에 하고 싶다면 변수 선언 시 타입을 지정하여야 한다. 
	let typed_vec::Vec&lt;i32&gt;;  
	let typed_num::i32; 

	
}
</code></pre></pre>
<h3 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h3>
<p>linux를 조금이라도 써본 사용자라면 alias 가 얼마나 유용한지 알 수 있다. 러스트에서도 비슷한 맥락으로 사용된다. 
타입에 대한 alias 선언을 알아보자. - 추후 많은 타입에 대해서도 alias 가 가능한데, 개념만 알면 자연스럽게 익히게 된다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
type NanoSecond = u64; // u64는 NanoSecond 라는 타입으로 사용할 수 있다.
type Inch = u64; // 러스트에서 Alias 는 UpperCamelCase 를 활용한다.

fn main() {
	
	let nanosec : NanoSecond = 5;

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conversion"><a class="header" href="#conversion">Conversion</a></h1>
<p>앞서 배웠듯이 원시 타입은 casting 을 통해 타입 변환이 가능하다.
나아가 custom types 인 <code>struct</code> 와 <code>enum</code> 에서도 traits 를 사용하면 가능하다. 
이번 챕터에서는 이러한 trait 에 대한 이해와 사용법에 대해 알아본다.</p>
<ul>
<li>
<p>Generic conversion 인 경우 From 과 Into Trait 를 사용한다. </p>
</li>
<li>
<p>String 에서 사용되는 to 와 from Trait 을 사용한다. </p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into">From and Into</a></h1>
<p>From 과 Into 매우 유용하며 개념만 이해한다면 쉽게 사용할 수 있다. </p>
<p>간단하게 설명하고 예제로 알아보자. 
먼저 A 라는 enum 또는 struct 이 존재한다고 하자. 
A 는 B를  가져와서 A 화 할 수 있다.</p>
<p>마찬가지로 B 도 원하면 A 가 될 수 있다. 말이 이상한데 예제로 살펴보자.
앞에서 종종 나왔지만 String::from 과 같은 trait 를 구현한 것이다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Gwano {
    kind: String, 
}


// std::lib 에 구현된 from tait 를 이용하여 gwano Struct 을 구현하였다. 
impl From&lt;String&gt; for Gwano {
    fn from(value : String) -&gt; Self {
        Gwano {
            kind : value,
        }
    }
}


fn main() {
   
   let k = Gwano::from(&quot;good&quot;.to_string()); 

   println!(&quot;{:?}&quot;, k);
   

   //into 는 from 을 구현하면 자동으로 구현된다고 생각하자. 
   //주의해야할 점은 into() 함수 사용 시, 타입을 필수로 지정해야 한다. 그래야 컴파일러가 어떤 타입으로 converting 할지 
   //알 수 있다.

   let kk = &quot;veryGood&quot;.to_string();
   let answer:Gwano = kk.into();
   
   println!(&quot;{:?}&quot;, answer);
}

</code></pre></pre>
<h1 id="tryfrom-and-tryinto"><a class="header" href="#tryfrom-and-tryinto">TryFrom and TryInto</a></h1>
<p>from and into 와 비슷한데, 리턴 값이 Err 일 수 있는 상황에서 유용하다. Result&lt;&gt; 타입은 추후에 자세히 다룬다. 
이런 것이 있다 정도만 알아두자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Gwano {
    kind: String, 
}

// 구현된 tryform trait 을 이용해 gwano 를 impl 한다. 
impl TryFrom&lt;String&gt; for Gwano {
    type Error = ();

    fn try_from(value: String) -&gt; Result&lt;Self, Self::Error&gt; {
        if value == &quot;answer&quot;.to_string() {
            let answer = Gwano {
                kind : value ,
            };
            Ok(answer)
        } else { 
           Err(()) 
        }
    }
}


fn main() {
    
    let check = &quot;answer&quot;.to_string();
    let n_check = &quot;not&quot;.to_string();

    let an1 = Gwano::try_from(check);
    
    println!(&quot;{:?}&quot;, an1);
    let an2 = Gwano::try_from(n_check);
    println!(&quot;{:?}&quot;, an2);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="to-and-from-strings"><a class="header" href="#to-and-from-strings">To and from Strings</a></h1>
<h3 id="converting-to-string"><a class="header" href="#converting-to-string">Converting to String</a></h3>
<p>어떤 타입이든 String 타입으로 변환하는 것은 어렵지 않다. <code>fmt::Display</code> trait 에서 편하게 <code>toString</code> 함수를 제공하기 때문이다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fmt::Display;

struct PhoneNumList {
    num : Vec&lt;i32&gt;,
}

impl Display for PhoneNumList {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;number list -- {:?}&quot;, self.num)
    }   
}


fn main() {
   
    // 폰번호 맨 앞자리 0이 사라지는 이유 알아보기 
    let list = PhoneNumList {
        num: vec![01029166767, 01029166766]
    };

    println!(&quot;{}&quot;, list);



}


</code></pre></pre>
<h3 id="parsing-a-string-문자열-형변환"><a class="header" href="#parsing-a-string-문자열-형변환">Parsing a String, 문자열 형변환</a></h3>
<p>러스트에선 문자열을 형변환 하는 것은 실제로는 까다로운데 String 문자열은 [u8] 형태로 구성되어 있기 때문이다.
그래서인지 러스트에서는 <code>FromStr</code> trait 를 std::lib 에서 여러 타입에 제공하고 있다. 그래서 <code>primative</code> 타입들 중에 <code>FromStr</code> 을 구현한 타입들은 쉽게 형변환이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    // 타입 지정이 필요함. 뭘로 형변환 해야할지 알지 못함.
    let parsed:i32 = &quot;5&quot;.parse().unwrap();
    
    // turbofish syntax, 유용하니 눈 여겨 봐두자.
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    println!(&quot;parse : {parsed}, turbofish : {turbo_parsed}&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>개인적으로 개념을 제대로 암기 후 이해하고 있는 것이 가장 중요하다고 생각한다.
그럼 러스트의 Expressions 을 알아보자.</p>
<p>statements - &quot;구문&quot; 이며 expressions - &quot;표현식&quot; 이라 말한다.</p>
<h3 id="표현과-식"><a class="header" href="#표현과-식">표현과 식</a></h3>
<ul>
<li>
<p>식은 법 식이라는 한자이며 방정식, 등식, 수식 등에 쓰인다. 즉 어떤 것에 대한 표현.</p>
</li>
<li>
<p>구문은 얽을 구에 글월 문이다. 말 그대로 글자들이 나열된 것을 말한다. </p>
</li>
</ul>
<p>이제 간단하게 구분할 수 있다</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let x = 3u32; // 변수에 value 를 바인딩하였다.구문이다.
	
	let y = {}; // 여기서 {} 은 구문일까 식일까? 당연히 구문이다. 리턴 값은 () 

	let z = 3 + x; // 3 + x 는 식이다.

	//그렇다면 러스트에선 구문 안에서 구문과 식을 나눈 것을 알아보자.
	
	let x_ = {
		let t = 3 + x; // 이렇게 뒤에 ; 을 넣어버리면 이것은 끝나지 않았다는 뜻으로 구문으로 정의된다.
		t + 3 // 이 문장은 뒤에 ; 이 없기 떄문에 이 구문 안에서는 식으로 정의되며 x_ 변수에 9가 들어간다. 
	}; 

}
</code></pre></pre>
<p>꽤나 복잡하게 설명하고 복잡한듯 보이지만 익숙해지면 아주 쉽다. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-and-control"><a class="header" href="#flow-and-control">Flow and Control</a></h1>
<ul>
<li>if - else </li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {
    let t = 3;

    let init: i32;

    if t &gt; 3 {
        init = 4;
    } else if t &lt; 3 {
        init = 2
    } else {
        init = 30
    }
    println!(&quot;init value : {init}&quot;);

    let return_value = if init &gt; 40 {
        50
    } else if init == 30 {
        init * 10
    } else {
        init / 10
    };

    println!(&quot;return value : {return_value}&quot;)
}

</code></pre></pre>
<ul>
<li>loop </li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
fn main() {

	let mut t = 3i32;

	loop {
		t += 1;
		if t == 10 {
			println!(&quot;t is finally 10&quot;);
			continue;
		}
		
		if t &lt; 10 {
			println!(&quot;t is not yet 10, t is {}&quot;, t);
		}

		if t == 11 {
			println!(&quot;bye..&quot;);
			break;
		} 
	}
}</code></pre></pre>
<ul>
<li>while </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	let mut n = 1u32;

	while n &lt; 50 {
		if n % 2 == 0 {
		 	println!(&quot;짝 : {n}&quot;);
		}else{
			println!(&quot;홀 : {n}&quot;);
		}
		n += 1;	
	}

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="for-and-iterators"><a class="header" href="#for-and-iterators">for and iterators</a></h1>
<p>for문과 iterators에 대해 알아보자.</p>
<h3 id="for-문"><a class="header" href="#for-문">For 문</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	for n in 1..101 {
		println!(&quot;{n}&quot;);
	}

	for n in 1..=100 {
		
		println!(&quot; 숫자 100까지 출력 {n}&quot;);

	} 

}</code></pre></pre>
<h3 id="iterators"><a class="header" href="#iterators">Iterators</a></h3>
<p>iterators 형은 for문 형태로 적용이 가능한 포맷을 말한다. 다시 말하면 loop 문이 가능하다. 
또한 러스트에는 iter 종류가 3가지 존재한다. </p>
<ul>
<li><code>iter</code> - borrows, 데이터를 참조만 할 수 있다.</li>
<li><code>iter_mut</code> - mutably borrows, 변환 가능하게 참조한다. </li>
<li><code>into_iter</code> - consumes, 러스트에서 데이터에서 끄내온 객체는 더 이상 그 객체의 데이터는 사용이 불가능하다. 
해당 소비된 데이터는 move 이동하였기 때문이다.</li>
</ul>
<h4 id="iter"><a class="header" href="#iter">iter()</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
    let name1 = vec![&quot;hell&quot;, &quot;low&quot;, &quot;world&quot;];

    for n in name1.iter() {
        // 참조로 사용하는 중
        match n {
            &amp;&quot;hell&quot; =&gt; {
                println!(&quot;name : {}&quot;, n);
            }
            _ =&gt; {
                println!(&quot;others&quot;);
            }
        }
    }
}</code></pre></pre>
<h4 id="iter_mut"><a class="header" href="#iter_mut">iter_mut()</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">fn main(){

    let mut name2 = vec![&quot;hell&quot;, &quot;low&quot;, &quot;world&quot;];
    for (index,n) in name2.iter_mut().enumerate() {
        // mutable 하게 사용 가능.
	// *는 ref된 데이터를 온전한 데이터로 사용한다는 것을 의미한다. 즉 온전한 데이터이기 때문에 다른 value 값을 넣을 수 있다.
        *n = match n {
            &amp;mut &quot;world&quot; =&gt; &quot;tony&quot;,
            _ =&gt; if index == 0 {
                &quot;finally&quot;
            }else {
                &quot;i found &quot;
            }
        }

    }
    println!(&quot;{:?}&quot;, name2);

}</code></pre></pre>
<h4 id="into_iter"><a class="header" href="#into_iter">into_iter()</a></h4>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
    
    let name3 = vec![&quot;hell&quot;, &quot;low&quot;, &quot;world&quot;];

    for n in name3.into_iter() {
    	//데이터 이동 중...
        match n {
           &quot;world&quot; =&gt; println!(&quot;hii&quot;),
            _ =&gt; println!(&quot;...&quot;)
        }
    }
    //move, consume 되었기 때문에 더 이상 사용이 불가능하다.
    //println!(&quot;{:?}&quot;, name3);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<p>러스트에서는 C <code>switch</code> 와 비슷한 개념으로 패턴 매치를 제공하는데 기본적인 테크닉을 익히면 아주 유용하게 사용할 수 있다.</p>
<p>간단히 설명하면 value 값을 매칭 시켜 분기를 태울 수 있다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
	let say = &quot;hello&quot;;
	// _ 의미는 else 개념으로 이해하면 된다.
	match say {
		&quot;hello&quot; =&gt; println!(&quot;he said {}&quot;, say),
		_ =&gt; println!(&quot;nothing&quot;)
	}
}
</code></pre></pre>
<p>match Destructure 에 대해 알아보자.</p>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<p>예제는 tuple 로만 표현했지만 struct, enum, array 으로도 destructure 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let tuple_match = (0, 1, 2);
	
	match tuple_match {

		(0, y, z) =&gt; println!(&quot;first is 0, then random y: {}, z :{}&quot; ,y ,z),
		(1, ..) =&gt; println!(&quot;first is 1, then ...&quot;),
		_ =&gt; println!(&quot;I dont care what first number is ..&quot;),
	}
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointersref"><a class="header" href="#pointersref">pointers/ref</a></h1>
<p>포인터와 참조 개념을 알아보자. </p>
<p>일단 매치에서 쓰이는 포인터와 참조 개념에 대해서 알아보자.</p>
<ul>
<li>
<p>참조된 값을 reference, &amp; 로 표현하며 반대로 참조된 값을 참조에서 벗길때는 *을 사용하며 Derefencing 이라고 한다.</p>
</li>
<li>
<p>매치에서 Destructuring 할 떄에는 &amp;, ref 와 ref mut 을 사용한다. </p>
</li>
</ul>
<p>추후 다른 단원에서 이러한 개념에 대해 깊게 다루니 그때 이해하면 되니까 너무 이해하려고 하지말자.</p>
<p>단박에 이해가 되면 좋지만 그렇지 못함으로 반복과 집중을 통해 이해를 높이자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let ref_val = &amp;3;

    // 여기서 ref_val 는 &amp;3 이다.
    match ref_val {
        &amp;v =&gt; println!(&quot;&amp; 를 이용한 match&quot;),
    }

    // &amp;3 -&gt; 3 으로 매치  
    match *ref_val {
        v =&gt; println!(&quot;value 를 dereferencing 함.&quot;)
    }

    
    let not_ref_val = 3;
    
    // 선언 시 변수 앞에 ref 를 추가하여 &amp;변수로 구현할 수 있다.
    let ref change_ref_val = not_ref_val;

    let value = 3;
    let mut mut_value = 3;
    

    match value {
        // value -&gt; &amp;val 로 출력할 수 있다. 
        ref r =&gt; println!(&quot;Create a ref val : {}&quot;, r),
    }

    //mutable 한 value를 ref mut 로 구현 후 dereferencing 하여 변환
    match mut_value {
         ref mut m =&gt; {
            *m += 10;
            println!(&quot;ref mut val : {}&quot;, m)
        }
    }

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="guardsbinding"><a class="header" href="#guardsbinding">Guards/Binding</a></h1>
<h3 id="guards"><a class="header" href="#guards">Guards</a></h3>
<p>매치에서 쓰이는 guard 는 filter 의 기능으로 사용할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	
	let pair = (3, 3);

	println!(&quot;the pair is {:?}&quot;, pair);

	match pair {
		(x, y) if x &gt; y =&gt; println!(&quot;x is bigger than y &quot;),
		(x, y) if x == y =&gt; println!(&quot;x is same as y&quot;),
		_ =&gt; println!(&quot;x is smaller than y&quot;),
	}

}
</code></pre></pre>
<h3 id="binding"><a class="header" href="#binding">Binding</a></h3>
<p>말 그대로 변수에 특정 value 를 @ 을 통해 바인딩 할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn get_value() -&gt; u32 {
	33
}
fn main() {
	// return 값이 u32 이기 때문에 u32 에 대한 모든 수를 매치 시켜줘야 한다. 말이 된다?
	match get_value() {
		n @ 1 ..=19 =&gt; println!(&quot;미성년&quot;),
		n @ 20 ..=30 =&gt; println!(&quot;성인, 이립&quot;),
		n @ 31 ..=40 =&gt; println!(&quot;어른, 불혹&quot;),
		n @ 41 ..=50 =&gt; println!(&quot;지천명&quot;),
		n @ 51 ..=60 =&gt; println!(&quot;이순&quot;),
		n @ 61 ..=70 =&gt; println!(&quot;종심&quot;),
		_ =&gt; println!(&quot;망구&quot;),

	}
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="if-let--while-let"><a class="header" href="#if-let--while-let">if let / while let</a></h1>
<p>match 보다 간결하게 쓸 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
	let optional = Some(7);

	match optional {
		Some(i) =&gt; println!(&quot;use match, value is {}&quot;, i),
		_ =&gt; println!(&quot;none&quot;),
	}

	let use_if_let = Some(7);

	if let Some(i) = use_if_let {
		println!(&quot;use if let, value is : {}&quot;, i);
	} else {
		println!(&quot;none&quot;);
	}
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    
    let mut value = Some(0);
    // 굳이 설명하자면 while let 은 Some(i) 인 형태일 때까지 구문을 실행한다.
    while let Some(i) = value {
        if i  &gt; 9 {
            println!(&quot;got 10!!, quit&quot;);
            value = None
        }else{
            println!(&quot; not reached yet... value is {}&quot;, i);
            value = Some(i+1)
        }

    }
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<ul>
<li>러스트에서 function,함수는 <code>fn</code> 키워드로 선언하며 함수 안에 변수는 타입 지정이 필수이다.</li>
<li>함수에서 리턴 값이 있으면 <code>-&gt;</code> 로 표시하며 그 뒤에 타입을 입력한다. </li>
<li>함수 안에 리턴 값은 구문이 아닌 식으로 표현해야 하기 때문에 <code>;</code>이 없어야 한다. (앞선 챕터 expression 참고)</li>
<li>만약 <code>if</code> 구문으로 인하여 아래 구문들이 실행되기 전에 <code>return</code> 해야 한다면 <code>return</code> 뒤에 <code>리턴값</code>을 입력하면 된다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">//함수 선언
fn make_fn(num1 : i32, num2 : i32) -&gt; i32 {
	num1 * num2  //식, return value 
}


fn no_return_fn(num1 : i32, num2 : i32) -&gt; () {
	println!(&quot;no return fn, 여기선 -&gt; () 입력하였지만 생략 가능. &quot;); // 구문 
}

fn return_value_at_num1(num1 : i32) -&gt; i32 {
	if num1 == 1 {
	 	return num1 * 100
	}else{
		num1 * 0
	}

}

fn main() {
	let num1 = 1;
	let num2 = 3;

	println!(&quot;make_fn : {}&quot;, make_fn(num1, num2));

	no_return_fn(num1, num2);

	println!(&quot;return_value_at_num1 : {}&quot;, return_value_at_num1(num1));

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<h3 id="associated-functions--methods"><a class="header" href="#associated-functions--methods">Associated functions &amp; Methods</a></h3>
<p>러스트에서 Associated fn 과 Methods 라고 불리는 함수가 존재한다. 
자바의 static method 라고 불리는 것이 Associated fn 이다.</p>
<p>객체 생성없이 해당 객체의 함수를 호출할 수 있는 함수를 Associated fn 이라 하며 생성된 객체, 인스턴스의 함수를
method 라 한다. </p>
<p>예를 통해 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Point {
    x : f64,
    y : f64
}

impl Point {
	//Associated fn 객체 생성 없이 호출 가능.
    fn new() -&gt; Point {
        Point { x : 0.0, y : 0.0}
    }

	// method 생성된 객체, 인스턴스에서 호출할 수 있는 함수.
    fn transrate(&amp;mut self, x: f64, y: f64) {
        self.x = x;
        self.y = y;
    }
	// move 개념인데 눈으로만 익히고 넘어가면 곧 자세히 설명할 수 있는 챕터가 나온다. 
    fn drop_point(self) {
        let move_to_here = self;
        println!(&quot;point was dropped&quot;);
    }
}



fn main() {
    
     let mut point = Point::new();
     
     println!(&quot;new : {:?}&quot;, point);
     
     point.transrate(3.3, 3.3);
     
     println!(&quot;transrate : {:?}&quot;, point);

     point.drop_point();
	// 이미 move 된 후 drop 되었기 때문에 해당 인스턴스는 메모리에서 없어짐.
     // println!(&quot;can't call this {:?}&quot;, point);

}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>클로져에 대해 알아보는 시간이다. 클로져는 무엇일까? 모던 언어에서는 클로져를 종종 볼 수 있다.
먼저 예제를 통해 클로져를 알아보자.</p>
<pre><code class="language-rsut  editable">
fn main() {
		
	let x = 3;
	// () 대신 || 사용.
	// 구문이 한 줄이라 {} 생략 가능.
	// 아래 클로져에서 x 는 캡쳐되어 사용 가능.
	let closure = | val:i32 | val + x ;

	println!(&quot; closure fn : {}&quot;, closure(3));	
	

}

</code></pre>
<ul>
<li>input value를 사용하기 위해 <code>()</code> 대신 <code>||</code> 을 사용한다.</li>
<li><code>{}</code> 구문 부분에서 생략 가능, 하지만 구문이 한줄이 아니라면 <code>{}</code> 사용한다. </li>
<li>클로져를 사용 시에는 다른 변수를 사용할 수 있다. Capturing 이라고 표현.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capturing"><a class="header" href="#capturing">Capturing</a></h1>
<p>클로져는 타입을 지정하고 선언하는 데 있어 상당히 자유롭게 작용하며 대부분 컴파일러가 알아서 파악한다. 
즉 캡쳐링 함에 있어 해당 변수를 borrow 할지 mut borrow 할 지, move 할 지 클로져 함수에 따라 컴파일러가 알아서 알아낸다.</p>
<ul>
<li>borrow &amp;T 참조만 하는 경우.</li>
<li>mut borrow &amp;mut T 변환가능하게 참조하는 경우.</li>
<li>T 데이터를 아예 가져오는 경우. </li>
</ul>
<p>크게는 이 세가지로 분류하며 이 경우를 잘 파악하고 인지하고 있어야 러스트를 깊이 있게 이해할 수 있다. </p>
<p>예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let color = String::from(&quot;red&quot;);
    // 캡쳐해서 변수의 값을 가져오는데, 이때는 &amp; 참조로만 사용한다.
    let print = || println!(&quot;참조만 하기 -&gt; {color}&quot;);
    // print() 클로져에서 color 를 참조로만 사용했기 때문에 다른 변수에 참조로 값을 선언할 수 있다.
    let t = &amp;color;

    print();
    // 하지만 color 를 그대로 참조없이 다른 변수에 넣어버리면 더 이상 print() 클로져를 사용할 수
    // 없게 된다.  즉 아래 변수 선언은 컴파일 에러가 난다.
    // let move_color = color;
    print();

    let mut count = 0;
    // inc() 클로져의 경우 count 를 캡쳐 한 후 숫자 1 씩 추가하는 함수인데, 이렇게 하기 위해선
    // 단순히 borrow 가 아닌 &amp;mut 또는 아예 가져와야하는데, 이럴 때에는 &amp;mut 를 컴파일러가 알아서
    // 사용한다.
    let mut inc = || {
        count += 1;
        println!(&quot;&amp;mut 변환가능한 참조 하기 -&gt; increase count by 1, current number is : {count}&quot;);
    };

    inc();
    // inc() 클로져에서 이미 count 변수를 &amp;mut 하게 사용하기 때문에 다른 변수에 선언할 수 없다.
    //let _count_borrowed = &amp;mut count;
    inc();
    inc();

    //카피가 되지 않는 타입으로 선언. 힙에 저장된 변수.
    let movable = Box::new(3);

    //drop 함수는 std::lib 에 존재하는 함수인데, 데이터 객체 그 자체를 필요로 하기 때문에 아예
    //move한다.
    let consume = || {
        println!(&quot;객체를 아예 옮겨버리기 -&gt;  movable : {:?}&quot;, movable);
        drop(movable);
    };

    consume();
    // 그렇기 때문에 아래 변수는 사용될 수 없다. 이미 consume 클로져에서 선언되었고 move했기
    // 때문이다. 모순 발생.
    //println!(&quot;{:?}&quot;, movable);

    let haystack = vec![1, 2, 3];
    
    //move 키워드를 사용하면 캡쳐링한 변수는 클로져로 이동하게 되어 사용할 수 없다.
    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;3));
    //아래 haystack 을 프린트 하는 함수를 사용하면 컴파일 에러가 난다. 
    //println!(&quot;{:?}&quot;, haystack);
    println!(&quot;{}&quot;, contains(&amp;4));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-input-parameters"><a class="header" href="#as-input-parameters">As input parameters</a></h1>
<p>그렇다면 <code>Closure</code> 을 input parameter 로 받을 때에는 타입 지정을 어떻게 해야할까?
<code>std::lib</code> 에 지정된 trait 을 이용하는데 3가지 trait 을 이용하여 타입을 지정한다.</p>
<ul>
<li><code>Fn</code> - &amp;T -&gt; 오직 참조</li>
<li><code>FnMut</code> - &amp;mut T -&gt; 참조 그리고 변환</li>
<li><code>FnOnce</code> - T -&gt; 참조 변환 그리고 이동</li>
</ul>
<p>예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn use_fn&lt;F&gt;(fn_: F)
where
    F: Fn(),
{
    fn_()
}

fn use_fn_mut&lt;F&gt;(fn_mut: &amp;mut F)
where
    F: FnMut(),
{
    fn_mut()
}

fn use_fn_once&lt;F&gt;(fn_once: F)
where
    F: FnOnce(),
{
    fn_once()
}

fn main() {
    

    //Fn 을 사용한 경우
    let x = &quot;just using this value as ref&quot;;
    let fn_closure = || {
        println!(&quot;Fn : use fn as parameter : {x}&quot;);
    };

    use_fn(fn_closure);

    //println!(&quot;Fn : still can use this closure {:?}&quot;, fn_closure());
    

    //FnMut 사용한 경우

    let mut y = &quot;using fn mut and see how it works&quot;.to_string();

    let mut fnmut_closure = || {
        println!(&quot;FnMut : the sentence was -- {}&quot;, y);
        y = &quot;it works&quot;.to_string();
        println!(&quot;FnMut : the sentence changed -- {}&quot;, y);
    };

    use_fn_mut(&amp;mut fnmut_closure);

    //println!(&quot;FnMut : still can use this closure {:?}&quot;, fnmut_closure());

    //fnonce 사용한 경우
    
    let z = &quot;using this value as FnOnce&quot;.to_string();

    let fnonce_closure = || {
        println!(&quot;FnOnce : let's using this value as fnonce.&quot;);
        //두가지 방법으로 이동 시킬 수 있는데, 직접 변수에 캡쳐링 한 값을 넣는 경우
        // let move_this_value_to = z;
        //std::lib 에 있는 drop 함수를 이용해서 메모리에서 드랍 시키는 경우
        drop(z);
    };

    use_fn_once(fnonce_closure);
    //아래 주석을 풀면 컴파일 에러가 난다.
    // println!(&quot;{z}&quot;);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="as-output-parameters"><a class="header" href="#as-output-parameters">As output parameters</a></h1>
<p>인풋 타입으로 클로져를 파라미터로 사용하는 것이 가능한 것 처럼 아웃풋 파라미터로도 사용이 가능하다.
하지만 클로져 자체가 익명함수이기 때문에 반환 값으로 타입을 지정하기가 애매하다. 
이럴땐 trait 로 리턴 값을 지정하면 된다.</p>
<p><code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code> 가 <code>trait</code> 로 구현된 것이기 때문이다. 추후에 <code>trait</code> 챕터에서 자세하게 다룰 예정이니 
눈으로 익히고 넘어가시길 바랍니다.</p>
<p>각 예제 마다 <code>move</code> 키워드를 사용했는데 왜 사용했을까?</p>
<p><code>move</code>와 <code>참조</code> 개념과 관련이 있는데, 블록 안에서는 변수 사용이 가능하지만 블록 밖으로 나가면 해당 변수는 메모리에서 드랍된다. (드랍에 대해서도 추후 챕터에서 나온다.) 
드랍된 변수는 더 이상 사용이 불가능하기 때문에 해당 <code>closure</code>는 변수 사용이 불가능하기에 컴파일 에러가 난다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn create_fn() -&gt; impl Fn() {
    let fn_text = &quot;fn_text&quot;.to_string();

    move || println!(&quot;this is a : {fn_text}&quot;)
}

fn create_fnmut() -&gt; impl FnMut() {
    let fnmut_text = &quot;fnmut_text&quot;.to_string();

    move || println!(&quot;this is a : {fnmut_text}&quot;)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let fnonce_text = &quot;fnonce_text&quot;.to_string();

    move || println!(&quot;this is a {fnonce_text}&quot;)
}

fn main() {
	// return 값이 클로져이다. 클로져를 실행하자. 
    let fn_function = create_fn();
    fn_function();

    let mut fnmut_function = create_fnmut();
    fnmut_function();

    let fnonce_function = create_fnonce();
    fnonce_function();
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="examples-in-std-standard-lib-에-존재하는-예제"><a class="header" href="#examples-in-std-standard-lib-에-존재하는-예제">Examples in std, standard Lib 에 존재하는 예제</a></h1>
<h3 id="iteratorany-iter에-있는-any라는-함수에-대해"><a class="header" href="#iteratorany-iter에-있는-any라는-함수에-대해">Iterator::any, iter에 있는 any라는 함수에 대해</a></h3>
<p>any라는 함수는 해당 iter 객체에서 나온 element 가 예상한 어떤 value 값과 비교하여 맞으면 true 아니면 false 를 반환하는 함수이다.</p>
<p>std::lib 에서는 어떻게 구현했는지 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
//std::lib 에 구현된 iter trait 
pub trait Iterator {
    //해당 iter의 type 을 item 이라 지정한다.
    type Item;
    
    //any 함수는 자신을 파라미터로 받고 클로져도 파라미터로 받는다. return 값은 bool type. 
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        // 클로져에 대한 타입과 return 값으 지정한다. 클로저 파라미터 또한 해당 iter 객체의
        // 아이템인 것을 알 수 있다. 왜 이렇게 하는가?
        F: FnMut(Self::Item) -&gt; bool;
}

fn main() {
    let any_test = vec![1, 2, 3, 4, 5];
    // iter 로 변환할 수 있는데 Vec 타입의 변수를 구현하고
    // any 함수를 호출한다. 이때 any 함수는 파라미터로 자기 자신과 클로져를 받는다는 것을 알 수있다.
    // 호출할 때 자기 자신이 파라미터로 포함되었다. 그럼 클로져만 파라미터로 넣으면 된다.
    // || 를 사용하여 파라미터를 클로져를 구현하고 뒤에 리턴 값인 bool type 이 나올 수 있게 식을
    // 구현한다.
    let answer = any_test.iter().any(|&amp;x| x == 2);

    println!(&quot;{answer}&quot;);
}

</code></pre></pre>
<h3 id="iteratorfind-iter에-있는-find-라는-함수에-대해"><a class="header" href="#iteratorfind-iter에-있는-find-라는-함수에-대해">Iterator::find, iter에 있는 find 라는 함수에 대해</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Iterator {
    //해당 iter의 type 을 item 이라 지정한다.
    type Item;

    fn find&lt;P&gt;(&amp;mut self, p: P) -&gt; Option&lt;Self::Item&gt;
    where
        //find function 의 클로져는 iter 의 아이템을 &amp; 로 받음.
        P: FnMut(&amp;Self::Item) -&gt; bool;

    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool
    where
        //any function 의 클로져는 iter 의 아이템을 &amp; 없이 받음.
        F: FnMut(Self::Item) -&gt; bool;
}

fn main() {
    let string_list = vec![&quot;hi&quot;.to_string(), &quot;bye&quot;.to_string()];
    //iter 를 통해 |x| 는 &amp;string 이 된다
    let answer_any = string_list.iter().any(|x| x == &quot;hi&quot; );
    println!(&quot;{}&quot;, answer_any);
    let str_list = vec![&quot;hi&quot;, &quot;bye&quot;];
    // iter 를 통해 |x| &amp;&amp;str 가 되고  == str에 &amp;를 붙이면 &amp;&amp; 가 되므로 비교 가능
    let str = str_list.iter().any(|x| x == &amp;&quot;hi&quot;);
    println!(&quot;{}&quot;, str);
    let num_list = vec![1,2,3,4,5];
    // iter 를 통해 |x| &amp;i32 가 되고 == i32 에 &amp;를 붙이면 &amp;i32 == &amp;i32 되므로 비교 가능
    let num = num_list.iter().any(|x| x == &amp;3);
    println!(&quot;{}&quot;, num);
    // find fn 는 &amp;를 추가한 item 값을 받는데 이유는 return 해야하기 때문이다.
    // &amp;&amp;string 이 되므로 == &amp;&amp;str 이랑 비교한다.
    let answer_find = string_list.iter().find(|&amp;x| x == &amp;&quot;hi&quot;);
    println!(&quot;{:?}&quot;, answer_find);
    let str_list = vec![&quot;hi&quot;, &quot;bye&quot;];
    //iter() 를 통해 &amp;str 가 되고 find 는 &amp;를 추가한 item 을 받기에 &amp;x 추가한다. 
    let find_str_list = str_list.iter().find(|&amp;x| x == &amp;&quot;hi&quot;);
    println!(&quot;find_str_list : {:?}&quot;, find_str_list);
    let fin_num_list = num_list.iter().find(|&amp;x| x == &amp;3);

    // iter 을 통해 |x| 값은 각 각 &amp;String, &amp;&amp;str, &amp;i32 가 된다. 
    // &amp;str 와 i32 는 Copy type 이다. &amp;x pattern 에 의해 destruct 된다.
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules-모듈"><a class="header" href="#modules-모듈">Modules 모듈</a></h1>
<p>모듈이란 function, structs, traits, <code>impl</code> 블록 또는 다른 모듈 을 포함한 영역을 설명한다.코드의 영역을 나누거나 할 때 쓰인다. </p>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<ul>
<li><code>mod</code> - module 영역 선언</li>
<li><code>super</code> - 상위 단계에서 사용할 수 있도록 선언</li>
<li><code>private</code> - default </li>
</ul>
<p>러스트에서 default 는 private 이며 pub 선언 시 다른 영역에서 사용이 가능하다. 예제를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
pub mod my_mod {
    use self::nested::nested_fn_only_called_by_super_mod;

  
    pub fn test() {
        println!(&quot;hello tony good morning&quot;);
    }

    fn private_fn() {
        println!(&quot;it is private but can called by same module fn&quot;)
    }

    pub fn will_call_private_fn() {
        private_fn();
    }

    mod nested {
  
        fn nested_fn() {
            println!(&quot;nested fn&quot;);
        }

        pub(super) fn nested_fn_only_called_by_super_mod() {
            nested_fn();
        }

    }

    pub fn can_call_nested_fn_can_nested_private_fn() {
        nested_fn_only_called_by_super_mod();
    }

}

fn main() {
    my_mod::test();
    my_mod::will_call_private_fn();
    my_mod::can_call_nested_fn_can_nested_private_fn();
}
</code></pre></pre>
<p>mod 이라고 선언하는 것이 하나의 파일을 만들어 그 안에 작성하는 것과 거의 동일한 역할을 한다. ex)
test.rs 라는 파일 안에 pub hello fn 을 구현하고 현재 파일 내에서 mod test; 하면 해당
모듈(파일내함수) 들을 import 하여 쓰는 것과 동일한다.</p>
<h3 id="struct-visibility-and-use-keyword"><a class="header" href="#struct-visibility-and-use-keyword">Struct Visibility and use keyword</a></h3>
<p>다른 언어에서와 비슷하게 동작한다. 크게 어렵지 않게 이해할 수 있다.</p>
<ul>
<li><code>mod</code> - module 선언</li>
<li><code>associated fn</code> - new function </li>
<li><code>use</code>, <code>crate</code>, <code>as</code> - Alias 사용가능</li>
</ul>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
mod my {
    pub struct OpenBox&lt;T&gt; {
        pub contents : T,
    }

    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        pub fn new(contents: T) -&gt; Self {
            ClosedBox { contents: contents }
        }
    }
}

use crate::my::ClosedBox as CBox;
fn main() {
    let open_box = my::OpenBox { contents: &quot;can put anything, it is public&quot; };
   
    // let closed_box = my::ClosedBox { contents: &quot;can't put anything, it is private&quot; };
    let closed_box = my::ClosedBox::new(&quot;struct can only be created when you use new associated fuction.&quot;);

    let t = CBox::new(&quot;I will call this CBox&quot;);

    println!(&quot;{:?}&quot;, t);
}

</code></pre></pre>
<h3 id="super-and-self"><a class="header" href="#super-and-self">super and self</a></h3>
<ul>
<li>super and self 개념은 자바스크립트나 자바에서 말하는 this == self, super 는 부모 모듈을 말한다. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<ul>
<li>
<p>crate 은 컴파일 유닛 - rustc some.rs 가 실행되면 해당 파일은 crate file 로 여겨진다.</p>
</li>
<li>
<p>crate 은 바이너리 또는 라이브러리 파일로 컴파일되며 default 는 바이너리. <code>--crate-type</code> flag 를 통해 지정도 가능. </p>
</li>
</ul>
<h3 id="creating-a-library-file"><a class="header" href="#creating-a-library-file">creating a library file.</a></h3>
<p>rary.rs 라는 파일 만든 후에 아래 코드를 작성한다. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>pub fn rary_fn() {
	println!(&quot; rary function &quot;);
}

<span class="boring">}</span></code></pre></pre>
<p>shell 에서 라이브러리 타입으로 컴파일한다. 
lib은 default, prefix name 이고 뒤에 붙는 것이 우리가 생성한 파일 이름이다. </p>
<ul>
<li><code>--crate-name</code> 옵션으로 변경 가능.</li>
</ul>
<pre><code class="language-shell">$ rustc --crate-type=lib rary.rs 
$ ls lib*

library.rlib

</code></pre>
<h3 id="using-a-library"><a class="header" href="#using-a-library">Using a Library</a></h3>
<p>rlib 파일을 --extern 이름 지정 = library.rlib 에 추가하여 실행할 파일 추가한다. 
해당 파일에서 라이브러리 사용 가능.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {

	rary::public_fn();

}
</code></pre></pre>
<pre><code class="language-shell">
$ rustc main.rs --extern rary=library.rlib --edition=2021 &amp;&amp; ./main

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code> 공식적으로 러스트에서 지원하는 패키지 매니지먼트 툴이다. </p>
<ul>
<li>Dependency 관리를 쉽게 할 수 있음. <a href="https://crates.io">crates.io</a> - official package registry of rust</li>
<li>유닛테스트 지원</li>
<li>버전관리 용이</li>
</ul>
<p>카고에 대한 자세한 내용은 <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a> 참고하시길 바랍니다.</p>
<h3 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h3>
<ul>
<li>binary project 생성 방법</li>
<li>library project 생성 방법</li>
</ul>
<pre><code class="language-shell">
# A binary
$cargo new foo

# OR A library
$cargo new --lib foo 

</code></pre>
<h3 id="cargo-structure"><a class="header" href="#cargo-structure">Cargo Structure</a></h3>
<ul>
<li>Cargo.toml - config file </li>
<li>src - rs files</li>
</ul>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<h4 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h4>
<ul>
<li>name - 프로젝트 이름</li>
<li>version - 버전 정보</li>
<li>authors - 작성자</li>
<li>dependencies - 추가할 디펜던시를 추가할 섹션 </li>
</ul>
<p>디펜던스 사이트
<a href="https://crates.io">crates.io</a></p>
<pre><code class="language-txt">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # from crates.io 
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # from online repo
bar = { path = &quot;../bar&quot; } # from a path in the local filesystem


</code></pre>
<p>참고 사이트 about Cargo
<a href="https://doc.rust-lang.org/cargo/reference/manifest.html">The Cargo book_format</a></p>
<h4 id="build--run"><a class="header" href="#build--run">build &amp; run</a></h4>
<ul>
<li>cargo build - 디펜덴시 다운로드 및 추가, 빌드</li>
<li>cargo run - 빌드 후 실행</li>
</ul>
<h3 id="conventions-바이너리-파일-실행"><a class="header" href="#conventions-바이너리-파일-실행">Conventions, 바이너리 파일 실행</a></h3>
<ul>
<li>main.rs 파일 외 다른 파일 실행하기 </li>
</ul>
<pre><code class="language-txt">foo
├── Cargo.toml
└── src
    └── main.rs
    └── other
          └── other_main.rs
</code></pre>
<pre><code class="language-shell">
$cargo r --bin other_main

</code></pre>
<p>카고에 대한 내용이 생각보다 방대하고 알아두면 좋은 지식들이 많기에 사이트를 둘러보는 것을 추천한다.</p>
<h3 id="cargo-test--build-scripts"><a class="header" href="#cargo-test--build-scripts">cargo test &amp; Build scripts</a></h3>
<p>추후 자세히 알아보자.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="attributes-속성"><a class="header" href="#attributes-속성">Attributes, 속성</a></h1>
<p>모듈, 크래이트, 아이템 등에 적용되는 것을 말하는데 이 속성에는 metadata 가 들어있어 그 속성이 적용된다.</p>
<ul>
<li>컴파일할 때 조건 적용</li>
<li>크래이트 이름, 버전, 타입 setting</li>
<li>warnings 표시 유무</li>
<li>macros, glob imports 적용</li>
<li>외부 라이브러리와 연결</li>
<li>함수에 unit 테스트라고 표시</li>
</ul>
<p>예제)</p>
<ul>
<li>crate 적용 시 - #![crate_attribute], bash script 처럼 샤뱅 적용. </li>
<li>모듈이나 아이템에 적용 시 -  #[item_attribute] </li>
</ul>
<pre><code class="language-txt">
#[attribute(value, value2)]

#[attribute(value, value2, value3, value4)]

</code></pre>
<h3 id="dead_code"><a class="header" href="#dead_code">dead_code</a></h3>
<p>러스트 코드를 짤 때 unused function 에 대해 warnings 을 나타내는데 꽤나 귀찮을 때도 있다.
이때 dead_code attribute 를 사용하면 표시되지 않는다.</p>
<pre><code class="language-txt">
#[allow(dead_code)]
fn unused_function() {}

</code></pre>
<p>책에서 말하기를 사용되지 않는 코드는 아예 지우는 편을 추천한다. 물론 동의하는 바이다. 같이 일하는 사수가
귀에 딱지가 앉도록 코드 정리가 중요하다고 얘기하고 있는데 감사하게 생각한다.... 많이 배우고 있다.... 
thank to Min 부장님..</p>
<h3 id="cfg"><a class="header" href="#cfg">cfg</a></h3>
<p>Configuration 의 약자이며  OS 체크 시 유용하다.</p>
<ul>
<li>cfg 는 attribute.</li>
<li>cfg! macro </li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">//  attribute를 이용한 os 체크
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
	println!(&quot;yes. running on linux!&quot;);
}
// attribute 
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
	println1(&quot; Not running on linux!&quot;);
}


fn main() {

	are_you_on_linux();
	// 매크로를 사용하여 체크
	if cfg!(target_os = &quot;linux&quot;) {
		println!(&quot; yes yes. It is linux&quot;);
	}

}
</code></pre></pre>
<h3 id="custom"><a class="header" href="#custom">Custom</a></h3>
<p>target_os 와 같은 몇몇은 rustc 에 의해 제공된다. 하지만 입맛대로 생성하여 조건을 맞출 수 있다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
#[cfg(custom_my_condition)]
fn my_custom_condition() {
	println!(&quot; condition met! &quot;);
}


fn main() {
	my_custom_condition();
}
</code></pre></pre>
<p><code>cargo r</code> 하면 컴파일 에러가 나온다. 해당 컨디션을 컴파일러에게 미리 말해주어야 한다.</p>
<pre><code class="language-shell">$ rustc --cfg custom_my_condition main.rs ** ./main 

</code></pre>
<p>해당 컨디션은 컴파일에게 알려지고 컴파일 후 해당 함수가 실행된다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-제네릭"><a class="header" href="#generics-제네릭">Generics, 제네릭</a></h1>
<p>개인적으로 러스트에서 중요하게 생각하는 개념이 있는데 오너쉽, 트레이트, 그리고 제네릭 3가지라 생각한다.
그 중 제네릭에 대해 알아보자. 예제만 잘 숙달하여도 이해하는데 큰 문제는 없다고 생각한다. </p>
<p>말 그대로 제네릭은 포괄적인 타입을 말한다. 그래서 제네릭 타입을 나타낼 때에도 타입을 특정하지 않고 <code>camel case</code> 방식으로 &lt;Aaa, Bbb&gt; 로 표현한다. </p>
<h3 id="functions--implementation"><a class="header" href="#functions--implementation">Functions &amp; Implementation</a></h3>
<ul>
<li>struct 에 제네릭 타입을 사용할 때에는 이름 뒤에 <T> 를 사용한다. </li>
<li>impl 에 사용할 떄에는 impl, Struct 뒤에 사용한다. </li>
</ul>
<p>하나의 struct 으로 여러 타입의 struct 인스턴스 생성이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

#[derive(Debug)]
struct SGen&lt;T&gt; {
    random : T,
}

impl&lt;T&gt; SGen&lt;T&gt; {
    fn get_value(&amp;self) -&gt; &amp;T {
            &amp;self.random
    }
}


fn main() {  
       let gen = SGen { random : 3}; 
        println!(&quot;{:?}&quot;, &amp;gen);
       let gen2 = SGen { random : 3.3};
        println!(&quot;{:?}&quot;, &amp;gen2);
       let gen3 = SGen { random : &quot;hello&quot;.to_string()};
        println!(&quot;{:?}&quot;, &amp;gen3);
       let gen4 = SGen { random : &quot;Hi&quot;};
        println!(&quot;{:?}&quot;, &amp;gen4);
}
</code></pre></pre>
<h3 id="traits"><a class="header" href="#traits">Traits</a></h3>
<p>trait 도 제네릭으로 활용할 수 있다. <code>Drop</code> <code>trait</code> 를 통해 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

#[derive(Debug)]
struct Empty;

#[derive(Debug)]
struct Null;

trait DoubleDrop&lt;T&gt;  {
    fn double_drop(self, _: T);
}

// impl 할 struct 을 제네릭 타입 U 로 추가하였다. 현재 crate 에선 모든 타입이
// double_drop 을 사용할 수 있게 된다. 

impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    fn double_drop(self, _: T) {}
}

fn main() { 
    let e = Empty;
    println!(&quot;{:?}&quot;, e);
    
    let n = Null; 
    println!(&quot;{:?}&quot;, n);

    // double_drop 함수 실행 후 더 이상 n, e는 사용할 수 없게 된다.
    n.double_drop(e);
    // println!(&quot;{:?}&quot;, n);
}

</code></pre></pre>
<h3 id="bounds"><a class="header" href="#bounds">Bounds</a></h3>
<p>제네릭의 타입을 정하고 제한하는 것을 바운드라고 한다.</p>
<p>바운드 표현 방식에 대해 알아보자</p>
<ul>
<li>타입 뒤에 <code>:</code> 후 바운드</li>
<li>리턴 값 지정하기 전에 where 구문을 뒤에 바운드</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">

use std::fmt::Display;

// 타입 뒤에 바로 바운드
fn printer&lt;T: Display&gt;(t: &amp;T) {
    println!(&quot;{}&quot;, t);
}

// 타입 지정 후 리턴 값 넣기 전에 where T : 방법으로 바운드
fn printer_&lt;T&gt;(t: &amp;T)
where
    T: Display,
{
    println!(&quot;{}&quot;, t);
}


fn main() {
   
    //struct 자체에는 display 가 되지 않기에 따로 구현 필요. 
    struct NoDisplayTrait(i32);

    //생성 시점 부터 display 를 구현한 타입만 받을 수 있게 바운드 처리.
    struct NeedDisplayTrait&lt;T: Display&gt;(T);

    let string_p = &quot;tony&quot;.to_string();


    printer(&amp;string_p);


    printer_(&amp;string_p);


    let nodisplay =NoDisplayTrait(3);
    
    // struct 은 display trait 이 구현되지 않았기에 printer 함수 실행 불가.
    
    // printer(&amp;nodisplay);
   
    // vec 타입은 display trait 을 구현하지 않았기에 아예 생성 조차 불가능.

    // let vec_is_not_impl_display = NeedDisplayTrait(vec![1,2,3]);
   


}
</code></pre></pre>
<p>예제를 통해 자세히 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    length: f64,
    height: f64,
}

struct Triangle {
    length: f64,
    height: f64,
}

//trait HasArea 생성 후 함수만 생성
trait HasArea {

    fn area(&amp;self) -&gt; f64;

}


// HasArea 를 impl 한 Rec 
impl HasArea for Rectangle {

	// 함수식 구현
    fn area(&amp;self) -&gt; f64 {

        println!(&quot;this is rectangle&quot;);
        self.length * self.height
    
    }
}

// HasArea 를 impl 한 Tri 
impl HasArea for Triangle {

	// 함수식 구현
    fn area(&amp;self) -&gt; f64 {

        println!(&quot;this is triangle&quot;);
        (self.length * self.height) / 2.0
    
    }
}


// where 를 이용한 바운드
// 하나의 함수를 만들고 제네릭 타입을 받고 바운드 처리 후 
// 해당 trait 를 구현한 타입에 한해서 함수 실행.

fn get_area&lt;T&gt;(objec: &amp;T) -&gt; f64
where
    T: HasArea,
{
    objec.area()
}

fn main() {
    let rec = Rectangle {
        length: 3.0,
        height: 3.0,
    };

    let tri = Triangle {
        length: 3.0,
        height: 3.0,
    };

    let rec_area = get_area(&amp;rec);
    println!(&quot;{:?}&quot;, rec_area);

    let tri_area = get_area(&amp;tri);
    println!(&quot;{:?}&quot;, tri_area);
}
</code></pre></pre>
<h4 id="testcase-empty-bounds"><a class="header" href="#testcase-empty-bounds">Testcase: empty bounds</a></h4>
<p>trait 에 함수가 없어도 유용하게 쓰일 수 있다. 예로 Copy 와 Eq trait 이 그러하다.</p>
<p>예제를 통해 어떻게 타입을 바운드 하는지 알아보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
struct Rectangle {
    length: f64,
    height: f64,
}

struct Korea;
struct China;

trait Hanbok {}

// 이렇게 Korea 란 struct 을 impl 하는 것으로 해당 struct 의 타입은 Hanbok 으로 바운드 된다.
impl Hanbok for Korea {}


// 해당 함수는 Hanbok 이란 타입으로 제한하고 있다. 
fn ownership&lt;T&gt;(_: &amp;T) -&gt; &amp;'static str
where
    T: Hanbok,
{
    &quot;한복&quot;
}

fn main() {
    let k = Korea;
    let c = China;


	// 함수 호출 불가능
    // println!(&quot;{:?}&quot;, ownership(&amp;c));

	// 호출 가능    
    println!(&quot;{:?}&quot;, ownership(&amp;k));
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-items--phantom-type-parameters"><a class="header" href="#associated-items--phantom-type-parameters">Associated items &amp; Phantom type parameters</a></h1>
<p>말 그대로 Associated item 을 제네릭 타입과 결합하여 어떻게 활용할 수 있는지 알아보자.</p>
<p>trait 에서도 다른 제네릭 타입을 받을 수 있으며 이를 활용할 수 있는데, 
아래 예제에서 처럼 제네릭을 선언할 수 있다. 하지만 이렇게 선언해버리면 코드 짜기가 여간 불편한 게 아니다. </p>
<h3 id="associated-items"><a class="header" href="#associated-items">Associated items</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Contains&lt;A, B&gt; {
    ....
}


<span class="boring">}</span></code></pre></pre>
<p>해당 trait 를 impl 할 떄 예제이다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>            // 타입 A, B를 추가해야함 
impl Contains&lt;i32, i32&gt; for SomeThing {


}

   // 해당 trait 을 이용한 함수를 선언할 때에도 A, B, C 타입에 대해서도 
   // 선언해야 한다.  
fn diff&lt;A, B, C&gt;(con : &amp;C) -&gt; i32 
   where C : Contains&lt;A, B&gt;  {
   
   }

<span class="boring">}</span></code></pre></pre>
<p>이러한 문제를 해결해보자.
바로 trait 안에 타입을 선언하는 것이다. 예제를 통해 알아보자.</p>
<pre><code class="language-initrust editable">
	// 해당 trait 안에 A, B 타입 선언
trait Contains {
    type A;
    type B;
    
   	// 함수에 위에서 선언한 타입을 이용 
    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;

    fn first(&amp;self)-&gt; i32;
    
    fn last(&amp;self) -&gt; i32;
}

struct Container(i32, i32);

	// 구현할 struct 내부에서 타입 선언
impl Contains for Container {
    type A = i32;
    type B = i32;

    fn contains(&amp;self, a: &amp;Self::A, b: &amp;Self::B) -&gt; bool {
        self.0 == *a &amp;&amp; self.1 == *b
    }

    fn first(&amp;self)-&gt; i32 {
        self.0
    }

    fn last(&amp;self) -&gt; i32 {
        self.1
    }
}

	// 함수 선언 시에도 하나의 타입만 선언하면 된다.
fn difference&lt;C&gt;(con : &amp;C) -&gt; i32 
    where C : Contains {
        con.last() - con.first()
    }



fn main() {
    let t = 3;
    let tt = 3;

    let c = Container(3, 3);
    let result = c.contains(&amp;t, &amp;tt);
    println!(&quot;{:?}&quot;, result);

    println!(&quot;{:?}&quot;, difference(&amp;c));

}

</code></pre>
<p>기존에는 A = B = C 가 같은 영역 안의 타입으로 지정되었다면,<br />
Associated type 을 활용하면 C 영역 안에 A와 B 타입이 선언된다. 
당연히 C type 을 구현할(impl) 타입에서 A와 B을 선언하니 A, B 타입을 따로 선언할 필요가
없게 된다.</p>
<h3 id="phantom-type"><a class="header" href="#phantom-type">Phantom type</a></h3>
<p>팬텀 타입은 런타임에는 나타나지 않고 컴파일 타임에 나타나 체크하는 타입을 말합니다.
데이터 타입은 제네릭 타입을 파라미터로 활용하여 표시용이나 컴파일 타입에 체크용으로 활용할 수 있습니다.
이러한 타입은 메모리에 어떠한 데이터도 갖고 있지 않으며 런타임에도 아무 영향을 미치지 못합니다.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
use std::marker::PhantomData;

#[derive(PartialEq)]
struct PhantomTuple&lt;A, B&gt;(A, PhantomData&lt;B&gt;);

#[derive(PartialEq)]
struct PhantomStruct&lt;A, B&gt; {
    first: A,
    phantom: PhantomData&lt;B&gt;,
}

// 메모리에 'A' 타입은 지정되어 있지만 'B'는 지정되어 있지 않다.

fn main() {
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);

    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    println!(&quot; tuple 1 == tuple 2 can not be compared because they are different type&quot;);

    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'S',
        phantom: PhantomData,
    };

    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'S',
        phantom: PhantomData,
    };

    // println!(&quot; struct 1 == struct 2 비교할 수가 없다. 이 둘의 타입이 다르기 때문 : {}&quot;, _struct1 == _struct2);
}

</code></pre></pre>
<h3 id="testcase--unit-clarification"><a class="header" href="#testcase--unit-clarification">TestCase : Unit clarification</a></h3>
<p>팬텀타입에 관해 활용 케이스를 알아보자.</p>
<p><a href="https://www.youtube.com/watch?v=Qr9PhKURf2g">영상으로 배우기</a></p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::Add;
use std::marker::PhantomData;


// Add 함수에서 객체가 카피되기 때문에 Clone과 Copy를 구현하였다.
#[derive(Debug, Clone, Copy)]
enum Inch {}

#[derive(Debug, Clone, Copy)]
enum Mm {}



// Length는 Unit 을 제네릭으로 받는 Struct이다. 
// 여기서 팬텀 타입은 타입 체크를 위해 추가한 것.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);


impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
    type Output = Length&lt;Unit&gt;;

	// length Struct 에서 첫번째 값만 연산을 하고 두번째 팬텀데이터는 타입 체크를 위해 활용되기 때문에, PhantomData 라고 추가하여 리턴한다.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // '+' 를 사용하면  Add 함수를 호출한다. 
        Length(self.0 + rhs.0, PhantomData)
    }

}


fn main() {
	    
	    // 동일한 타입만 연산됨. 
    let inch_1: Length&lt;Inch&gt; = Length(3.0, PhantomData);

    let return_inch = inch_1 + Length(12.0, PhantomData);

    println!(&quot;{:?}&quot;, return_inch);

    let mm_1 : Length&lt;Mm&gt; = Length(1000.0, PhantomData); 
    let mm_2 : Length&lt;Mm&gt; = Length(1000.0, PhantomData); 

    
    let return_mm = mm_1 + mm_2; 

    println!(&quot;{:?}&quot;, return_mm);


}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scoping-rules오너쉽-참조-라이프타임"><a class="header" href="#scoping-rules오너쉽-참조-라이프타임">Scoping rules(오너쉽, 참조, 라이프타임)</a></h1>
<p>Scoping rules - ownership 과 borrowing 그리고 lifetimes 에서 중요한 역할을 한다. </p>
<h3 id="part-1---raii-resource-acquistion-is-initialization"><a class="header" href="#part-1---raii-resource-acquistion-is-initialization">part 1 - RAII (Resource Acquistion Is Initialization)</a></h3>
<p>러스트에서 변수는 데이터를 스택에 저장하는 것만 하는 것은 아니다. --&gt; 리소스를 소유하고 있다. 
예로 Box<T> 는 힙에 저장된 메모리를 소유하고 있다. 
러스트는 RAII 를 강요하는데, 특정 객체가 스코프를 벗어나게 되면, 이 객체는 destructor 를
호출하고 소유하고 있던 리소스 또한 없어진다. </p>
<p>이러한 행위는 리소스 누수 버그를 예방하고 수동적으로 메모리를 없앨 필요가 없다. 
예제를 통해 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn create_box() {
    // Allocate an integer on the heap, 힙에 지정 i32 type 
    let _box1 = Box::new(3i32); 

    // `_box1` is destroyed here, and memory gets freed, scope 가 끝나는 시점에서 메모리에서 없어짐. 
}


fn main() {

    // Allocate an integer on the heap, 힙에 i32 타입 지정
    let _box2 = Box::new(5i32);


    // A nested scope:  scope 만들기. 
    {
        // Allocate an integer on the heap, scope 안에서 힙에 i32 타입 지정
        let _box3 = Box::new(4i32);

        // `_box3` is destroyed here, and memory gets freed, scope 끝나는 시점에서 destructor 호출 -&gt; drop 
    }

    // Creating lots of boxes just for fun
    // There's no need to manually free memory!,

    //1000 개를 힙에 저장시키지만 단 한 개도 남지 않는다. 
    
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2` is destroyed here. 


}
</code></pre></pre>
<h3 id="part-2-destructor"><a class="header" href="#part-2-destructor">part 2 Destructor</a></h3>
<p>스코프를 벗어날 때 호출되는 destructor 는 러스트가 제공하는 <code>Drop</code> trait 에 의해 실행된다.
자동으로 실행되며 따로 코드를 impl 할 필요는 없지만 필요하다면 구현할 수도 있다. 
변수가 scope 를 벗어나려는 순간, destructor 는 호출되며 drop 이 실행된다. </p>
<pre><pre class="playground"><code class="language-rust edition2021">
    // part 2 
    struct ToDrop;
    impl Drop for ToDrop {
        fn drop(&amp;mut self) {
            println!(&quot;이 객체는 dropped 된다.&quot;);
        }
    }
    fn main() {

    let x = ToDrop;
    println!(&quot;곧 드랍될 예정&quot;);

}

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-move-borrowing"><a class="header" href="#ownership-move-borrowing">Ownership, Move, Borrowing</a></h1>
<h3 id="part-1-오너쉽-그리고-이동-ownership-and-moves"><a class="header" href="#part-1-오너쉽-그리고-이동-ownership-and-moves">part 1 오너쉽 그리고 이동 (Ownership and moves)</a></h3>
<p>메모리에 저장된 리소스는 오직 한 변수만을 오너로 삼는다. 참고할 것은 모든 변수가 리소스를 소유하고 있는 것은 아니다. 레퍼런스를 가질 때도 있기 때문이다. </p>
<p><code>let x = y</code>를 선언하거나 foo라는 함수에 <code>foo(x)</code> 를 적용하였을 시에는 오너쉽이 이동하게 된다. 
y는 x 변수 안으로, 함수에서 x는 foo라는 함수 안으로 이동.</p>
<p>러스트에서는 이러한 이동을 <code>move</code>라고 얘기한다. </p>
<p>이렇게 이동하게 된 값, 즉 y나 함수에서 사용된 x값은 더 이상 사용할 수 없다. 
이렇게 하면 dangling pointers 를 예방할 수 있다. </p>
<h3 id="part-2-변환-mutability"><a class="header" href="#part-2-변환-mutability">part 2 변환 (Mutability)</a></h3>
<p>오너쉽이 다른 변수로 이동하였을 때, 변환타입(immutable -&gt; mutable) 변경이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span> let immut_box = Box::new(5u32);

 let mut mut_box = immut_box;

<span class="boring">}</span></code></pre></pre>
<h3 id="part-3-부분-이동partial-moves"><a class="header" href="#part-3-부분-이동partial-moves">part 3 부분 이동(Partial moves)</a></h3>
<p>변수를 destructuring 할 때, <code>by-move</code>, <code>by-reference</code> 패턴 바인딩이 동시에 가능하다. 
다만 이렇게 할 때, 부분적으로 변수가 이동하게 된다. 즉 변수의 한 부분이 이동할 때 다른 한 부분은 변수에 머물게 된다. 
이런 경우는 해당 변수는 전체로써 사용은 불가능하지만 부분적으로는 사용이 가능하다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {


     #[derive(Debug)]
     struct Person {
         name : String,
         age : Box&lt;u8&gt;
     }
      
     let person = Person { name: String::from(&quot;Tony&quot;), age: Box::new(35) };
    
     let Person { name, ref age } = person;
   
     println!(&quot;what is your name : {:?}&quot;, name);
     let name_move = name;
    
     println!(&quot;{:?}&quot;, name_move);
    
     println!(&quot;{:?}&quot;, person.age);
     // println!(&quot;{:?}&quot;, person); // 전체 객체로는 사용이 불가능
}
</code></pre></pre>
<h3 id="part-4-빌림-borrowing"><a class="header" href="#part-4-빌림-borrowing">part 4 빌림 (Borrowing)</a></h3>
<p>대부분 데이터에 접근할 때 오너쉽을 가져와서 사용하지 않는다. 이때 러스트에서는 빌림 메커니즘을 이용한다(borrowing mechanism). 
값을 (<code>T</code>) 를 그대로 던져주는 것이 아닌 (<code>&amp;T</code>) 를 사용한다.</p>
<p>러스트 컴파일러는 정적인 상태에서도 (borrow checker 를 통해) 우리가 사용 중인  reference 에 대해 항상 값이 존재하는 것을 보장한다. 
즉 참조값이 존재한다는 것은 해당 객체가 없어지는 않는다는 것이다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {


     fn eat_box_i32(boxed_i32 : Box&lt;i32&gt;) {
         println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
     }
   
     fn borrow_i32(borrowed_i32 : &amp;i32) {
         println!(&quot;This int is : {}&quot;, borrowed_i32);
     }
   
     let boxed_i32 = Box::new(5_i32);
     let stacked_i32 = 6_i32;
     
     borrow_i32(&amp;boxed_i32);
     borrow_i32(&amp;stacked_i32);
   
     {
         let _ref_to_i32 = &amp;boxed_i32;
         println!(&quot;{:?}&quot;, _ref_to_i32);
     } 
     // &amp;boxed_i32 값은 _ref_to_i32 로 이동하였지만 {} 스쿠핑 룰에 의해 참조값은 드랍된다. 
     // 온전한 값으로 다시 사용 가능.
    eat_box_i32(boxed_i32);
   }
</code></pre></pre>
<h3 id="part-5-변환-mutability"><a class="header" href="#part-5-변환-mutability">part 5 변환 (Mutability)</a></h3>
<p>변환 데이터 (Mutable data) 는 <code>&amp;mut T</code> 를 이용하여 mutably borrowed 가 가능하다. 이를 <em>mutable reference</em> 라 하며 참조값에 대해 읽기/쓰기 접근이 가능하다. 반대로 <code>&amp;T</code> 는 immutably borrowed 가 가능하며 <em>immutable reference</em> 하며 참조값에 대해 읽기 접근만 가능하다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">

fn main() {
  
    struct Book {
        author : &amp;'static str,
        title : &amp;'static str,
        year : u32,
    }

    fn borrow_book(book : &amp;Book) {
        println!(&quot;immutably borrowed {} - {} edition&quot;, book.title, book.year);
    }

    fn new_edition(book : &amp;mut Book) {
        book.title = &quot;Rust란&quot;;
        book.year = 2014;
        println!(&quot;mutably borrowed {} - {} edition&quot;, book.title, book.year);
    }

    let mut immutabook = Book {
        author: &quot;tony&quot;,
        title: &quot;rust란&quot;,
        year: 2020,
    };


    borrow_book(&amp;immutabook);

    new_edition(&amp;mut immutabook);

}
</code></pre></pre>
<h3 id="part-6-the-ref-pattern"><a class="header" href="#part-6-the-ref-pattern">part 6 The ref pattern</a></h3>
<p>pattern matching 이나 <code>let</code> 바인딩을 이용해 destructuring 할 때, <code>ref</code>는 해당 필드를 참조값으로 가져올 수 있다.
아래 예제를 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
#[derive(Clone, Copy)]
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    let c = 'Q';

    let ref ref_c1 = c;
    let ref_c2 = &amp;c;


    println!(&quot;ref_c1 와 ref_c2 는 값이 같다.  {}&quot;, *ref_c2 == *ref_c1);

    let point = Point { x: 3, y: 3 };

    let _copy_of_x = {
        let Point{ x : ref ref_to_x, y : _ } = point;
    };

    // mutable copy of point
    let mut mutable_point = point;

    {
        let Point { x:_, y: ref mut mut_ref_to_y } = mutable_point;

        *mut_ref_to_y = 30;
    }

    println!(&quot; point is ( {}, {})&quot;, point.x, point.y );

    println!(&quot; mutable_point is ( {}, {})&quot;, mutable_point.x, mutable_point.y );


    // 포인터를 포함하는 mutable 튜플
    let mut mutable_tuple_with_pointer = (Box::new(5u32), 3u32);

    {
        let (_, ref mut val) = mutable_tuple_with_pointer;
        *val = 30u32;

    }

    println!(&quot;mutable_tuple_with_pointer : ( {}, {} ) &quot;, mutable_tuple_with_pointer.0, mutable_tuple_with_pointer.1);


}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<h3 id="part-1-라이프타임"><a class="header" href="#part-1-라이프타임">part 1 라이프타임</a></h3>
<p>러스트에서는 borrow checker가 존재. 이 borrow check는 borrow한 값을 보장한다.
여기서 보장한다는 말은 라이프타임의 시작과 끝을 보장한다는 말이다.</p>
<p>예제를 통해 살펴보자.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
 fn main () {

 let i = 3; // 라이프 타임 i 시작.

 {
     let borrow1 = &amp;i; // 'borrow1'  라이프타임 시작.

     println!(&quot;borrow1 : {}, 라이프 타임 끝 &quot;, borrow1);
 }
 {
     let borrow2 = &amp;i; // 'borrow1'  라이프타임 시작.

     println!(&quot;borrow2 : {}, 라이프 타임 끝 &quot;, borrow2);
 }

 }  // 라이프타임 i 끝.</code></pre></pre>
<h3 id="part-2-explicit-annotation-명확한-선언"><a class="header" href="#part-2-explicit-annotation-명확한-선언">part 2 Explicit annotation, 명확한 선언</a></h3>
<p>참조한 값에 라이프타임 선언이 필요하다.
생략이 가능한 부분이 많은데, 생략이 불가능한 부분에서 사용한다.</p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> foo&lt;'a&gt;
// foo 는 라이프타임 파라미터 `'a` 를 갖는다.
<span class="boring">}</span></code></pre></pre>
<ul>
<li>클로져에서 라이프타임을 사용할 때 제네릭과 동일한 방법으로 표기한다.</li>
<li>foo&lt;'a&gt; 에서 foo는 <code>'a</code>  보다 라이프타임이 짧다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
 fn main() {
   
   fn fn_life_time_longer&lt;'a&gt;() {
         let t = 3;

         // let lifetime_valie: &amp;'a i32= &amp;t;
         // t 는 함수에 지정된 라이프타임보다 더 일찍 드랍되기 때문에 사용이 불가능하다.
     }
 }</code></pre></pre>
<h3 id="part3-functions"><a class="header" href="#part3-functions">part3 Functions</a></h3>
<ul>
<li>함수에서 사용된 참조값은 지정된 라이프타임 값이 존재해야 한다. 단 생략 가능한 경우는 제외.</li>
<li>함수에서 사용된 참조값 중에 리턴될 참조 값은 input 된 파라미터와 동일한 라이프 타임 참조값을 가지고 있어야 하거나 스태틱이여야 한다.</li>
<li>input 없이 참조값을 리턴하는 것은 있을 수 없는 일이다.( 참조할 값이 없기 때문)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"> fn main() {
	// 동일한 라이프타임 소유
     fn return_lifetime_str_after_compare&lt;'a&gt;(a : &amp;'a str, b : &amp;'a str) -&gt; &amp;'a str {
         if a.len() &gt; b.len() {
            return a
         }
         b
     }

     let a = &quot;hi&quot;;
     let b = &quot;tony&quot;;
     let result = return_lifetime_str_after_compare(a, b);

     println!(&quot;{}&quot;, result);

 }</code></pre></pre>
<h3 id="part4-bounds"><a class="header" href="#part4-bounds">part4 Bounds</a></h3>
<ul>
<li><code>T: 'a</code> : All references in <code>T</code> must outlive life time `a. </li>
<li><code>T: Trait + 'a </code> : Type T must implement trait <code>Trait</code> and all references in <code>T</code> must outlive 'a.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
 use std::fmt::Debug;
 fn main() {
     #[derive(Debug)]
     struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);

     fn print&lt;T&gt;(t: T)
     where
         T: Debug,
     {
         println!(&quot;print which impl Debug trait : {:?}&quot;, t);
     }

     fn print_ref&lt;'a, T&gt;(t: &amp;'a T)
     where
         T: Debug + 'a,
     {
         println!(&quot; print wich impl Debug and 'a : {:?}&quot;, t);
     }

     let st = &quot;tony&quot;;
     let t = Ref(&amp;st);

     print_ref(&amp;t);
     print(&amp;t);
 }</code></pre></pre>
<h3 id="part-5-coercion"><a class="header" href="#part-5-coercion">part 5 Coercion</a></h3>
<ul>
<li>A longer lifetime can be coerced into a shorter one. </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
     first * second
}

// 'a 는 'b 와 동일한 라이프타임 이라는 의미 -&gt; 'b 로 output 를 내기 때문에
// first 를 return 하든 second 를 return 하든 관계 없음
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, second: &amp;'b i32) -&gt; &amp;'b i32 {
     first
}

fn main() {
     let a = 3i32;
     let b = 6i32;

     println!(&quot;{}&quot;, multiply(&amp;a, &amp;b));

     println!(&quot;{}&quot;, choose_first(&amp;a, &amp;b));
 }
</code></pre></pre>
<h3 id="part-6-static"><a class="header" href="#part-6-static">part 6 Static</a></h3>
<ul>
<li>reserved name <code>'static</code> </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span> let s: &amp;'static str = &quot;hello tony&quot;;

 fn generic&lt;T&gt;(x: T) where T: 'static {}
<span class="boring">}</span></code></pre></pre>
<p>위의 두 코드의 차이점을 알아보자.</p>
<h4 id="reference-lifetime"><a class="header" href="#reference-lifetime">Reference lifetime</a></h4>
<p><code>'static</code> 이라고 표시된 데이터는 프로그램이 실행될 동안 항상 존재한다. 물론 coercion 규칙도 적용되어 shorter 라이프타임으로도 쓰일 수 있다.<br />
변수를 <code>'static</code> 라이프타임으로 만들 수 있는 방법이 두 가지가 존재한다. 그리고 이 데이터들은 read-only memory of the binary 이다. </p>
<ul>
<li>Make a constant 변수에 <code>static</code> 선언하기. </li>
<li>Make a <code>string</code> literal -&gt; <code>&amp;'static str</code> type </li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>static NUM:i32 = 18;

fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM 
}
<span class="boring">}</span></code></pre></pre>
<h4 id="trait-bound"><a class="header" href="#trait-bound">Trait bound</a></h4>
<p>트레이트 바운드에서 <code>T: 'static</code> 의 뜻은 <code>static</code> 이 아닌 레퍼런스는 허용하지 않는다는 뜻이다.<br />
즉 특정 데이터에서 참조값을 준 데이터는 허용되지 않고 <code>static</code> 이거 owned data 여야 한다. </p>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use std::fmt::Debug;

fn print_it(input : impl Debug + 'static ) {

	println!(&quot;static value : {:?}&quot;, input );

}

<span class="boring">}</span></code></pre></pre>
<h3 id="part-7-elision"><a class="header" href="#part-7-elision">part 7 Elision</a></h3>
<p>라이프타임 룰은 꽤나 규칙적이고 자주 볼 수 있기 때문에 borrow checker 에서 생략 가능 하도록
허용한다. 이를 elision 이라 한다. </p>
<ul>
<li>first - 모든 래퍼런스 파라미터에 라이프타임이 추가된다. </li>
<li>second - 만약 input 파라미터가 하나라면 output 값에도 동일한 라이프타임 파라미터가 적용된다. </li>
<li>third - 만약 multiple input 라이프타임 파라미터를 갖고 그 중 하나가 <code>&amp;self</code> 또는 <code>&amp;mut self</code>
라면 <code>self</code>의 라이프타임이 output 라이프타임 파라미터에 적용된다. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits-1"><a class="header" href="#traits-1">Traits</a></h1>
<h3 id="part1-traits"><a class="header" href="#part1-traits">part1 Traits</a></h3>
<ul>
<li>
<p><code>trait</code> 는 함수의 집합이라고 볼 수 있다. 또한 선언된 함수들은 함수들 끼리 서로 호출할 수 있다.</p>
</li>
<li>
<p>선언된 함수의 집합들은 어떤 데이터 타입에서도 implement 할 수 있다.</p>
</li>
</ul>
<h3 id="part2-derive"><a class="header" href="#part2-derive">part2 Derive</a></h3>
<ul>
<li>러스트 컴파일러는 <code>#[derive] attribute</code> 라는 선언을 이용해서 trait 을 이용할 수 있다.</li>
<li>또한 직접 <code>#[derive]</code> 말고 <code>trait</code> 을 직접 구현할 수 있다.</li>
</ul>
<p>종류</p>
<ul>
<li>비교 traits : <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code></li>
<li><code>Clone</code>, T 라는 객체를 &amp;T 객체를 통해 Copy.</li>
<li><code>Copy</code>, Move 대신에 해당 type 을 Copy 한다.</li>
<li><code>Hash</code>, to compute a hash from &amp;T.</li>
<li><code>Default</code>, to create an empty instance of a data type.</li>
<li><code>Debug</code>, to format a value using the <code>{:?}</code> formatter.</li>
</ul>
<h3 id="part2-returning-traits-with-dyn"><a class="header" href="#part2-returning-traits-with-dyn">part2 Returning Traits with dyn</a></h3>
<p>함수에서 <code>return</code> 타입을 지정할 때에는 명확한 타입이 필요하다. 그렇지 않으면 컴파일 타임에 <code>return</code> 타입에 사이즈를 알 수 없기 때문이다. 그렇다면 <code>trait</code> 타입은 어떻게 리턴할 수 있는가? 박스 타입을 이용하면 가능하다. 박스 타입은 레퍼런스이며 힙에 저장된 메모리이다. 레퍼런스는 사이즈를 알 수 있기 때문에 박스로 감싸면 <code>return</code> 이 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::fmt::Debug;
trait Human {
    fn get_name(&amp;self) -&gt; &amp;str;
 }

#[derive(Debug)]
struct Tony {
     name: String,
 }

 #[derive(Debug)]
 struct Hee {
     name: String,
 }

 impl Human for Tony {
     fn get_name(&amp;self) -&gt; &amp;str {
         &amp;self.name
     }
 }

 impl Human for Hee {
     fn get_name(&amp;self) -&gt; &amp;str {
         &amp;self.name
     }
 }

 fn get_struct_name&lt;T&gt;(n: T) -&gt; Box&lt;dyn Human&gt;
 where
     T: Human,
 {
     if n.get_name() == &quot;gwano&quot; {
         Box::new(Hee {
             name: &quot;hee&quot;.to_string(),
         })
     } else {
         Box::new(Tony {
             name: &quot;gwano&quot;.to_string(),
         })
     }
 }


 fn main() {
     let t = Tony {
         name: &quot;gwano&quot;.to_string(),
     };
     let h = Hee {
         name: &quot;hee&quot;.to_string(),
     };

     println!(&quot;{:?}&quot;, get_struct_name(t).get_name());
     println!(&quot;{:?}&quot;, get_struct_name(h).get_name());
 }
</code></pre></pre>
<h3 id="part3-operator-overloading"><a class="header" href="#part3-operator-overloading">part3 Operator Overloading</a></h3>
<p><code>연산자</code> 는 <code>trait</code> 을 통해 Overloading이 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::ops::Add;

#[derive(Debug)]
struct Bar;
#[derive(Debug)]
struct Foo;
#[derive(Debug)]
struct FooBar;
#[derive(Debug)]
struct BarFoo;

impl Add&lt;Foo&gt; for Bar {
     type Output = BarFoo;

     fn add(self, rhs: Foo) -&gt; BarFoo {
         BarFoo
     }
 }

 impl Add&lt;Bar&gt; for Foo {
     type Output = FooBar;

     fn add(self, rhs: Bar) -&gt; Self::Output {
         FooBar
     }
 }
 fn main() {
     let t = Bar.add(Foo);

     let tt = Foo + Bar;
     println!(&quot;{:?}&quot;, tt);
     println!(&quot;{:?}&quot;, t);
 }</code></pre></pre>
<h3 id="part4-drop"><a class="header" href="#part4-drop">part4 Drop</a></h3>
<p><code>Drop</code> trait 는 <code>drop</code> 함수만을 가지고 있으며 해당 객체가 <code>scope</code> 에서 벗어날 때 자동으로
실행되는 함수이다. <code>Drop</code> 을 사용하는 이유는 해당 자원을 Free 시키기 위함이다.
<code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, and <code>Process</code> 타입들이 대표적으로 <code>Drop Trait</code> 을 implement 한 것이다. 또한 <code>Drop trait</code> 은 수동적으로도 implement 하는 것이 가능하다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Droppable {
     name : &amp;'static str,
 }

 impl Droppable {
     fn new(name : &amp;'static str) -&gt; Self  {
         Droppable { name }
     }
 }

 impl Drop for Droppable {
     fn drop(&amp;mut self) {
        println!(&quot;will drop this name of struct : {:?}&quot;, self.name);
     }
 }


 fn main() {
     let a = Droppable::new(&quot;A&quot;);

     {
         let b = Droppable::new(&quot;B&quot;);
         {
             let c = Droppable::new(&quot;C&quot;);
         }
     }

     drop(a); // 직접 드랍하기.
 }</code></pre></pre>
<h3 id="part5-iterators"><a class="header" href="#part5-iterators">part5 Iterators</a></h3>
<p>iter Trait 를 구현하기 위해서는 <code>next</code> 요소만 구현하면 된다.
또는 arrays 나 ranges 의 경우는 자동으로 구현됨.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Fibonacci {
     curr: u32,
     next: u32,
 }

impl Iterator for Fibonacci {
     type Item = u32;

     fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
         let new_next = self.curr + self.next;

         self.curr = self.next;
         self.next = new_next;

         Some(self.curr)
     }
 }

 fn fibonacci() -&gt; Fibonacci {
     Fibonacci { curr: 0, next: 1 }
 }

 fn main() {
     for  i in fibonacci().take(4) {
         println!(&quot;&gt; {}&quot;, i);
     }

 }</code></pre></pre>
<h3 id="part6-impl-trait"><a class="header" href="#part6-impl-trait">part6 impl Trait</a></h3>
<p><code>impl Trait</code> 은 보통 아래 두 가지 방법으로 쓰일 수 있다.</p>
<ul>
<li>파라미터</li>
<li>리턴 타입</li>
</ul>
<h4 id="파라미터-타입으로-쓰일-경우"><a class="header" href="#파라미터-타입으로-쓰일-경우">파라미터 타입으로 쓰일 경우</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn parse_csv_documnet&lt;R: std::io::BufRead&gt;(src : R) {}

fn parse_csv_documnet_using_impl(src : impl std::io::BufRead) {}</code></pre></pre>
<h4 id="리턴-타입으로-쓰일-경우"><a class="header" href="#리턴-타입으로-쓰일-경우">리턴 타입으로 쓰일 경우</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::iter;
use std::vec::IntoIter;

// This function combines two `Vec&lt;i32&gt;` and returns an iterator over it.
// Look how complicated its return type is!
 fn combine_vecs_explicit_return_type(
     v: Vec&lt;i32&gt;,
     u: Vec&lt;i32&gt;,
 ) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
     v.into_iter().chain(u.into_iter()).cycle()
 }

// This is the exact same function, but its return type uses `impl Trait`.
// Look how much simpler it is!
 fn combine_vecs(
     v: Vec&lt;i32&gt;,
     u: Vec&lt;i32&gt;,
 ) -&gt; impl Iterator&lt;Item=i32&gt; {
     v.into_iter().chain(u.into_iter()).cycle()
 }

// Returns a function that adds `y` to its input
// clouse 는 이름이 없는 콘크리트 타입을 가진다. impl Fn(타입) 으로 지정.
 fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
     let closure = move |x: i32| { x + y };
     closure
 }

//you can also use impl Trait to return an iterator that uses map or filter closures. This makes
//using map and filter easier. Because closure types don't have names, you can't write out an
//explicit return type if your function returns iterators with closures. But with impl Trait you
//can do this easily

 fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
     numbers
         .iter()
         .filter(|x| x &gt; &amp;&amp;0)
         .map(|x| x * 2)
 }

 fn main() {
     let plus_one = make_adder_function(1);
     assert_eq!(plus_one(2), 3);

     let singles = vec![-3, -2, 2, 3];
     let doubles = double_positives(&amp;singles);
     assert_eq!(doubles.collect::&lt;Vec&lt;i32&gt;&gt;(), vec![4, 6]);
 }</code></pre></pre>
<h3 id="part6-supertraits"><a class="header" href="#part6-supertraits">part6 Supertraits</a></h3>
<p>러스트에는 &quot;inheritance&quot; 가 존재하지 않지만 <code>trait</code> 에 또 다른 <code>trait</code> 을 구현할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust edtiable edition2021">

 trait Person {
     fn name(&amp;self) -&gt; String;
 }

 trait Student: Person {
     fn university(&amp;self) -&gt; String;
 }

 trait Programmer {
     fn fav_language(&amp;self) -&gt; String;
 }

 trait ComSciStudent: Programmer + Student {
     fn git_username(&amp;self) -&gt; String;
 }

 struct A;

 impl Person for A {
     fn name(&amp;self) -&gt; String {
         &quot;gwano&quot;.to_string()
     }
 }

 impl Student for A {
     fn university(&amp;self) -&gt; String {
         &quot;kyunghee_uni&quot;.to_string()
     }
 }

 impl Programmer for A {
     fn fav_language(&amp;self) -&gt; String {
         &quot;rust&quot;.to_string()
     }
 }

 impl ComSciStudent for A {
     fn git_username(&amp;self) -&gt; String {
         &quot;leepl37&quot;.to_string()
     }
 }

 fn comp_sci_student_greeting(student: &amp;dyn ComSciStudent) -&gt; String {
     format!(
         &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
         student.name(),
         student.university(),
         student.fav_language(),
         student.git_username()
     )
 }

 fn main() {
     
     let who = comp_sci_student_greeting(&amp;A);
     println!(&quot;{}&quot;, who);
 }
</code></pre></pre>
<h3 id="part7-disambiguating-overlapping-traits"><a class="header" href="#part7-disambiguating-overlapping-traits">part7 Disambiguating overlapping traits</a></h3>
<p>만일 두 개의 <code>trait</code> 을 impl 하였는데 동일한 이름이 존재한다면 어떻게 할 것인가?
<code>impl</code> 블락이 다르기 때문에 구현 시에는 문제가 없지만 해당 객체를 호출할 때 문제가 된다.
이럴 땐 full syntax 을 사용한다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait UsernameWidget {
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    fn get(&amp;self) -&gt; u8;
}

struct Form {
    username : String,
    age : u8,
}

impl UsernameWidget for Form {

    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
       self.age 
    }
}


fn main() {
    
    let form: Form = Form {
        username: &quot;rustacean&quot;.to_owned(),
        age: 35,
    };
    
    let t = UsernameWidget::get(&amp;form);

}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<h3 id="part-1-macro_rules"><a class="header" href="#part-1-macro_rules">part 1 macro_rules!</a></h3>
<p>러스트에 매크로 시스템은 메타프로그래밍이 가능하다. 함수와 비슷하지만 끝에 <code>!</code> (bang) 이 붙는다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
     
     // macro_rules! 매크로이름 {
     //  생성된 함수 =&gt; statement
     // }

     macro_rules! say_hi {
         () =&gt; {
             println!(&quot;hello&quot;);
         };
     }

     say_hi!();
 }</code></pre></pre>
<h3 id="part2-designators"><a class="header" href="#part2-designators">part2 Designators</a></h3>
<ul>
<li>매크로의 인수는 <code>$</code> 로 표현한다.
Designator 종류
<code>block</code>, <code>expr</code>, <code>ident</code>, <code>item</code>, <code>literal</code>(literal constants), <code>pat</code>(pattern), <code>path</code>, <code>stmt</code>(statement), <code>tt</code>(token tree), <code>ty</code>(type), <code>vis</code>(visibility qualifier)</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
fn main() {
     macro_rules! create_fn {
         // ident 라는 designator 를 사용하고 함수 $fn_name 을 생성한다.
         ($fn_name : ident) =&gt; {
             fn $fn_name() {
                 println!(&quot;I make fn name {:?}&quot;, stringify!($fn_name));
             }
         };
     }

     create_fn!(gwano);

     gwano();


     macro_rules! print_result {
         // expr 라는 designator 를 사용
         ($expression:expr) =&gt; {
             println!(&quot;{:?} = {:?}&quot;,
                     stringify!($expression),
                     $expression);
         };
     }

     print_result!(2 + 2);

 }</code></pre></pre>
<h3 id="part3-overload"><a class="header" href="#part3-overload">part3 Overload</a></h3>
<p>매크로는 다른 조합의 인수도 오버로드를 통해 받아들일 수 있다.
<code>match</code> 와 비슷하게 동작한다.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
macro_rules! test {
     ($left:expr; and $right:expr) =&gt; {
         println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right) // bool
     };
     // 새로운 단락에서 (arm) 세미콜론을 붙여줘야 한다.
     ($left:expr; or $right:expr) =&gt; {
         println!(&quot;{:?} or {:??} is {:?}&quot;,
                  stringify!($left),
                  stringify!($right),
                  $left || $right) // bool
     }
 }

 fn main() {
     test!(1i32 + 1 == 2; and 2i32 + 0 == 2); // bool type만 비교 가능
     test!(5i32 + 5 == 10; and 10i32 + 5 == 15); //bool type만 비교 가능
 }

</code></pre></pre>
<h3 id="part4-repeat"><a class="header" href="#part4-repeat">part4 Repeat</a></h3>
<ul>
<li><code>+</code> 인수로 사용하는데, 이는 적어도 한번은 반복하겠다는 의미이다.</li>
<li><code>*</code> 아예 반복을 하지 않거나 여러 번 하겠다는 뜻.</li>
<li><code>$(...), +</code> 로 감싸진 인수는 이에 맞는 단락에 매치되고 <code>,</code> 로 다음 인수를 분류한다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
 macro_rules! find_min {
     ($x:expr) =&gt; ($x); // A Case

     ($x:expr, $($y:expr),+) =&gt; (  // B, C Case

         std::cmp::min($x, find_min!($($y),+))
         )
     }

 fn main() {
         println!(&quot;{}&quot;, find_min!(1)); // A Case

         println!(&quot;{}&quot;, find_min!(1 + 2, 2)); // B Case
         // 3, 2 =&gt; min(3, 2) =&gt; 2
         println!(&quot;{}&quot;, find_min!(5, 2 * 3, 4)); // C Case
         // 5, (6, 4) =&gt; min(6, 4) =&gt; 4 =&gt; min(5, 4) =&gt; 4
 }

</code></pre></pre>
<h3 id="part5-dont-repeat-yourself"><a class="header" href="#part5-dont-repeat-yourself">part5 Don't Repeat Yourself</a></h3>
<pre><pre class="playground"><code class="language-rust edition2021"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>use std::ops::{Add, Mul, Sub};

 macro_rules! assert_equal_len {
     // The `tt` (token tree) designator is used for
     // operators and tokens.
     ($a:expr, $b:expr, $func:ident, $op:tt) =&gt; {
         assert!($a.len() == $b.len(),
                 &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                 ($a.len(),),
                 stringify!($op),
                 ($b.len(),));
     };
 }

 macro_rules! op {
     ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
         fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
             assert_equal_len!(xs, ys, $func, $op);

             for (x, y) in xs.iter_mut().zip(ys.iter()) {
                 *x = $bound::$method(*x, *y);
                 // *x = x.$method(*y);
             }
         }
     };
 }

 // Implement `add_assign`, `mul_assign`, and `sub_assign` functions.
 op!(add_assign, Add, +=, add);
 op!(mul_assign, Mul, *=, mul);
 op!(sub_assign, Sub, -=, sub);

 mod test {
     use std::iter;
     macro_rules! test {
         ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
             #[test]
             fn $func() {
                 for size in 0usize..10 {
                     let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                     let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                     let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                     super::$func(&amp;mut x, &amp;y);

                     assert_eq!(x, z);
                 }
             }
         };
     }

     // Test `add_assign`, `mul_assign`, and `sub_assign`.
     test!(add_assign, 1u32, 2u32, 3u32);
     test!(mul_assign, 2u32, 3u32, 6u32);
     test!(sub_assign, 3u32, 2u32, 1u32);
 }
<span class="boring">}</span></code></pre></pre>
<h3 id="part-6-domain-specific-languagesdsls"><a class="header" href="#part-6-domain-specific-languagesdsls">part 6 Domain Specific Languages(DSLs)</a></h3>
<p>러스트에 속해 있는 embedded 된 macro 언어라고 생각하자. </p>
<pre><pre class="playground"><code class="language-rust edition2021">

 macro_rules! cal {
     (eval $e:expr) =&gt; {
         {
             let val: usize = $e; // 타입을 integer 로 제한한다. 
             println!(&quot;{} = {}&quot;, stringify!{$e}, val);
         }
     };
 }


 fn main(){

     cal! {
         eval 1 + 2
     }

     cal! {
         eval 1 + 3 
     }
 }

</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="러스트-데이터-구조와-알고리즘"><a class="header" href="#러스트-데이터-구조와-알고리즘">러스트 데이터 구조와 알고리즘</a></h1>
<h3 id="chapters"><a class="header" href="#chapters">Chapters</a></h3>
<p>section 1</p>
<ul>
<li>about lifetime, generics that are most important in rust</li>
</ul>
<p>section 2</p>
<ul>
<li>sorting an algorithm complexity.</li>
</ul>
<p>section 3</p>
<ul>
<li>lists and tress (linked lists, binary tress etc)</li>
</ul>
<p>section 4</p>
<ul>
<li>about graph ( pathfinding algorithms)</li>
</ul>
<p>section 5 </p>
<ul>
<li>HashMap data structure</li>
</ul>
<p>section 6</p>
<ul>
<li>Organizing your data by type with Entity Component Systems</li>
</ul>
<p>section 7</p>
<ul>
<li>Persistent Storage Data structure ( something like a HashMap as a file)</li>
</ul>
<h3 id="goals"><a class="header" href="#goals">Goals</a></h3>
<ul>
<li>Confidence using Rust's Lifetime system.</li>
<li>Understanding of common algorithms (library algorithm).</li>
<li>Confidence building your own libraries based on.</li>
<li>Understanding of the design decisions made in building useable algorithms.</li>
<li>Knowing when to choose which kind of structure. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="section-1"><a class="header" href="#section-1">Section 1</a></h1>
<h3 id="results-and-options"><a class="header" href="#results-and-options">Results and Options</a></h3>
<p>this section, we are going to learn about Results and Options in rust.</p>
<p>Before using Results and Options in rust std lib, we are going to make our own result.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">//lets build our own result type.

#[derive(Debug)]
enum Res&lt;T, E&gt; {
    Thing(T),
    Error(E),
}

//우리가 만든 Res, result 타입은 T, E 제네릭 타입으로 어떤 타입으로도 생성이 가능하다.
//아래 함수에서 쓰일 T, E 의 타입은 i32, String 으로 정한다.
fn divide(a: i32, b: i32) -&gt; Res&lt;i32, String&gt; {
    if b == 0 {
        // b 가 0 이면 divide 가 불가능함으로 바로 return 한다.
        return Res::Error(&quot;0으로 나누는 것은 불가능합니다.&quot;.to_string());
    }
    Res::Thing(a / b)
}

fn main() {
    let a = divide(3, 0);

    if let Res::Error(e) = a {
        println!(&quot;error : {e}&quot;);
    }
}

</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">pub struct Stepper {
    curr: i32,
    step: i32,
    max: i32,
}

impl Stepper {
    fn new() -&gt; Self {
        Stepper {
            curr: 1,
            step: 3,
            max: 55,
        }
    }
}
impl Iterator for Stepper {
    // 현재 iter 를 구현한 stepper 의 item type 은 i32 이며
    type Item = i32;

    // next 함수 호출 시, max 값 보다 적을 때만 값을 리턴한다.
    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; {
        if self.max &lt; self.curr {
            return None;
        }
        // 현재 값을 리턴하고 curr 값에는 step 만큼 증가 시킨다.
        let res = self.curr;
        self.curr += self.step;
        Some(res)
    }
}

fn main() {
    // associate fn 을 이용하여 객체를 생성
    let mut step = Stepper::new();
    
    // 현재 값이 맥스 값 보다 작을 때에만 while 진행
    while step.curr &lt; step.max {
        //match 를 사용하여 증가 값을 보여주며 분기 적용.
        match step.next() {
            Some(v) =&gt; {
                println!(&quot;the current value is {:?}&quot;, v);
            }
            None =&gt; {
                println!(&quot;the step can not go higher anymore, the current value is {:?}, and max value is {:?}&quot;,                    step.curr, step.max);
            }
        }
    }
}
</code></pre></pre>
<!-- ### Stack Data Strutrue in Rust  -->
<!---->
<!--  what is a Stack ? -->
<!---->
<!--  * It is a list where items are added at one end and removed from the same endd -->
<!--  * For instance, like a stack of plates -->
<!--  * This mostly used in rapidly changing objects, parsers, and graphic processing like JavaScript Canvas operations -->
<h3 id="mutability-variables-copying-and-cloning"><a class="header" href="#mutability-variables-copying-and-cloning">Mutability, Variables, Copying, and Cloning</a></h3>
<p>we are going to learn about copying and cloning </p>
<ul>
<li>heap, and stack memory that can copy or not </li>
<li>type that implements copy trait and clone trait</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2021">
// 일반적으로 러스트에서는 struct를 복사하는 것은 불가능하다. 다른언어와는 다르기 때문에 이점을 많이 어려워한다.
// 예제를 살펴보자.

#[derive(Debug)]
struct Person {
    name : String,
    age : i32,
}

fn main() {
    let p = Person {
        name: &quot;Tony&quot;.to_string(),
        age: 35,
    };

    let p2 = p;

    println!(&quot;{:?}&quot;, p2);

    // p can not print because it is not impl copy trait. and String value is stored in the heap
    // memory. only stack memory implements copy trait automatically.
    
    // println!(&quot;{:?}&quot;, p);

    // but if we implements Clone trait, we can copy String into another section of memory

}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust edition2021">
// 하지만 derive 라는 컴포넌트 자바에 @하고 Service 등 하는 것과 비슷하다. 
// derive 로 Clone 을 implements 하게 되면 해당 struct 과 String 필드는 Clone 이 가능하다. 
// 즉 struct 이 복사가 가능해진다.

#[derive(Debug, Clone)] //  String 타입은 Clone trait 을 impl 함 
struct Person {
    name : String, 
    age : i32,
}



fn main() {
    let mut p = Person {
        name: &quot;Tony&quot;.to_string(),
        age: 35,
    };

    let p2 = p.clone();
    p.name.push_str(&quot;lee&quot;);
    println!(&quot;{:?}&quot;, p2);
    
    // p can not print because it is not impl copy trait. and String value is stored in the heap
    // memory. only stack memory implements copy trait automatically.

    println!(&quot;{:?}&quot;, p);

    // Copy 를 implements 한 타입 적용.
    #[derive(Debug, Clone, Copy)] // 안에 필드는 copy trait 를 impl 한 타입이라 copy 를 적용해야
                                 // 함. 단 Clone 도 해야하는데, 이유는 객체도 복사해야되기 때문. 
    struct Point {
        x : i32,
        y : i32,
    }

    let pnt = Point {x: 3, y: 3};

    let pnt2 = pnt; // .copy() 를 호출할 필요 없음 
   		    // copy trait 와 clone trait 의 차이점이 존재. -- copy 는 호출할 필요 없음.  
    println!(&quot;{:?}&quot;, pnt);
    
}</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="did-document-생성하기"><a class="header" href="#did-document-생성하기">DID document 생성하기.</a></h1>
<h2 id="1-사전-준비"><a class="header" href="#1-사전-준비">1. 사전 준비</a></h2>
<h3 id="11-파일-다운로드-및-환경-구성"><a class="header" href="#11-파일-다운로드-및-환경-구성">1.1 파일 다운로드 및 환경 구성</a></h3>
<ul>
<li>
<p>DID 생성 파일 <a href="https://dev.mobileid.go.kr/mip/dfs/downapi/useguidedown.do">Download</a></p>
<ul>
<li>검색어에 파일명(<code>SP 서버 Wallet &amp; DID 생성가이드</code>) 입력 후 조회</li>
</ul>
</li>
<li>
<p>환경 구성
- 자바 설치 후 환경변수 설정</p>
</li>
</ul>
<h3 id="12-폴더-구성"><a class="header" href="#12-폴더-구성">1.2 폴더 구성</a></h3>
<p><img src="spManual/./images/files.png" alt="steps" /> </p>
<h2 id="2-생성"><a class="header" href="#2-생성">2. 생성</a></h2>
<h3 id="참고사항"><a class="header" href="#참고사항">참고사항</a></h3>
<p><span style='background-color:#f7ddbe'>서버 설정 시 필요한 항목(application.properties)</span> 
<br></p>
<ul>
<li><code>PASSWORD</code> - step 2 에서 진행</li>
<li><code>ECC KEY ID</code> - step 3 에서 진행</li>
<li><code>RSA KEY ID</code> - stpe 4 에서 진행</li>
<li><code>wallet</code> 과 <code>did</code> 파일 - step 7 에서 진행</li>
</ul>
<h3 id="step-1-생성-파일-실행"><a class="header" href="#step-1-생성-파일-실행">Step 1. 생성 파일 실행</a></h3>
<ul>
<li>리눅스 : <code>create_doc_linux.sh</code> 해당 파일 실행</li>
</ul>
<p><img src="spManual/./images/linux_r.png" alt="steps" /> </p>
<ul>
<li>윈도우 : <code>create_doc_window.bat</code> 해당 파일 실행 </li>
</ul>
<p><img src="spManual/./images/window_r.png" alt="steps" /> </p>
<h3 id="step-11-실행-후-화면"><a class="header" href="#step-11-실행-후-화면">Step 1.1 실행 후 화면</a></h3>
<p><img src="spManual/./images/step1.png" alt="steps" /> </p>
  개발 및 운영에 따라 `1` 또는 `2` 를 선택한다.
<h3 id="step-2-패스워드-입력"><a class="header" href="#step-2-패스워드-입력">Step 2. 패스워드 입력</a></h3>
<p><img src="spManual/./images/step2.png" alt="steps" /> </p>
<p><code>wallet</code> 생성에 필요한 비밀번호를 입력받는다.(예시: <code>komsco1</code>)</p>
<h3 id="step-3-ecc-key-입력"><a class="header" href="#step-3-ecc-key-입력">Step 3. ECC KEY 입력</a></h3>
<p><img src="spManual/./images/step3.png" alt="steps" /> </p>
<p><code>wallet</code> 에 추가할 ECC KEY ID를 입력받는다.(예시: <code>komsco.sp</code>) </p>
<ul>
<li>확장자는 <code>.sp</code>가 되어야 한다. </li>
<li>default 값으로 하고 싶은 경우 <code>enter</code> 입력. </li>
</ul>
<h3 id="step-4-rsa-key-입력"><a class="header" href="#step-4-rsa-key-입력">Step 4. RSA KEY 입력</a></h3>
<p><img src="spManual/./images/step4.png" alt="steps" /> </p>
<p><code>wallet</code> 에 추가할 RSA KEY ID를 입력받는다.(예시: <code>komsco.sp.rsa</code>) </p>
<ul>
<li>확장자는 <code>.sp.rsa</code>가 되어야 한다. </li>
<li>default 값으로 하고 싶은 경우 <code>enter</code> 를 입력. </li>
</ul>
<h3 id="step-5-did-document-파일명-입력"><a class="header" href="#step-5-did-document-파일명-입력">Step 5. DID Document 파일명 입력</a></h3>
<p><img src="spManual/./images/step5.png" alt="steps" /> </p>
<p><code>DID Document</code> 파일명을 입력받는다.(예시: <code>komsco.did</code>) </p>
<ul>
<li>확장자는 <code>.did</code>가 되어야 한다. </li>
<li>default 값으로 하고 싶은 경우 <code>enter</code> 를 입력. </li>
</ul>
<h3 id="step-6-메시지-확인"><a class="header" href="#step-6-메시지-확인">Step 6. 메시지 확인</a></h3>
<p><img src="spManual/./images/finish.png" alt="steps" /> </p>
<p>위와 같은 메시지가 나오면 성공적으로 생성이 되었다. </p>
<h3 id="step-7-생성-파일-확인"><a class="header" href="#step-7-생성-파일-확인">Step 7. 생성 파일 확인</a></h3>
<p><img src="spManual/./images/result.png" alt="steps" /> </p>
<ul>
<li>해당 경로에서 <code>*.did</code> 와 <code>*.wallet</code> 파일을 확인할 수 있다. </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h3 id="sp-운영자-메뉴얼"><a class="header" href="#sp-운영자-메뉴얼">[SP 운영자 메뉴얼]</a></h3>
<ul>
<li>주제 : 모바일 신분증 SP 운영자 메뉴얼</li>
<li>버전 : v2.0</li>
<li>일자 : 2022-12-15</li>
<li>작성 : 라온시큐어 민기주</li>
</ul>
<h3 id="변경-이력"><a class="header" href="#변경-이력">[변경 이력]</a></h3>
<div class="table-wrapper"><table><thead><tr><th>버전</th><th>내용</th><th>일자</th><th>작성자</th></tr></thead><tbody>
<tr><td>1.0</td><td>최초수정</td><td>2021-11-23</td><td>LG CNS 컨소시엄</td></tr>
<tr><td>2.0</td><td>재수정</td><td>2022-12-15</td><td>라온시큐어 민기주</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h3 id="1-개요"><a class="header" href="#1-개요">1. 개요</a></h3>
<p>본 문서는 모바일 신분증을 이용한 서비스를 제공하고자 하는 SP(Service Provider)에게 다음의 정보를 제공함을 목적으로 한다.</p>
<ul>
<li>모바일 신분증 검증 서비스 개요</li>
<li>연계 절차</li>
<li>SP가 준비해야 할 항목</li>
<li>모바일 신분증 수행단 제공정보 및 기타</li>
</ul>
<h3 id="11-용어"><a class="header" href="#11-용어">1.1. 용어</a></h3>
<ul>
<li>mDL
<ul>
<li>Mobile Driver License의 약어</li>
<li>모바일 운전면허증 모바일 신분증</li>
</ul>
</li>
<li>모바일로 발급한 국가 신분증
<ul>
<li>현재는 모바일 운전면허증(mDL)만 있음 신분증앱</li>
</ul>
</li>
<li>신분증앱
<ul>
<li>&quot;모바일 신분증 앱&quot;의 줄임말 </li>
</ul>
</li>
<li>블록체인 계정
<ul>
<li>블록체인 노드 상에서 참여자를 식별하기 위한 계정</li>
<li>스마트 컨트랙트 호출을 위해 필요 </li>
</ul>
</li>
<li>서비스 코드
<ul>
<li>Holder가 제출한 VP를 검증하기 위해 블록체인에 등록한 서비스 구분자</li>
<li>매칭 정보: Verifier의 블록체인 계정, VC type, 검증할 개인정보 리스트 등 </li>
</ul>
</li>
<li>CLI (Command Line Interface)
<ul>
<li>명령창에서 실행 가능한 툴</li>
<li>Wallet 및 DID 생성 (Decentralized ID) 탈중앙화된 신원</li>
</ul>
</li>
<li>DID (Decentralized ID) 
<ul>
<li>탈중앙화된 신원</li>
</ul>
</li>
<li>DID Document (DID 문서)
<ul>
<li>DID의 요소로서 블록체인에 등록되어 누구나 조회 가능한 문서</li>
<li>DID 소유자의 id (예 - did:kr:mobileid:1234567890) 및 공개키 등이 저장됨 </li>
<li>W3C의 Decentralized Identifier v.1.0을 준수</li>
</ul>
</li>
<li>Holder
<ul>
<li>Issuer가 발급한 VC를 소유하는 주체</li>
</ul>
</li>
<li>Issuer
<ul>
<li>VC를 발급하는 주체</li>
</ul>
</li>
<li>Verififer
<ul>
<li>Holder가 제출한 VP를 검증하는 검증자</li>
<li>일반적으로 서비스를 제공하는 SP(Service Provider)가 verifier 역할을 수행함</li>
</ul>
</li>
<li>VC (Verifiable Credential)
<ul>
<li>Issuer(발급자)가 holder의 요청에 의해 holder의 개인정보를 증명 가능한 형태로 발급한 문서 W3C의 Verifiable Credential Data Model v.1.0을 준수</li>
</ul>
</li>
<li>VP (Verifiable Presentation)
<ul>
<li>Holder가 서비스를 제공받거나 기타 용도로 VC를 verifier에게 제출하기 위해 작성하고 서명한 문서 </li>
<li>여러 발급자의 여러 VC를 하나의 VP에 담을 수도 있음</li>
</ul>
</li>
<li>Wallet
<ul>
<li>개인키를 담고 있는 파일 형태의 암호화 지갑</li>
<li>DID의 개인키를 보관하고 있어 SDK 연동시 반드시 필요</li>
</ul>
</li>
</ul>
<h3 id="12-모바일-신분증-검증-서비스"><a class="header" href="#12-모바일-신분증-검증-서비스">1.2. 모바일 신분증 검증 서비스</a></h3>
<h3 id="121-이용-가능한-신분증"><a class="header" href="#121-이용-가능한-신분증">1.2.1. 이용 가능한 신분증</a></h3>
<div class="table-wrapper"><table><thead><tr><th>신분증</th><th>발급처</th><th>효력</th></tr></thead><tbody>
<tr><td>운전면허증</td><td>경찰청(도로교통공단)</td><td>- 대면 신원확인 <br> - 대면/비대면 자격확인, 성인여부확인 등 운전면허증 상 정보제공</td></tr>
</tbody></table>
</div>
<ul>
<li>대면 신원확인
<ul>
<li>Holder가 창구에 방문하거나 키오스크를 이용하는 등 검증자와 대면하는 경우</li>
<li>이 경우에는 이름, 주민등록번호 등을 제출하여 신원을 확인하는 기능으로 이용 가능</li>
<li>은행 홈페이지에 비회원 로그인 등 비대면 상황에서의 신원확인으로는 <span style="color:red">이용 불가함</span></li>
</ul>
</li>
<li>대면/비대면 자격확인
<ul>
<li>신원확인 이외의 운전면허 자격확인, 성인확인, 성별확인, 주소지 확인 등은 대면/비대면 모두 이용 가능</li>
</ul>
</li>
</ul>
<h3 id="122-인터페이스--송신모드"><a class="header" href="#122-인터페이스--송신모드">1.2.2. 인터페이스 &amp; 송신모드</a></h3>
<p>SP는 Holder에게 어떤 인터페이스와 송신모드로 VP를 제출받을지 미리 결정하여야 한다. 아래 표는 시범사업에서 선택 가능
한 인터페이스와 송신모드 목록이다.</p>
<p><img src="spmanual/./img/interface.png" alt="mpm" /> </p>
<p>인터페이스</p>
<div class="table-wrapper"><table><thead><tr><th>인터페이스</th><th>설명</th><th>비고</th></tr></thead><tbody>
<tr><td>QR-MPM</td><td>SP가 QR을 제시하고 holder가 촬영</td><td></td></tr>
<tr><td>App2pp</td><td>Holder의 동일 스마트폰에 신분증앱과 SP용 서비스 앱간 직접 통신</td><td></td></tr>
<tr><td>QR-CPM</td><td>Holder가 QR을 제시하고 SP가 촬영</td><td>전자출입명부와 같은 방식</td></tr>
</tbody></table>
</div>
<p>송신모드</p>
<div class="table-wrapper"><table><thead><tr><th><strong>모드</strong></th><th><strong>설명</strong></th><th><strong>비고</strong></th></tr></thead><tbody>
<tr><td><strong>direct</strong></td><td>verifier서버에 VP 직접 제출</td><td></td></tr>
<tr><td><strong>indirect</strong></td><td><strong>App2App</strong> : 서비스앱으로 VP 제출</td><td></td></tr>
<tr><td><strong>proxy</strong></td><td>QR-CPM 이거나, verifier서버와의 통신이 불가하여 중계서버를 이용하고자 하는 경우</td><td>웹소켓 연결</td></tr>
</tbody></table>
</div>
<h3 id="123-수집정보claim"><a class="header" href="#123-수집정보claim">1.2.3. 수집정보(Claim)</a></h3>
<h4 id="1231-claim-리스트"><a class="header" href="#1231-claim-리스트">1.2.3.1 Claim 리스트</a></h4>
<p>SP는Holder에게 다음의 정보(Claim)를 VP로 제출하도록 요청할 수 있다.</p>
<p><strong>[운전면허증VC]</strong></p>
<div class="table-wrapper"><table><thead><tr><th>코드</th><th>이름</th><th>타입</th><th>예시</th></tr></thead><tbody>
<tr><td>name</td><td>이름</td><td>string</td><td>&quot;홍길동&quot;</td></tr>
<tr><td>ihidnum</td><td>주민등록번호</td><td>string</td><td>&quot;8601021111111&quot;</td></tr>
<tr><td>address</td><td>주소</td><td>string</td><td>&quot;서울특별시종로구 XX대로 103&quot;</td></tr>
<tr><td>birth</td><td>생년월일</td><td>string</td><td>&quot;860102&quot;</td></tr>
<tr><td>dlno</td><td>운전면허증번호</td><td>string</td><td>&quot;10-20-123456-11&quot;</td></tr>
<tr><td>asort</td><td>면허종별</td><td>(구분자사용)</td><td>string</td></tr>
<tr><td>inspctbegend</td><td>적성검사시작,종료일자(구분자사용)</td><td>string</td><td>&quot;20220101,20221231&quot;</td></tr>
<tr><td>issude</td><td>발급일자</td><td>string</td><td>&quot;20141010&quot;</td></tr>
<tr><td>locpanm</td><td>지방경찰청명의</td><td>string</td><td>&quot;서울경찰청장&quot;</td></tr>
<tr><td>passwordsn</td><td>암호일련번호</td><td>string</td><td>&quot;A1XY28&quot;</td></tr>
<tr><td>inorgdonnyn</td><td>장기기증여부(구분사용)</td><td>string</td><td>&quot;Y&quot;</td></tr>
<tr><td>dlphotoimage</td><td>운전면허증사진이미지</td><td>hexstring</td><td>&quot;2f396a...6b3d&quot;</td></tr>
<tr><td>lcnscndcdnm</td><td>면허조건명(구분자사용)</td><td>string</td><td>&quot;A,D&quot;</td></tr>
</tbody></table>
</div>
<p><strong>[영지식VC]</strong></p>
<div class="table-wrapper"><table><thead><tr><th>코드</th><th>이름</th><th>설명</th></tr></thead><tbody>
<tr><td>zkpaddr</td><td>영지식주소(시/군/구/동)</td><td>상세주소</td></tr>
<tr><td>zkpsex</td><td>영지식</td><td>성별</td></tr>
<tr><td>zkpasort</td><td>영지식</td><td>면허종별(구분자사용)</td></tr>
<tr><td>zkpbirth</td><td>영지식</td><td>생년월일</td></tr>
</tbody></table>
</div>
<h3 id="1232-제출-방식"><a class="header" href="#1232-제출-방식">1.2.3.2. 제출 방식</a></h3>
<p>서비스신청서에 제출받을 claim을 선택하여 기재한다. VP 제출 방식은 다음 2가지가 있다.
※일반 VC와 영지식 VC를 섞어서 제출할 수 없음</p>
<ul>
<li>일반VP
<ul>
<li>운전면허증VC에서 제출받을 claim을 선택</li>
</ul>
</li>
<li>Holder의DID와 서명이 포함되므로 제출자 식별이 가능</li>
<li>영지식VP
<ul>
<li>영지식VC에서 제출받을 claim을 선택</li>
<li>Holder정보가 전혀 포함되지 않아 제출자 식별이 불가능</li>
<li>예를들어, &quot;영지식 생년월일(zkpbirth)&quot;을 제출받을 경우 SP가 제시한 기준일보다 이전에 태어났는지 파악 가능</li>
</ul>
</li>
</ul>
<h3 id="1233-서비스-코드"><a class="header" href="#1233-서비스-코드">1.2.3.3. 서비스 코드</a></h3>
<p>SP는 서비스 별로 제출받을 claim을 지정하여 1개 이상의 서비스 신청이 가능하다. 예를 들어,</p>
<ul>
<li>서비스#1
<ul>
<li>이름: 신원확인 서비스</li>
<li>Claims: 이름, 주민등록번호, 주소, 운전면허증사진이미지</li>
</ul>
</li>
<li>서비스#2
<ul>
<li>이름: 운전면허 자격확인 서비스</li>
<li>Claims: 이름, 운전면허증번호, 면허종별, 발급일자, 암호일련번호 </li>
</ul>
</li>
</ul>
<p>※ 단, 주민등록번호를 제출받으려면 해당 SP는 주민등록번호 수집이 가능한 기관이어야 함</p>
<h3 id="124-인증방식"><a class="header" href="#124-인증방식">1.2.4. 인증방식</a></h3>
<p>Holder는 SP에게 VP를 제출하기 위해 제출동의 및 인증을 수행하여야 한다. 인증에는 다음의 방식이 있다.</p>
<div class="table-wrapper"><table><thead><tr><th>인증방식</th><th>설명</th><th>비고</th></tr></thead><tbody>
<tr><td>PIN</td><td>비밀번호 인증</td><td></td></tr>
<tr><td>BIO</td><td>생체인증: 지문(Android),FaceID(iOS)</td><td>운영체제에 따라 다름</td></tr>
<tr><td>FACE</td><td>안면인식</td><td>운전면허증의 사진과 비교</td></tr>
</tbody></table>
</div>
<p>인증방식은 1개 이상 다중선택이 가능하며, 서비스코드 별로 인증방식을 지정하여야 한다.</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="2-준비-사항"><a class="header" href="#2-준비-사항">2. 준비 사항</a></h3>
<h3 id="21-수행단-제공-서버-정보"><a class="header" href="#21-수행단-제공-서버-정보">2.1. 수행단 제공 서버 정보</a></h3>
<p>서비스 제공에 필요한 서버는 다음과 같다.</p>
<div class="table-wrapper"><table><thead><tr><th>서버</th><th>IP</th><th>포트</th><th>설명</th></tr></thead><tbody>
<tr><td>(개발)읽기노드</td><td>103.4.48.153</td><td>18888</td><td>SSL 미적용</td></tr>
<tr><td>(개발)중계서버</td><td>103.4.48.154</td><td>9090</td><td>SSL 미적용, WebSocket 연결</td></tr>
</tbody></table>
</div>
<p><span style="color:red">SP서버에서 접속이 가능하도록 방화벽 설정을 미리 해 두어야 한다. </span></p>
<h3 id="211-읽기노드-접속-확인"><a class="header" href="#211-읽기노드-접속-확인">2.1.1. 읽기노드 접속 확인</a></h3>
<h4 id="2111-curl-이용"><a class="header" href="#2111-curl-이용">2.1.1.1. curl 이용</a></h4>
<pre><code class="language-console">1 | $ curl -v http://103.4.48.153:18888/v1/chain/get_info 
2 | * Trying 103.4.48.153...
3 | * TCP_NODELAY set
4 | * Connected to 103.4.48.153 (103.4.48.153) port 18888 (#0) 
5 | &gt; GET /v1/chain/get_info HTTP/1.1
6 | &gt; Host: 103.4.48.153:18888
7 | &gt; User-Agent: curl/7.55.1
8 | &gt; Accept: */*
9 | &gt; 
10| &lt; HTTP/1.1 200 OK 
11| &lt; Access-Control-Allow-Headers: * 
12| &lt; Access-Control-Allow-Origin: * 
13| &lt; Connection: close 
14| &lt; Content-Length: 793 
15| &lt; Content-type: application/json 
16| &lt; Server: WebSocket++/0.7.0
17| &lt; 
18| {&quot;server_version&quot;:&quot;0d87dff8&quot;,&quot;chain_id&quot;:&quot;101ece14e68c7a5c47565f352bfe
4633457f71b4452cddd81f5c11b221cccddb&quot;,&quot;head_block_num&quot;:4801403,
&quot;last_irreversible_block_num&quot;:4801362, 
&quot;last_irreversible_block_id&quot;:&quot;00494352907a0ce8525167f500be7bf64df8b3db6f8996d903080a0 
165f6eca2&quot;,
&quot;head_block_id&quot;:&quot;0049437bbe3f10cea9b1c65bad14c2895dd422369a0079c5190758500 09560b3&quot;,
&quot;head_block_time&quot;:&quot;2021-11-23T07:57:56.000&quot;,&quot;head_block_producer&quot;:&quot;producer1 &quot;,
&quot;virtual_block_cpu_limit&quot;:200000000,&quot;virtual_block_net_limit&quot;:1048576000,
&quot;block_cpu _limit&quot;:200000,&quot;block_net_limit&quot;:1048576,&quot;server_version_string&quot;:&quot;v2.0.7&quot;,
&quot;fork_db_he ad_block_num&quot;:4801403,&quot;fork_db_head_block_id&quot;:
&quot;0049437bbe3f10cea9b1c65bad14c2895dd422 369a0079c519075850009560b3&quot;,
&quot;server_full_version_string&quot;:&quot;v2.0.7-0d87dff8bee56179aa01 472dd00a089b2aa7b9fa-dirty&quot;}
 * Closing connection 0
</code></pre>
<h3 id="2-1-1-2-브라우저-이용"><a class="header" href="#2-1-1-2-브라우저-이용">2-1-1-2 브라우저 이용</a></h3>
<p>웹 브라우저에 아래 URL을 입력하여 응답 데이터를 확인한다.</p>
<pre><code class="language-console">1 | http://103.4.48.153:18888/v1/chain/get_info
</code></pre>
<p><img src="spmanual/./img/2.1.1.2-url2.png" alt="url2_img" /> </p>
<h3 id="2-1-2-중계서버-접속-확인"><a class="header" href="#2-1-2-중계서버-접속-확인">2-1-2. 중계서버 접속 확인</a></h3>
<h4 id="2121-curl-이용"><a class="header" href="#2121-curl-이용">2.1.2.1. curl 이용</a></h4>
<pre><code class="language-console">1 | $ curl -v http://103.4.48.154:9090/proxyServer 
2 | * Trying 103.4.48.154...
3 | * TCP_NODELAY set
4 | * Connected to 103.4.48.154 (103.4.48.154) port 9090 (#0) 
5 | &gt; GET /proxyServer HTTP/1.1
6 | &gt; Host: 103.4.48.154:9090
7 | &gt; User-Agent: curl/7.55.1
8 | &gt; Accept: */*
9 | &gt; 
10| &lt; HTTP/1.1 302 Found
11| &lt; Date: Tue, 23 Nov 2021 08:02:02 GMT
12| &lt; Location: http://103.4.48.154:9090/proxyServer/ 
13| &lt; Content-Length: 0
14| &lt; Server: Jetty(9.4.43.v20210629)
15| &lt; 
16| * Connection #0 to host 103.4.48.154 left int

</code></pre>
<h4 id="2122-브라우저-이용"><a class="header" href="#2122-브라우저-이용">2.1.2.2. 브라우저 이용</a></h4>
<pre><code class="language-console">1 | http://103.4.48.154:9090/proxyServer/
</code></pre>
<p><img src="spmanual/./img/brower_2.1.2.2-2.png" alt="mpm" /> </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="3-연계절차"><a class="header" href="#3-연계절차">3. 연계절차</a></h3>
<p>모바일 신분증 서비스 신청 및 등록 절차는 다음 그림과 같다. </p>
<p><img src="spmanual/./img/3-Verifier (SP).png"alt="url_img" /> </p>
<h3 id="31-wallet-did-생성"><a class="header" href="#31-wallet-did-생성">3.1. Wallet, DID 생성</a></h3>
<p>Wallet과 DID는 수행단이 제공한 CLI 툴을 이용한다. Wallet은 생성된 키를 암호화하여 저장하는 파일이므로 SP가 안전하게 보관하여야 한다. CLI 툴로 생성한 DID는 sp.did(생성 시 파일명 지정 가능)라는 파일에 로컬로만 만들어지는 것이므로 이를 블록체인에 등록하여야만 실제 사용이 가능하다. DID 등록은 Admin 권한을 가진 자만 가능하므로 수행단에 제출하여 등록을 의뢰하여야 한다.</p>
<p>Wallet&amp;DID 생성 파일 다운로드링크 <a href="https://dev.mobileid.go.kr/mip/dfs/downapi/useguidedown.do">생성파일</a></p>
<ul>
<li>SP 서버 Wallet&amp;DID 생성 가이드 클릭 후 다운로드.</li>
</ul>
<p>CLI 툴은 윈도우와 리눅스 운영체제에서 모두 실행이 가능하며 각각 아래의 단축 명령을 이용한다. </p>
<ul>
<li>윈도우: omni-cli.bat</li>
<li>리눅스: <span style="color:blue">omni-cli.sh</span></li>
</ul>
<h4 id="개발운영-구분에-따라-controller-did-변경"><a class="header" href="#개발운영-구분에-따라-controller-did-변경">개발/운영 구분에 따라 controller DID 변경</a></h4>
<ul>
<li>
<p>개발 : did:kr:mobileid:3pnuR77qKLZWnu4kaw4qmVtGcoZt</p>
</li>
<li>
<p>운영 : did:kr:mobileid:4VmgGJ3geNyyKRKupXDiCkw1kKw5</p>
</li>
</ul>
<h4 id="---for-linux"><a class="header" href="#---for-linux">-- for Linux</a></h4>
<hr />
<pre><code class="language-console">
// Wallet 생성 =&gt; sp.wallet

./omni-cli.sh keymanager createstore -p
./omni-cli.sh keymanager addkey -i omni.sp --keytype 0 -p
./omni-cli.sh keymanager addkey -i omni.sp.rsa --keytype 1 -p
./omni-cli.sh keymanager list -p


// DID Document 생성 (controller did 수정 금지) =&gt; sp.did   *controller did 값은 위에 입력된 개발과 운영에 따라 구분하여 입력함

//**운영용
./omni-cli.sh did2 create -i omni.sp --keymethod 3 -s sp.did --controller did:kr:mobileid:4VmgGJ3geNyyKRKupXDiCkw1kKw5 -p
//**개발용
./omni-cli.sh did2 create -i omni.sp --keymethod 3 -s sp.did --controller did:kr:mobileid:3pnuR77qKLZWnu4kaw4qmVtGcoZt -p

// 키(RSA) 추가 
./omni-cli.sh did2 addkey -i omni.sp.rsa --keymethod 4 -f sp.did -p

// 패스워드 변경시
./omni-cli.sh keymanager changepwd -m example_op.wallet -p -n


</code></pre>
<h4 id="---for-windows"><a class="header" href="#---for-windows">-- for Windows</a></h4>
<hr />
<pre><code class="language-console">
// Wallet 생성 =&gt; sp.wallet

omni-cli.bat keymanager createstore -p
omni-cli.bat keymanager addkey -i omni.sp --keytype 0 -p
omni-cli.bat keymanager addkey -i omni.sp.rsa --keytype 1 -p
omni-cli.bat keymanager list -p

// DID Document 생성 (controller did 수정 금지) =&gt; sp.did   *controller did 값은 위에 입력된 개발과 운영에 따라 구분하여 입력함
//**개발용 
omni-cli.bat did2 create -i omni.sp --keymethod 3 -s sp.did --controller did:kr:mobileid:3pnuR77qKLZWnu4kaw4qmVtGcoZt -p
//**운영용
omni-cli.bat did2 create -i omni.sp --keymethod 3 -s sp.did -controller did:kr:mobileid:4VmgGJ3geNyyKRKupXDiCkw1kKw5 -p

// 키(RSA) 추가 
omni-cli.bat did2 addkey -i omni.sp.rsa --keymethod 4 -f sp.did -p

// 패스워드 변경시
omni-cli.bat keymanager changepwd -m example_op.wallet -p -n

</code></pre>
<ul>
<li>더 자세한 설명을 원하시면 <a href="spmanual/chapter_3.html#etc.md">부록</a>을 참고해 주시기 바랍니다. </li>
</ul>
<h3 id="32-신청서-작성"><a class="header" href="#32-신청서-작성">3.2. 신청서 작성</a></h3>
<ol>
<li>
<p>신청서 양식 다운로드 : <a href="https://dev.mobileid.go.kr/mip/dfs/downapi/formdown.do">개발지원센터</a>.</p>
</li>
<li>
<p>다운로드 후 신청서를 작성한다. </p>
</li>
</ol>
<p>신청서 작성에 대한 자세한 문의는 조폐공사 이승훈 과장님(1042-214-1231)에게 문의한다. </p>
<h3 id="321-앱-테스트를-위한-엑셀파일-및-개인정보-동의서-작성"><a class="header" href="#321-앱-테스트를-위한-엑셀파일-및-개인정보-동의서-작성">3.2.1 앱 테스트를 위한 엑셀파일 및 개인정보 동의서 작성</a></h3>
<ol>
<li>
<p>앱 테스트를 위한 엑셀파일 작성한다.</p>
</li>
<li>
<p>개인정보 동의서를 작성한다.</p>
</li>
</ol>
<h3 id="322-제출"><a class="header" href="#322-제출">3.2.2 제출</a></h3>
<p>mid_apply@komsco.com 으로 생성한 DID 와 신청서, 개인정보 동의서, 작성된 엑셀을 제출한다.</p>
<h3 id="323-서비스코드와-sp계정--테스터-등록"><a class="header" href="#323-서비스코드와-sp계정--테스터-등록">3.2.3 서비스코드와 sp계정 &amp; 테스터 등록</a></h3>
<p>모바일신분증 운영단은 mid_apply@komsco.com 메일로 받은 did 파일을 블록체인 노드에 등록 후
해당 did에 대한 서비스코드와 sp 계정을 회신한다. </p>
<ul>
<li>이때 회신 메일에 적힌 sp 계정을 sp 서버 소스 코드 설정 파일에 입력한다. </li>
</ul>
<p>모바일신분증 운영단은 mid_apply@komsco.com 메일로 받은 엑셀에 대한 정보를 가지고 앱을 다운로드 받을 수 있는
링크를 전송하는데 이 링크를 통해 sp 는 테스트를 진행할 수 있다. </p>
<p>앱 설치 및 테스트는 링크 전송 시 파일을 첨부하여 안내된다. </p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="4-sp-서버-개발"><a class="header" href="#4-sp-서버-개발">4. SP 서버 개발</a></h3>
<p>SP 라이브러리 샘플소스코드 : <a href="https://dev.mobileid.go.kr/mip/dfs/downapi/useguidedown.do">개발지원센터</a>.</p>
<h3 id="41-설치-및-서버-구동"><a class="header" href="#41-설치-및-서버-구동">4.1 설치 및 서버 구동</a></h3>
<ol>
<li>Eclipse 또는 Intellij 를 사용하여 해당 프로젝트를 실행.</li>
<li>IDE 툴에서 jdk 1.7 또는 jdk 1.8 로 설정.</li>
<li>IDE 툴 플로그인에서 spring boot 다운 후 maven build 실행</li>
</ol>
<h3 id="42-applicationproperties-설정"><a class="header" href="#42-applicationproperties-설정">4.2 application.properties 설정</a></h3>
<h4 id="1-server-settings"><a class="header" href="#1-server-settings">1. Server Settings</a></h4>
<div class="table-wrapper"><table><thead><tr><th>key</th><th>config-value</th><th>비고</th></tr></thead><tbody>
<tr><td>app.blockchain-server-domain</td><td>개발과 운영에 맞는 주소를 설정한다.</td><td></td></tr>
<tr><td>app.sp-server</td><td>서비스할 주소를 입력</td><td></td></tr>
<tr><td>app.proxy-server</td><td>proxy 주소 입력</td><td>cpm 의 경우 사용</td></tr>
<tr><td>app.push-server-domain</td><td>push server 주소 입력</td><td>push 사용 시</td></tr>
</tbody></table>
</div>
<h4 id="2-sp--wallet-설정"><a class="header" href="#2-sp--wallet-설정">2. SP &amp; Wallet 설정</a></h4>
<div class="table-wrapper"><table><thead><tr><th>key</th><th>config-value</th></tr></thead><tbody>
<tr><td>app.keymanager-path</td><td>생성한 wallet을 해당 경로로 지정한다. <br> - app.keymanager-path=./example_op.wallet</td></tr>
<tr><td>app.keymanager-password</td><td>생성 시 입력한 패스워드 입력. <br> - app.keymanager-password=raon1234</td></tr>
<tr><td>app.sp-key-id</td><td>개발 지원 센터로 부터 안내 받은 계정 ?</td></tr>
<tr><td>app.sp-rsa-key-id</td><td>?</td></tr>
<tr><td>app.sp-account</td><td>개발지원센터로 부터 안내받은 계정?</td></tr>
<tr><td>app.sp-did-path</td><td>생성한 did의 위치를 저장한다. <br> app.sp-did-path=./example_op.sp.did</td></tr>
<tr><td>app.sp-bi-image-url</td><td>검증 시 보이는 이미지 url 주소<br> app.sp-bi-image-url=https://www.mobileid.go.kr/resources/images/main/mdl_ico_homepage.ico</td></tr>
<tr><td>app.sp-bi-image-base64</td><td>이미지에 대한 값을 base64로 인코딩</td></tr>
<tr><td>app.include-profile</td><td>?</td></tr>
<tr><td>app.sp-ci</td><td>ci 값을 안내받기 위한 여부</td></tr>
<tr><td>app.issuer-check-vc</td><td>서명 검증 여부</td></tr>
</tbody></table>
</div>
<p>질문 1. zpk, sdk, log, db, boot settings ??</p>
<div style="break-before: page; page-break-before: always;"></div><h3 id="5-sp-검증-인터페이스"><a class="header" href="#5-sp-검증-인터페이스">5 SP 검증 인터페이스</a></h3>
<h4 id="1-동작-모드-설명"><a class="header" href="#1-동작-모드-설명">1. 동작 모드 설명</a></h4>
<div class="table-wrapper"><table><thead><tr><th>분류</th><th>설명</th></tr></thead><tbody>
<tr><td>Indirect Mode</td><td>응대 장치가 VP를 받아 SP서버에게 전달하여 VP검증을 수행하는 모드<br> 암호화 필요</td></tr>
<tr><td>Direct Mode</td><td>SP서버가 VP를 받아 검증을 수행하는 모드<br> 응대 장치나 중계서버를 거치지 않기 때문에 암호화 필요 없음</td></tr>
<tr><td>Proxy Mode</td><td>SP서버나 응대 장치가 중계서버를 통해 VP를 받는 모드 <br> 암호화 필요</td></tr>
<tr><td>P2P Mode</td><td>응대 장치가 VP를 받아 VP검증을 수행 <br> 응대 장치가 VP를 바로 받거나(P2P Mode) 중계서버를 통해 VP를 받을 수 있음(P2P Proxy Mode)</td></tr>
</tbody></table>
</div>
<h4 id="11-qr-mpm"><a class="header" href="#11-qr-mpm">1.1 QR MPM</a></h4>
<ul>
<li>
<p>MPM 이란 Merchant Presentation Mode 의 약자이며 판매자 또는 서비스 제공자가 QR 을 제시하는 방법을 말한다.</p>
<ul>
<li>MPM 의 경우 두 가지 인터페이스가 존재
<ul>
<li>Direct</li>
<li>Proxy </li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="12-qr-cpm"><a class="header" href="#12-qr-cpm">1.2 QR CPM</a></h4>
<ul>
<li>
<p>CPM 이란 Customer Presentation Mode 의 약자이며 판매자 또는 서비스 제공자가 QR 을 촬영하는 방법을 말한다. </p>
<ul>
<li>CPM 의 경우 Proxy 모드만 존재한다. </li>
</ul>
</li>
</ul>
<h4 id="13-apptoapp"><a class="header" href="#13-apptoapp">1.3 AppToApp</a></h4>
<ul>
<li>
<p>AppToApp 이란 신분 검증을 하고자하는 App 에서 모바일 신분증 App 을 호출하여 검증하는 것을 말한다. </p>
<ul>
<li>AppToApp 의 경우 세 가지 인터페이스가 존재
<ul>
<li>Direct / Indirect </li>
<li>App-proxy mode </li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="table-wrapper"><table><thead><tr><th>mode</th><th>image</th></tr></thead><tbody>
<tr><td>QR MPM Direct</td><td><p><img src="spmanual/./img/qrmpm_direct.png" alt="mpm" /></p></td></tr>
<tr><td>설명</td><td>사용자가 PC Browser 이용 시, 검증자는 QR을 표시하고 모바일 신분증 앱은 QR에서 제공하는 URL에서 제출정보를 다운로드하고 검증자에게 직접 VP를 제출합니다.</td></tr>
<tr><td>QR MPM PROXY</td><td><p><img src="spmanual/./img/qrmpm_proxy.png" alt="mpm" /></p></td></tr>
<tr><td>설명</td><td>사용자가 PC Browser 이용 시, 검증자는 QR을 표시하고 모바일 신분증 앱은 QR에서 제공하는 URL에서 제출정보를 다운로드하고 중계서버를 통해서 검증자에게 VP를 제출합니다.</td></tr>
<tr><td>QR CPM PROXY</td><td><p><img src="spmanual/./img/qrcpm-proxy_mode.png" alt="cpm" /></p></td></tr>
<tr><td>설명</td><td>CPM기반 QR을 이용할 경우, 거래코드와 중계서버 URL을 QR로 표출하고 검증자의 디바이스는 해당 거래코드와 URL을 기반으로 제출정보를 전달하고 모바일 신분증 앱은 중계서버를 통해 VP를 제출합니다.  영지식 증명 데이터가 아닌 DID기반 VP 제출시에는 QR 표출 후 사용자 인증이 필요합니다.</td></tr>
<tr><td>APP2APP DIRECT / INDIRECT</td><td><p><img src="spmanual/./img/apptoapp_direct_indirect.png" alt="apptoapp" /></p></td></tr>
<tr><td>설명</td><td>사용자가 모바일 신분증 앱과 서비스 앱이 동일 디바이스 내에 설치되어 있는 경우, 앱간 통신으로 제출정보를 확인하고 검증자에게 직접 VP를 제출(direct) 혹은 호출한 앱으로 반환(indirect) 합니다.</td></tr>
<tr><td>APP2APP PROXY</td><td><p><img src="spmanual/./img/apptoapp_proxy.png" alt="apptoapp" /></p></td></tr>
<tr><td>설명</td><td>사용자가 PC Browser 이용 시, 검증자는 QR을 표시하고 모바일 신분증 앱은 QR에서 제공하는 URL에서 제출정보를다운로드하고 중계서버를 통해서 검증자에게 VP를 제출합니다.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="부록"><a class="header" href="#부록">부록</a></h1>
<p>매 명령 실행 시마다 동일한 입력을 생략하기 위해 <span style="color:purple">omni-cli.properties</span>에 이를 등록할 수 있다. 설정은 아래와 같다.</p>
<p>Wallet 암호는 보안을 위하여 매번 실행 시마다 입력하는 것을 권장한다.(-p 옵션을 주면 명령 실행 전 암호 입력) 그러므로 최 초 생성 시 적용한 암호는 잘 기억해 두어야 한다.</p>
<h3 id="wallet-생성"><a class="header" href="#wallet-생성">Wallet 생성</a></h3>
<pre><code class="language-console">1 | &gt; omni-cli.bat keymanager createstore -p
2 |
3 | Enter value for --keymanagerpass (keymanager password): 
4 | create call/
5 | Command: keymanger-&gt;createstore
6 | keymanagerType DEFAULT
7 | KeyStore Generate Success:sp.wallet

</code></pre>
<p><span style="color:purple">sp.wallet</span> 파일이 생성 되었음을 확인한다.</p>
<h3 id="ecc-키쌍-생성"><a class="header" href="#ecc-키쌍-생성">ECC 키쌍 생성</a></h3>
<p>서명용 ECC 키쌍을 생성하고 키 이름을 <span style="color:purple">omni.sp</span>로 지정한다. 이름은 자유롭게 변경이 가능하며 Verifier SDK 사용 시 설정파 일에 이 이름을 지정하면 된다.</p>
<pre><code class="language-console">1 | &gt; omni-cli.bat keymanager addkey -i omni.sp --keytype 0 -p 
2 |
3 | Enter value for --keymanagerpass (keymanager password):
4 | Command: keymanger-&gt;addkey
5 | keymanagerType DEFULT
6 | Unlock Success
7 | SECP256k1 key create
8 | Base58! = zBoekah8ZZAFPuystRhsKSi1biBY2TMzxSy4JcopqVoj
9 | HEX! = 0351aeb61260dd8b4c2090a470a52bcdc0470f40c68c637ceaaf8cdca334a096f6
</code></pre>
<ul>
<li>-i: 키 인덱스
<ul>
<li>향후 이 키를 참조할 때 사용할 이름</li>
</ul>
</li>
<li>--keytype: 키 종류 
<ul>
<li>0: ECC 키쌍 </li>
<li>1: RSA 키쌍</li>
</ul>
</li>
</ul>
<h3 id="rsa-키쌍-생성"><a class="header" href="#rsa-키쌍-생성">RSA 키쌍 생성</a></h3>
<p>암호화용 RSA 키쌍을 생성하고 키 이름을 omni.sp.rsa로 지정한다. 이름은 자유롭게 변경이 가능하며 Verifier SDK 사용 시 설정파일에 이 이름을 지정하면 된다.</p>
<pre><code class="language-console">1 &gt; omni-cli.bat keymanager addkey -i omni.sp.rsa --keytype 1 -p 
2
3 Enter value for --keymanagerpass (keymanager password):
4 Command: keymanger-&gt;addkey
5 keymanagerType DEFULT
6 Unlock Success
7 SECP256k1 key create
8 Base58! = zBoekah8ZZAFPuystRhsKSi1biBY2TMzxSy4JcopqVoj
9 HEX! = 0351aeb61260dd8b4c2090a470a52bcdc0470f40c68c637ceaaf8cdca334a096f6

</code></pre>
<ul>
<li>-i: 키 인덱스
<ul>
<li>향후 이 키를 참조할 때 사용할 이름</li>
</ul>
</li>
<li>--keytype: 키 종류 
<ul>
<li>0: ECC 키쌍 </li>
<li>1: RSA 키쌍</li>
</ul>
</li>
</ul>
<h3 id="키-목록-확인"><a class="header" href="#키-목록-확인">키 목록 확인</a></h3>
<pre><code class="language-console">1 | &gt; omni-cli.bat keymanager list -p
2 |
3 | Enter value for --keymanagerpass (keymanager password):
4 | Command: keymanger-&gt;list
5 | keymanagerType DEFULT
6 | Unlock Success
7 | Key Size: 2
8 | Index1-KeyID:omni.sp
9 | Index1-PublicKey:zBoekah8ZZAFPuystRhsKSi1biBY2TMzxSy4JcopqVoj
10| Index2-KeyID:omni.sp.rsa
11| Index2-PublicKey:
  | 2TuPVgMCHJy5atawrsADEzjP7MCVbyyCA89UW6Wvjp9HrBayS3H4kT7RvSwrmodxQXyi
  | vW2R9wPXs166oTT27GirNbmpCPUGMofAhXv265oCwwGkDLpvR1NW23fjv9uEb8r6bJr4TcKxE6jGTnJ9GAEKn 
  | zDwFvrHoypnoneMfhdToPdmL5W3YAs7ojXKHCzL54ULoSyUndy5M3njgW1gffAbtMwMN5sBtbHhnPwyMNZcG3 
  | DHb2epW4w2C9zYfgNQYfcVXeWeHC7VpgV32ZUJk3HLZMH3WaAYA52rSwmHVmn7NrLYsAmb34nWgpUSDK2tU2P 
  | wMjFmADGWNbr99gVXYujCYDKLrzvNU5J3ogFd6HkqPkJNiQvn7CxPTJ1v1774XASKgv8B7L8bENbNnU

</code></pre>
<h3 id="did-document-생성"><a class="header" href="#did-document-생성">DID Document 생성</a></h3>
<p>DID Document를 생성하고 서명용 ECC 공개키를 추가한다.</p>
<pre><code class="language-console"> 1 | &gt; omni-cli.bat did2 create -i omni.sp --keymethod 3 -s sp.did 
   |	--controller did:omn:3UGo7s2S3gC7doT7Ud3uo3rRJnab -p 
 2 | 
 3 | Enter value for --keymanagerpass (keymanager password): 
 4 | new did create call
 5 | Command: v2-&gt;create
 6 | keymanagerType DEFULT
 7 | {
 8 | 	&quot;authentication&quot;: [
 9 | 	{
 10| 		&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp&quot;
 11| 	} 
 12| 	],
 13| 	&quot;controller&quot;: &quot;did:omn:3UGo7s2S3gC7doT7Ud3uo3rRJnab&quot;, 
 14| 	&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ&quot;, 
 15| 	&quot;proof&quot;: {
 16| 		&quot;created&quot;: &quot;2021-11-23T20:35:37&quot;,
 17| 		&quot;creator&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp&quot;,
 18| 		&quot;nonce&quot;: &quot;99933519f4f50ff1111292b9234d1641ccc0f643&quot;,
 19| 		&quot;signatureValue&quot;: &quot;3rbzFqkcYRQkjbwtPFhb9VvekhwVja7amzm4pNqqXqHGBV5tZUVM8
   |					rB8KYyFoCKpyv6tSPUtRcZZvaV8HUtf9VcWT&quot;,
 20| 		&quot;type&quot;: &quot;Secp256k1VerificationKey2018&quot;
 21| 		},
 22| 		&quot;updated&quot;: &quot;2021-11-23T20:35:37&quot;, &quot;verificationMethod&quot;: [
 23| 		{
 24| 		&quot;controller&quot;: &quot;did:omn:3UGo7s2S3gC7doT7Ud3uo3rRJnab&quot;, 
   |				&quot;expirationDate&quot;: &quot;2021-12-03T23:59:59&quot;,
 25| 		&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp&quot;, 
   |		&quot;publicKeyBase58&quot;: &quot;zBoekah8ZZAFPuystRhsKSi1biBY2TMzxSy4JcopqVoj&quot;, 
   |		&quot;status&quot;: &quot;valid&quot;,
 26| 		&quot;type&quot;: &quot;Secp256k1VerificationKey2018&quot;
 27| 		} 
 28| 	]
 29| 	}
 30| DidDocument Save: sp.did

</code></pre>
<ul>
<li>-i
<ul>
<li>서명용 ECC 키 인덱스 </li>
</ul>
</li>
<li>--keymethod
<ul>
<li>3으로 고정 </li>
</ul>
</li>
<li>-s
<ul>
<li>생성할 DID Document 파일명</li>
<li>원하는 파일명으로 생성 가능</li>
</ul>
</li>
<li>--controller
<ul>
<li>DID Document 수정 권한을 가진 DID id</li>
<li>개발환경에서는 did:omn:3UGo7s2S3gC7doT7Ud3uo3rRJnab로 고정</li>
</ul>
</li>
</ul>
<h3 id="did-document에-rsa-공개키-추가"><a class="header" href="#did-document에-rsa-공개키-추가">DID Document에 RSA 공개키 추가</a></h3>
<p>Wallet에 있는 암호용 RSA 공개키를 DID Document에 추가한다.</p>
<pre><code class="language-console"> 1 | &gt; omni-cli.bat did2 addkey -i omni.sp.rsa --keymethod 4 -f sp.did -p
 2 | 
 3 | Enter value for --keymanagerpass (keymanager password): 
 4 | DID addkey Call......
 5 | Command: v2-&gt;addkey
 6 | keymanagerType DEFULT
 7 | Unlock Success 
 8 | {
 9 | 	&quot;authentication&quot;: [ 
 10| 		{
 11| 			&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp&quot; 
 12| 			}
 13| 		],
 14| 		&quot;controller&quot;: &quot;did:omn:3UGo7s2S3gC7doT7Ud3uo3rRJnab&quot;, 
 15| 		&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ&quot;, 
 16| 		&quot;keyAgreement&quot;: [
 17| 			{
 18| 			&quot;controller&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ&quot;,
 19| 			&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp.rsa&quot;, 
 20| 			&quot;publicKeyBase58&quot;: &quot;2TuPVgMCHJy5atawrsADEzjP7MCVbyyCA89UW6Wvjp9HrBayS3H4kT7RvSw
 21| 			rmodxQXyivW2R9wPXs166oTT27GirNbmpCPUGMofAhXv265oCwwGkDLpvR1NW23fjv9uEb8r6bJr4TcKxE6jG 
   | 			TnJ9GAEKnzDwFvrHoypnoneMfhdToPdmL5W3YAs7ojXKHCzL54ULoSyUndy5M3njgW1gffAbtMwMN5sBtbHhn 
   |			PwyMNZcG3DHb2epW4w2C9zYfgNQYfcVXeWeHC7VpgV32ZUJk3HLZMH3WaAYA52rSwmHVmn7NrLYsAmb34nWgp 
   | 			USDK2tU2PwMjFmADGWNbr99gVXYujCYDKLrzvNU5J3ogFd6HkqPkJNiQvn7CxPTJ1v1774XASKgv8B7L8bENb NnU&quot;,
 22| 			&quot;status&quot;: &quot;valid&quot;,
 23| 			&quot;type&quot;: &quot;RSAEncryptionKey&quot; 
 24| 			}
 25| 		], 
 26| 		&quot;proof&quot;: {
 27| 			&quot;created&quot;: &quot;2021-11-23T21:04:10&quot;,
 28| 			&quot;creator&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp&quot;,
 29| 			&quot;nonce&quot;: &quot;5c25cd7a5e703adb07889e32543fe782d5c5dd20&quot;,
 30| 			&quot;signatureValue&quot;: &quot;3rA4HzUDuN1FMBxeFgsNb9z3TPqSzDTSo91TYWpQvJc6w3HNauvT1Y7TjoSJQu
 31| 			7MNsByyGirWsv9BNTtxHEw7y9Ag&quot;,
 32| 			&quot;type&quot;: &quot;Secp256k1VerificationKey2018&quot;
 33| 			},
 34| 		&quot;updated&quot;: &quot;2021-11-23T21:04:10&quot;, &quot;verificationMethod&quot;: [
 35| 			{
 36| 			&quot;controller&quot;: &quot;did:omn:3UGo7s2S3gC7doT7Ud3uo3rRJnab&quot;, 
 37| 			&quot;expirationDate&quot;: &quot;2021-12-03T23:59:59&quot;,
 38| 			&quot;id&quot;: &quot;did:kr:mobileid:43eiB4Qorv2hV93Bg7eKHdkUAYHZ#omni.sp&quot;, 
 39| 			&quot;publicKeyBase58&quot;: &quot;zBoekah8ZZAFPuystRhsKSi1biBY2TMzxSy4JcopqVoj&quot;, 
 40|	 		&quot;status&quot;: &quot;valid&quot;,
 41| 			&quot;type&quot;: &quot;Secp256k1VerificationKey2018&quot;
 42| 			}
 43| 		]
 44| 	}
 45| DidDocument Save: sp.did
 46| 
</code></pre>
<ul>
<li>-i
<ul>
<li>암호화용 RSA 키 인덱스 </li>
</ul>
</li>
<li>--keymethod
<ul>
<li>4로 고정 </li>
</ul>
</li>
<li>-f
<ul>
<li>DID Document 파일명 </li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
