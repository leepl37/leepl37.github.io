<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10 - tony</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="一切唯心造">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item "><a href="../aboutNvim/nvim.html"><strong aria-hidden="true">2.</strong> aboutNvim&Linux</a></li><li class="chapter-item "><a href="../system/index.html"><strong aria-hidden="true">3.</strong> systemProgremming</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../system/lecture1.html"><strong aria-hidden="true">3.1.</strong> lecture1</a></li><li class="chapter-item "><a href="../system/lecture2.html"><strong aria-hidden="true">3.2.</strong> lecture2</a></li></ol></li><li class="chapter-item expanded "><a href="../rust_book/intro.html"><strong aria-hidden="true">4.</strong> The Rust Programming Language</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rust_book/3_common_programming_concepts.html"><strong aria-hidden="true">4.1.</strong> Common Programming Concepts, Ch3</a></li><li class="chapter-item "><a href="../rust_book/4_understanding_ownership.html"><strong aria-hidden="true">4.2.</strong> UNDERSTANDING OWNERSHIP, Ch4</a></li><li class="chapter-item "><a href="../rust_book/5_using_structs_to_structure_related_data.html"><strong aria-hidden="true">4.3.</strong> USING STRUCTS TO STRUCTURE RELATED DATA, Ch5</a></li><li class="chapter-item "><a href="../rust_book/6_enums_and_pattern_matching.html"><strong aria-hidden="true">4.4.</strong> ENUMS AND PATTERN MATCHING, Ch6</a></li><li class="chapter-item "><a href="../rust_book/7_managing_growing_projects_with_packages_creates_and_modules.html"><strong aria-hidden="true">4.5.</strong> MANAGING GROWING PROJECTS WITH PACKAGES, CREATES, AND MODULES, Ch 7</a></li><li class="chapter-item "><a href="../rust_book/8_common_collections.html"><strong aria-hidden="true">4.6.</strong> COMMON COLLECTIONS, Ch 8</a></li><li class="chapter-item "><a href="../rust_book/9_error_handling.html"><strong aria-hidden="true">4.7.</strong> ERROR HANDLING, Ch 9</a></li><li class="chapter-item expanded "><a href="../rust_book/10_generic_types_traits_and_lifetimes.html" class="active"><strong aria-hidden="true">4.8.</strong> GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10</a></li><li class="chapter-item "><a href="../rust_book/13_iterators_and_closures.html"><strong aria-hidden="true">4.9.</strong> FUNCTIONAL LANGUAGE FEATRUES : ITERATORS AND CLOSURES, ch 13</a></li><li class="chapter-item "><a href="../rust_book/14_more_about_cargo_and_creates_io.html"><strong aria-hidden="true">4.10.</strong> MORE ABOUT CARGO AND CREATES.IO, ch 14</a></li><li class="chapter-item "><a href="../rust_book/15_smart_pointers.html"><strong aria-hidden="true">4.11.</strong> SMART POINTERS, ch 15</a></li></ol></li><li class="chapter-item "><a href="../example/example.html"><strong aria-hidden="true">5.</strong> Rust by example(번역)</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello.html"><strong aria-hidden="true">5.1.</strong> Hello World 출력</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello/comment.html"><strong aria-hidden="true">5.1.1.</strong> Comments, 주석</a></li><li class="chapter-item "><a href="../example/hello/print.html"><strong aria-hidden="true">5.1.2.</strong> Formatted print, 출력에 관해</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/hello/debug_display.html"><strong aria-hidden="true">5.1.2.1.</strong> Debug & Display</a></li></ol></li><li class="chapter-item "><a href="../example/hello/testcase.html"><strong aria-hidden="true">5.1.3.</strong> TestCase: List(iter 개념과 Option 개념이 필요함)</a></li></ol></li><li class="chapter-item "><a href="../example/primitives.html"><strong aria-hidden="true">5.2.</strong> Primitives, 원시타입</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/primitives/arrays_and_slices.html"><strong aria-hidden="true">5.2.1.</strong> Arrays and Slices</a></li></ol></li><li class="chapter-item "><a href="../example/customtype.html"><strong aria-hidden="true">5.3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/customtype/testcase.html"><strong aria-hidden="true">5.3.1.</strong> TestCase: linked-list</a></li><li class="chapter-item "><a href="../example/customtype/constants.html"><strong aria-hidden="true">5.3.2.</strong> constants</a></li></ol></li><li class="chapter-item "><a href="../example/variablebinding.html"><strong aria-hidden="true">5.4.</strong> Variable Bindings,변수 바인딩</a></li><li class="chapter-item "><a href="../example/types.html"><strong aria-hidden="true">5.5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/types/casting_literals.html"><strong aria-hidden="true">5.5.1.</strong> casting_and_literals</a></li><li class="chapter-item "><a href="../example/types/inference_aliasing.html"><strong aria-hidden="true">5.5.2.</strong> inference_and_aliasing</a></li></ol></li><li class="chapter-item "><a href="../example/conversion/conversion.html"><strong aria-hidden="true">5.6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/conversion/from_and_into.html"><strong aria-hidden="true">5.6.1.</strong> From and Into, tryFrom and tryInto</a></li><li class="chapter-item "><a href="../example/conversion/to_and_from_strings.html"><strong aria-hidden="true">5.6.2.</strong> To and from Strings</a></li></ol></li><li class="chapter-item "><a href="../example/expressions.html"><strong aria-hidden="true">5.7.</strong> Expressions</a></li><li class="chapter-item "><a href="../example/flowAndControl/flow_and_control.html"><strong aria-hidden="true">5.8.</strong> Flow and Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/flowAndControl/for_and_iter.html"><strong aria-hidden="true">5.8.1.</strong> for_and_iter</a></li><li class="chapter-item "><a href="../example/flowAndControl/match.html"><strong aria-hidden="true">5.8.2.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/flowAndControl/pointer_and_ref.html"><strong aria-hidden="true">5.8.2.1.</strong> pointers/ref</a></li><li class="chapter-item "><a href="../example/flowAndControl/guards_and_binding.html"><strong aria-hidden="true">5.8.2.2.</strong> Guards/Binding</a></li></ol></li><li class="chapter-item "><a href="../example/flowAndControl/if_let_and_while_let.html"><strong aria-hidden="true">5.8.3.</strong> if let / while let</a></li></ol></li><li class="chapter-item "><a href="../example/functions/about_funtions.html"><strong aria-hidden="true">5.9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/functions/methods.html"><strong aria-hidden="true">5.9.1.</strong> Methods</a></li><li class="chapter-item "><a href="../example/functions/closures/closures.html"><strong aria-hidden="true">5.9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/functions/closures/capturing.html"><strong aria-hidden="true">5.9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="../example/functions/closures/as_input_parameters.html"><strong aria-hidden="true">5.9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="../example/functions/closures/as_output_parameters.html"><strong aria-hidden="true">5.9.2.3.</strong> As output parameters</a></li><li class="chapter-item "><a href="../example/functions/closures/iterator_searching_thro_iter.html"><strong aria-hidden="true">5.9.2.4.</strong> Examples in std</a></li></ol></li></ol></li><li class="chapter-item "><a href="../example/modules/modules.html"><strong aria-hidden="true">5.10.</strong> Modules</a></li><li class="chapter-item "><a href="../example/crates/crates.html"><strong aria-hidden="true">5.11.</strong> Crates</a></li><li class="chapter-item "><a href="../example/cargo/cargo.html"><strong aria-hidden="true">5.12.</strong> Cargo</a></li><li class="chapter-item "><a href="../example/attributes/attributes.html"><strong aria-hidden="true">5.13.</strong> Attributes, 속성</a></li><li class="chapter-item "><a href="../example/generics/generics.html"><strong aria-hidden="true">5.14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/generics/generic_associated_phantom.html"><strong aria-hidden="true">5.14.1.</strong> Associated items & Phantom type parameters</a></li></ol></li><li class="chapter-item "><a href="../example/scoping/scoping.html"><strong aria-hidden="true">5.15.</strong> Scoping rules-오너쉽, 참조, 라이프타임</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../example/scoping/ownership_move_borrowing.html"><strong aria-hidden="true">5.15.1.</strong> Ownership Move Borrowing</a></li><li class="chapter-item "><a href="../example/scoping/lifetimes.html"><strong aria-hidden="true">5.15.2.</strong> Lifetimes</a></li></ol></li><li class="chapter-item "><a href="../example/traits.html"><strong aria-hidden="true">5.16.</strong> Traits</a></li><li class="chapter-item "><a href="../example/macro.html"><strong aria-hidden="true">5.17.</strong> macro</a></li></ol></li><li class="chapter-item "><li class="part-title">Will be Deleted</li><li class="chapter-item affix "><li class="part-title">Datestructre and algorithms</li><li class="chapter-item "><a href="../dataStructureAndAlgorithms/intro.html"><strong aria-hidden="true">6.</strong> 데이터 구조와 알고리즘</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../dataStructureAndAlgorithms/section1.html"><strong aria-hidden="true">6.1.</strong> Section 1</a></li></ol></li><li class="chapter-item "><a href="../rustOS/intro.html"><strong aria-hidden="true">7.</strong> writing an OS in Rust</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../rustOS/freestandingRustBinary.html"><strong aria-hidden="true">7.1.</strong> A Freestanding Rust Binary</a></li></ol></li><li class="chapter-item "><li class="part-title">SP Manual</li><li class="chapter-item "><a href="../spmanual/start.html"><strong aria-hidden="true">8.</strong> SP MANUAL</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../spmanual/chapter_1.html"><strong aria-hidden="true">8.1.</strong> ch1</a></li><li class="chapter-item "><a href="../spmanual/chapter_2.html"><strong aria-hidden="true">8.2.</strong> ch2</a></li><li class="chapter-item "><a href="../spmanual/chapter_3.html"><strong aria-hidden="true">8.3.</strong> ch3</a></li><li class="chapter-item "><a href="../spmanual/chapter_4.html"><strong aria-hidden="true">8.4.</strong> ch4</a></li><li class="chapter-item "><a href="../spmanual/chapter_5.html"><strong aria-hidden="true">8.5.</strong> ch5</a></li><li class="chapter-item "><a href="../spmanual/etc.html"><strong aria-hidden="true">8.6.</strong> etc</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">tony</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="generic-type-traits-and-lifetimes-ch-10"><a class="header" href="#generic-type-traits-and-lifetimes-ch-10">GENERIC TYPE, TRAITS, AND LIFETIMES, Ch, 10</a></h1>
<p>Generics are abstract stand-:ine your own types, functions, and methods with generics. </p>
<ul>
<li>
<p>how to use generic type in struct and enum definitions. </p>
</li>
<li>
<p>how to use traits to define behavior in a generic way. </p>
<ul>
<li>combine traits with generic types to constrain a generic type to only those types that have a particular behavior. </li>
</ul>
</li>
<li>
<p>lifetimes, a variety of generics that give the compiler imformation about how reference relate to each other. lifetimes allow us to borrow values in many situations while still enabling the compiler to check that the references are valid. </p>
</li>
</ul>
<h3 id="in-function-definitions"><a class="header" href="#in-function-definitions">In Function Definitions</a></h3>
<p>we place the generics in the signature of the function. where we would usually specify the data types of the parameters and return value. </p>
<pre><code class="language-rs">
	// this function is generic over some type T 
	fn function&lt;T&gt;(param : T) -&gt; T {
		//...
	};

	
</code></pre>
<ul>
<li>you can use any type identifier as a type parameter name. But 'T' by convention, parameter names in Rust are short, often just a letter, and Rust's type-naming convention is CamelCase. &quot;type&quot;, T is the default choice of most Rust programmers. </li>
</ul>
<h3 id="in-struct-definitions"><a class="header" href="#in-struct-definitions">In Struct Definitions</a></h3>
<pre><code class="language-rs">struct Point&lt;T&gt; {
	x : T,
	y : T,
}

struct Differ_field&lt;T, U&gt; {
	x : T, 
	y : U,
}
</code></pre>
<h3 id="in-enum-definitions"><a class="header" href="#in-enum-definitions">In Enum Definitions</a></h3>
<pre><code class="language-rs">
enum Option&lt;T&gt; {
	Some(T), 
	None, 
}

enum Result&lt;T, E&gt; {
	Ok(T), 
	Err(E), 
}


</code></pre>
<h3 id="in-method-definitions"><a class="header" href="#in-method-definitions">In Method Definitions</a></h3>
<pre><code class="language-rs">struct Point&lt;T&gt; {
	x : T,
	y : T,
}

impl&lt;T&gt; Point&lt;T&gt; {
	fn x(&amp;self) -&gt; &amp;T {
		&amp;self.x
	}
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

</code></pre>
<ul>
<li>
<p>By declaring T as a generic type after impl, Rust can identify that the type in the angle brakets in point struct is a generic type. </p>
</li>
<li>
<p>we could implement concrete type method for Point struct. </p>
</li>
</ul>
<h3 id="performance-of-code-using-generics"><a class="header" href="#performance-of-code-using-generics">Performance of Code Using Generics</a></h3>
<p>Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. </p>
<ul>
<li>we pay no run time cost for using generics. </li>
</ul>
<h3 id="traits-defining-shared-behavior"><a class="header" href="#traits-defining-shared-behavior">Traits: Defining Shared Behavior.</a></h3>
<ul>
<li>
<p>tells the rust compiler about functionality a particular type has and can share with other type. </p>
</li>
<li>
<p>trait bounds is to specify a generic can be any time that has certain behavior. </p>
</li>
<li>
<p>group method signatures. </p>
</li>
<li>
<p>accomplish some purpose. </p>
</li>
</ul>
<pre><code class="language-rs">
trait Summary {
	fn summary(&amp;self) -&gt; String; 
}

</code></pre>
<ul>
<li>
<p>implementing a trait, compiler enforce you to implement all methods trait has. </p>
</li>
<li>
<p>we do not need to curly brakets for implement function, we use semiconlon instead. </p>
</li>
<li>
<p>we use alse curly brakets to implement function. ex) default fucntion.. </p>
</li>
</ul>
<h3 id="implementing-a-trait-on-a-type"><a class="header" href="#implementing-a-trait-on-a-type">Implementing a Trait on a Type.</a></h3>
<pre><code class="language-rs">
pub struct Tweet {
    pub username: String,
    pub content: String,
    pub reply: bool,
    pub retweet: bool,
}

impl Summary for Tweet {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{}: {}&quot;, self.username, self.content)
    }
}

</code></pre>
<ul>
<li>
<p>we can implement a trait on a type only if either the trait or the type is local to our crate. </p>
</li>
<li>
<p>this restriction is called, coherence, orphan rule. ( parent type is not present ) </p>
</li>
<li>
<p>two crates could implement the same trait for the same type, and Rust wouldn’t know which implementation to use.</p>
</li>
</ul>
<h3 id="default-implementaion"><a class="header" href="#default-implementaion">Default Implementaion.</a></h3>
<pre><code class="language-rs">
pub trait Summary {

   fn summarize_author(&amp;self) -&gt; String; 

   fn summarize(&amp;self) -&gt; String {
     String::from(&quot;(Read more...)&quot;)
	     }
     }

</code></pre>
<ul>
<li>Default implementations can call other methods in the same trait, even if those other methods don’t have a default implementation.</li>
</ul>
<pre><code class="language-rs">
impl Summary for Tweet {
    fn summarize_author(&amp;self) -&gt; String {
      format!(&quot;@{}&quot;, self.username)
    }
}

</code></pre>
<ul>
<li>Note that it isn’t possible to call the default implementation from an overriding implementation of that same method.</li>
</ul>
<h3 id="traits-as-parameters"><a class="header" href="#traits-as-parameters">Traits as Parameters.</a></h3>
<pre><code class="language-rs">
pub fn notify(item: impl Summary) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}


// trait bound syntax 

pub fn notify&lt;T: Summary&gt;(item: T) {
    println!(&quot;Breaking news! {}&quot;, item.summarize());
}

// where clauses 

fn some_function&lt;T, U&gt;(t: T, u: U) -&gt; i32
     where T: Display + Clone,
           U: Clone + Debug
{
   //...
}

</code></pre>
<h3 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that implement Traits.</a></h3>
<pre><code class="language-rs">
fn returns_summarizable(switch: bool) -&gt; impl Summary {
    if switch {
        NewsArticle {
            headline: String::from(&quot;Penguins win the Stanley Cup Championship!&quot;),
            location: String::from(&quot;Pittsburgh, PA, USA&quot;),
            author: String::from(&quot;Iceburgh&quot;),
            content: String::from(&quot;The Pittsburgh Penguins once again are the best
            hockey team in the NHL.&quot;),
        }
    } else {
        Tweet {
            username: String::from(&quot;horse_ebooks&quot;),
            content: String::from(&quot;of course, as you probably already know, people&quot;),
            reply: false,
            retweet: false,
       }
 }
}

</code></pre>
<ul>
<li>
<p>this code would not work. </p>
</li>
<li>
<p>due to restrictions around how the impl Trait syntax is implemented in the compiler. We’ll cover how to write a function with this behavior in “Using Trait Objects That Allow for Values of Different Types”</p>
<ul>
<li>**The ability to return a type that is only specified by the trait it implements is especially useful in the context of closures and iterators, which we cover in Chapter 13.</li>
</ul>
</li>
</ul>
<h3 id="using-trait-bounds-to-conditionally-implement-methods"><a class="header" href="#using-trait-bounds-to-conditionally-implement-methods">Using Trait Bounds to Conditionally Implement Methods.</a></h3>
<pre><code class="language-rs">
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}
 impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
   }
}
 impl&lt;T: Display + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {}&quot;, self.x);
        } else {
          println!(&quot;The largest member is y = {}&quot;, self.y);
        }
    }
}

</code></pre>
<ul>
<li>blanket implementations. </li>
</ul>
<h4 id="example-of-std"><a class="header" href="#example-of-std">example of std.</a></h4>
<pre><code class="language-rs">
// the ToString trait on any type that implements the Display trait. 

impl&lt;T: Display&gt; ToString for T {
    // --snip--
}

</code></pre>
<ul>
<li>
<p>we can call to_string method defined by the ToString Trait on any type that implements the Display trait. </p>
</li>
<li>
<p>Blanket implementations appear in the documentation for the trait in the “Implementors” section.</p>
</li>
<li>
<p>Traits and trait bounds let us write code that uses generic type parameters to reduce duplication</p>
</li>
<li>
<p>specify to the compiler that we want the generic type to have particular behavior.</p>
</li>
<li>
<p>In dynamically typed languages, we would get an error at runtime if we called a method on a type that the type didn’t implement. But Rust moves these errors to compile time so we’re forced to fix the problems before our code is even able to run.</p>
</li>
</ul>
<h3 id="validating-references-with-lifetimes"><a class="header" href="#validating-references-with-lifetimes">Validating References with Lifetimes.</a></h3>
<p>Although we won't cover lifetimes in their entirety in this chapter. </p>
<p>we'll discus common ways you might encounter lifetime syntax. </p>
<h3 id="preventing-dangling-references-with-lifetimes"><a class="header" href="#preventing-dangling-references-with-lifetimes">Preventing Dangling References with Lifetimes.</a></h3>
<p>it can prevent memory loss while referencing other data. </p>
<pre><pre class="playground"><code class="language-rust  runable  editable edition2021">{
	let r; 

	//println!(&quot;r : {}&quot;, r); 
	// rust does not allow null values. 
	
	{
		let x= 5; 
		r = &amp;x;
	}
	
	println!(&quot;r : {}&quot;, r);
	// x variable is dropped after the '}' culry braket. 
	// can not compile.
}</code></pre></pre>
<ul>
<li>'{}' scope can borrow check, compiler let you know where it need to be fixed. </li>
</ul>
<h3 id="generic-lifetimes-in-functions"><a class="header" href="#generic-lifetimes-in-functions">Generic Lifetimes in Functions.</a></h3>
<pre><code class="language-rs">	fn function(a : &amp;str, b : &amp;str) -&gt; &amp;str {
		if a.len() &gt; b.len() {
			return a
		}
		b	
	}
</code></pre>
<ul>
<li>
<p>borrow checker can't determine. </p>
</li>
<li>
<p>does not know how the lifetimes of x and y relate to the lifetime of the return value. </p>
</li>
<li>
<p>we'll add generic lifetime parameters that define the relationship between the references. </p>
</li>
</ul>
<pre><code class="language-rs">	fn function&lt;'a&gt;(a : &amp;'a str, b : &amp;'a str) -&gt; &amp;'a str {
		if a.len() &gt; b.len() {
			return a
		}
		b	
	}
</code></pre>
<ul>
<li>
<p>lifetime annotations describe the relationships of the lifetims of multiple references to each other without affecting the lifetimes.  // ?? </p>
</li>
<li>
<p>string slice returned from the function will live at least as long as lifetime 'a.</p>
</li>
<li>
<p>we're not changing the lifetimes of any values passed in or returned. </p>
</li>
<li>
<p>we're specifying that the borrow checker shoud reject any values that don't adhere to these contraints</p>
</li>
<li>
<p>this function doesn't need to know exactly how long x and y will live, only that some scope can be substited for 'a that will satisfy this signature. </p>
</li>
<li>
<p>the annotations go in the function signature, not in the function body. Rust can analyze the code within the function without any help. However, when a function has references to or from code outside that function, it becomes almost impossible for Rust to figure out the lifetimes of the parameters or return values on its own. The lifetimes might be different each time the function is called. This is why we need to annotate the lifetimes manually.</p>
</li>
<li>
<p>generic lifetime 'a will get the concrete lifetime that is equal to the smaller of the lifetimes of x and y. </p>
</li>
</ul>
<pre><code class="language-rs">	fn test&lt;'a&gt;(a : &amp;'a str, b : &amp;'a str) -&gt; &amp;'a str {
		if a.len() &gt; b.len() {
			return a
		}
		b	
	}

	{
		let string1 = String::from(&quot;xyz&quot;);
		let string2;
		{ 
			let string2_test = String::from(&quot;abc&quot;);
		}
		
		test(&amp;string1, &amp;string2);

		// can not compile because value that is referencing to string2 is already dropped.   

	}


</code></pre>
<ul>
<li>
<p>lifetime syntax is connecting the lifetimes of various parameters and return values of functions. </p>
</li>
<li>
<p>Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety. </p>
</li>
</ul>
<h3 id="lifetime-annotaions-in-struct-definitions"><a class="header" href="#lifetime-annotaions-in-struct-definitions">Lifetime Annotaions in Struct Definitions.</a></h3>
<pre><code class="language-rs">
struct ImportantExcerpt&lt;'a&gt; {
	
	part: &amp;'a str, 

}

</code></pre>
<ul>
<li>this annotation means can't outlive the reference it holds in its part field. </li>
</ul>
<h3 id="lifetime-elision"><a class="header" href="#lifetime-elision">Lifetime Elision.</a></h3>
<ul>
<li>first rule 
<ul>
<li>reference gets its own lifetime parameter.</li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
fn test1(a : &amp;'a str){}

fn test2(a: &amp;'a str, b: &amp;'a str){} 

</code></pre>
<ul>
<li>second rule 
<ul>
<li>if there is exactly one input lifetime parameter, that lifetime is assigned to all output lifetime parameters. </li>
</ul>
</li>
</ul>
<pre><code class="language-rs">
	fn test1(a : &amp;'a str) -&gt; &amp;'a str {}

</code></pre>
<ul>
<li>third rule 
<ul>
<li>one of them is &amp;self or &amp;mut self, the lifetime of self is assigned to all output lifetime parameters. </li>
</ul>
</li>
</ul>
<h3 id="lifetime-annotaions-in-method-definitions"><a class="header" href="#lifetime-annotaions-in-method-definitions">Lifetime Annotaions in Method Definitions</a></h3>
<ul>
<li>
<p>third rule applies. </p>
</li>
<li>
<p>Lifetime names for struct fields always need to be declared after the impl keyword and then used after the struct's name. its lifetimes are part of the struct's type. </p>
</li>
</ul>
<pre><code class="language-rs">
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; {
   fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str {
      println!(&quot;Attention please: {}&quot;, announcement);
      self.part
   }
}

</code></pre>
<ul>
<li>Rust applies the first lifetime elision rule and gives both &amp;self and announcement their own lifetimes. one of the parameters is &amp;self, the return type gets the lifetime of &amp;self. </li>
</ul>
<h3 id="the-static-lifetime"><a class="header" href="#the-static-lifetime">The Static Lifetime</a></h3>
<pre><code class="language-rs">
let s : &amp;'static str = &quot;I have a static lifetime.&quot;; 

</code></pre>
<ul>
<li>the text of this string is strored directly in the binary of your program. </li>
</ul>
<h3 id="generic-type-parameters-trait-bounds-and-lifetimes-together"><a class="header" href="#generic-type-parameters-trait-bounds-and-lifetimes-together">Generic Type Parameters, Trait Bounds, And LifeTimes Together.</a></h3>
<pre><code class="language-rs">
use std::fmt::Display;
fn longest_with_an_announcement&lt;'a, T&gt;(x: &amp;'a str, y: &amp;'a str, ann: T) -&gt; &amp;'a
str
   where T: Display
{
   println!(&quot;Announcement! {}&quot;, ann);
   if x.len() &gt; y.len() {
       x
   } else {
       y
   }
}

</code></pre>
<h3 id="summary"><a class="header" href="#summary">Summary</a></h3>
<ul>
<li>
<p>Trait and trait bounds ensure that even though the types are generic, they will have the behavior the code needs. </p>
</li>
<li>
<p>lifetime annotations to ensure that this flexible code won't have any dangling references at compile time. </p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../rust_book/9_error_handling.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../rust_book/13_iterators_and_closures.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../rust_book/9_error_handling.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../rust_book/13_iterators_and_closures.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
